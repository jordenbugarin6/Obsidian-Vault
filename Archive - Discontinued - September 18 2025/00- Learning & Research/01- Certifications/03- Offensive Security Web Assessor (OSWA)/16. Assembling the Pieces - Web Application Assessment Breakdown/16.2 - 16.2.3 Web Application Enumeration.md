Before continuing, we'll need to start the Asio challenge machine from the _Labs_ page. We'll make an entry in our `/etc/hosts` file so we can access the challenge machine via its hostname rather than IP address.

```bash
kali@kali:~$ sudo mousepad /etc/hosts

kali@kali:~$ cat /etc/hosts
127.0.0.1       localhost
127.0.1.1       kali

# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters

192.168.50.131  asio
```

We'll use this challenge machine for the rest of the Learning Module.

Now that we have the challenge machine running, we can start our web application assessment by performing basic host enumeration.

#### 16.2.2. Basic Host Enumeration and OS Detection

Let's start by enumerating the server using _Nmap_. Though most web applications run on the standard HTTP or HTTPS ports, they can run on any port or even multiple ports. For example, a web application might serve HTML content on port 80, which calls web services on port 8080. If we focus only on port 80 in this case, we might miss important functionality.

When conducting web application assessments, we need to strike a balance between the speed and coverage of automated tools. Running a quick scan with broad coverage will often provide us useful, actionable information. A longer, more comprehensive scan can be useful to ensure we don't miss anything, but we can often run these longer scans in the background while we perform manual testing.

With that in mind, we'll start with a basic Nmap scan of our target machine. Since we're not specifying any options about what to scan, Nmap will scan the 1000 most commonly used TCP ports. This option provides us with good coverage of the ports that web applications typically use.[1](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/web-application-enumeration-37067/accessing-the-challenge-machine-37056#fn-local_id_82-1)

```bash
kali@kali:~$ nmap asio
Starting Nmap 7.92 ( https://nmap.org ) at 2022-01-18 15:11 EST
Nmap scan report for asio (192.168.50.131)
Host is up (0.059s latency).
Not shown: 998 filtered tcp ports (no-response)
PORT     STATE SERVICE
80/tcp   open  http
3389/tcp open  ms-wbt-server

Nmap done: 1 IP address (1 host up) scanned in 5.80 seconds
```

Our Nmap scan identified two open ports. Servers usually run HTTP on port 80 and _Remote Desktop Protocol_ (RDP)[2](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/web-application-enumeration-37067/basic-host-enumeration-and-os-detection-37055#fn-local_id_82-2) usually runs on port 3389. We could be dealing with a Windows host.

Nmap includes an operating system (OS) detection feature. Let's run nmap again with the -O argument to enable this feature and -Pn to disable ping probes because we know the host is up. Unlike the previous scan, we'll need to run this command with sudo.

```bash
kali@kali:~$ sudo nmap -O -Pn asio       
Starting Nmap 7.92 ( https://nmap.org ) at 2022-01-18 15:12 EST
Nmap scan report for asio (192.168.50.131)
Host is up (0.059s latency).
Not shown: 998 filtered tcp ports (no-response)
PORT     STATE SERVICE
80/tcp   open  http
3389/tcp open  ms-wbt-server
Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port
Device type: specialized|general purpose
Running (JUST GUESSING): AVtech embedded (87%), Microsoft Windows XP (85%)
OS CPE: cpe:/o:microsoft:windows_xp::sp3
Aggressive OS guesses: AVtech Room Alert 26W environmental monitor (87%), Microsoft Windows XP SP3 (85%)
No exact OS matches for host (test conditions non-ideal).

OS detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 11.69 seconds
```

Nmap's output warns us that the "results may be unreliable" and the server could be AVtech embedded or Windows. Because we're dealing with a web application, we are more likely dealing with a Microsoft OS than an AVtech Room Alert 26W environmental monitor. However, we'll have to keep multiple operating systems in mind as we develop any exploits until we can definitively determine the correct OS.

Now that we have some basic, albeit incomplete, information about the host, we will turn our attention to the web application and perform content discovery.

#### 16.2.3 Content Discovery

Let's start by examining the web application to get a sense of its functionality. If we know the application's intended use, we can focus on areas that might include vulnerabilities or exploitable misconfigurations.

Our first step will be exploring the web application as a normal user. We'll do this with a browser proxied through _Burp Suite_ so we can capture all requests and responses for later inspection. Let's start Burp Suite, disable Intercept, open the embedded Chromium browser, and browse to the challenge machine.

![[Pasted image 20241107011333.png]]

The home page indicates we're dealing with a pizzeria. Before we continue, let's take a moment to review the _HTTP History_ tab in Burp Suite. Web applications will often load resources from multiple domains. These requests can clutter up Burp Suite if we don't filter them out.

![[Pasted image 20241107012156.png]]

As we suspected, the web application loads font files from an external domain. We have several ways to hide or exclude these external requests using Burp Suite's scope settings. When we add a URL to scope, we want to select the base URL so Burp treats all traffic to the site as "in scope". Let's scroll to the first request to `http://asio`, right-click on it, and select _Add to scope_.

***n the Burp Suite screenshots throughout this Learning Module, we have sorted the HTTP history tab in descending order based on request history. This places the newest requests at the top of the window, but is a personal preference.***

![[Pasted image 20241107012300.png]]

We'll receive a pop-up window asking us if we want to "stop sending out-of-scope requests to the history or other Burp tools?".\

![[Pasted image 20241107012602.png]]

We may want to inspect these requests later, so we'll click _No_ for now. We can still temporarily remove these items from the HTTP history tab by setting a filter. To do this, we'll click on the _Filter_ bar above the HTTP history table, which triggers a pop-up Filter settings window.

![[Pasted image 20241107012858.png]]


We'll click the checkbox for _Show only in-scope items_ and then click _Apply_. The HTTP history table will now filter out two requests to https://fonts.gstatic.com. As with any feature that limits or excludes data, we need to be careful to not exclude too many things, which might cause us to miss a vulnerability. By using a filter to remove external requests from HTTP history, Burp Suite still captures the external requests, but does not display them until we remove the filter. We can always remove the filter later if we need to review that HTTP traffic.

Let's continue exploring the web application. If we click on the links in the page's header, our browser scrolls to the relevant section of the page without loading a new URL.

The _Newsletter_ and _Contact_ sections include fields that seemingly allow us to submit data to the server. Let's submit values in these fields so we have examples in Burp Suite of what requests the application sends. We'll start with the Newsletter section. We'll type `web200@test.local` in the _Email_ field and then click _Subscribe_.

The web page does not reload and displays the message `Thanks for subscribing!`. Let's check the HTTP history tab in Burp Suite.

![[Pasted image 20241107013105.png]]
Our browser sent a POST request to /newsletter and the application responded with a short JSON body. Let's right-click on the POST request and select _Send to Repeater_ from the context menu so we can easily return to it if necessary.

Let's return to our browser and click on _Contact_. We'll fill out the _Name_, _Email_, and _Message_ fields. The values we use while testing functionality during a web application assessment don't matter very much. However, we will often find it useful to use values that will be easy to find or identify if the application stores them or reuses them some way. We'll type "web200" for the _Name_, "web200@test.local" in the _Email_ field, and "assembling the pieces" in the _Message_ field. Finally, we'll click _Send Message_.

Once again, the page updates without reloading. Checking HTTP history in Burp Suite, we find a POST request to /contact. Let's right-click on the request and select _Send to Repeater_ so we have a copy we can easily return to if necessary.

Now that we've explored all the functionality we can find on the home page, let's use another tool to search for more pages. Let's run gobuster in directory/file enumeration mode with the dir command. We'll specify our target URL with -u and a wordlist with -w.

```bash
kali@kali:~$ gobuster dir -u http://asio -w /usr/share/wordlists/dirb/common.txt   
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://asio
[+] Method:                  GET
[+] Threads:                 10
[+] Wordlist:                /usr/share/wordlists/dirb/common.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.1.0
[+] Timeout:                 10s
===============================================================
2022/01/18 15:38:10 Starting gobuster in directory enumeration mode
===============================================================
/admin                (Status: 302) [Size: 0] [--> http://asio/login]
/contact              (Status: 405) [Size: 105]                            
/error                (Status: 500) [Size: 73]                             
/login (Status: 200) [Size: 2746]
/logout               (Status: 302) [Size: 0] [--> http://asio/]     
/newsletter           (Status: 405) [Size: 108]                            
/redirect             (Status: 302) [Size: 0] [--> http://asio/]     
/specials             (Status: 400) [Size: 99]                             
                                                                           
===============================================================
2022/01/18 15:38:53 Finished
===============================================================
```

Gobuster found eight potential endpoints, but only one of them returned an HTTP 200 OK response. However, we can still infer useful information from the non-200 responses. For example, /admin returned an HTTP 302 Found response and redirected to /login. This means /admin is probably a valid endpoint that requires authentication.

The `/contact` and `/newsletter` endpoints returned HTTP 405 Method Not Allowed responses. When we were exploring the web page in our browser, we sent POST requests to these endpoints. Gobuster sends GET requests by default, so these responses seem normal.

Let's check the login page in our browser.

![[Pasted image 20241108141456.png]]

The login page allows us to log in with credentials or an API key. Unfortunately, we do not have either right now.

Next, let's check the `/error` page for any useful information.

![[Pasted image 20241108143059.png]]

The error page doesn't contain much. However, the message "you are seeing this as a fallback" suggests this might be a default error page. Because the page title is "Whitelabel Error Page", let's try googling that.

The top search results indicate that we might have found a default error page for _Spring Boot_, a framework for "running stand-alone Java applications".[1](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/web-application-enumeration-37067/content-discovery-37054#fn-local_id_271-1) Knowing the application's programming language and frameworks may be useful once we're ready to exploit it.

The last result from the Gobuster scan is for /specials, returning an HTTP 400 Bad Request. Specials is one of the links in the header of the home page, but none of those links reference other pages or endpoints. Burp Suite automatically builds a site map based on all proxied traffic. Let's take a moment to review the site map in Burp Suite by clicking on _Target_ and then clicking on _Site map_.

![[Pasted image 20241108143240.png]]

After expanding the site map, we find that our browser did make a GET request to /specials?menu=winter.html and received an HTTP 200 OK response. In contrast, Gobuster received an HTTP 400 response when it sent a GET request to the same endpoint without any query string values.

It is also interesting that our browser sent "winter.html" in a query string value rather than as part of the base URL. In fact, none of the pages we've interacted with have included an .html extension.

Let's send this request to Repeater so we can manually investigate it further in the next Learning Unit.

![[Pasted image 20241108143438.png]]
