Each type of web application vulnerability has a different target that usually falls into two categories: _client-side_ and _server-side_.

_Client-side_ attacks target the users of the web application or their browser. This usually requires some form of user interaction, which could range from clicking a specific link to simply opening a vulnerable page. These types of attacks typically result in [_session hijacking_](https://csrc.nist.gov/glossary/term/session_hijack_attack) or theft of sensitive data.

_Server-side_ attacks target the web application or its underlying server. These attacks tend to result in theft of sensitive data or _remote code execution_ (RCE) on the server.

--------------------------------------------------

#### 2.4.1 Authentication Bypass

When we run authentication bypass attacks, we're trying to gain new permissions within the target application. This could mean bypassing the authentication functionality entirely to log in without valid credentials through SQL injection, brute forcing credentials, or hijacking another user's session using cross-site scripting.

Depending on the configuration of the application, we might be able to abuse the application's [_Cross-Origin Resource Sharing_](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) (CORS) settings to perform malicious actions on behalf of another user.

Once we have an authenticated session, we could also try to elevate our permissions within the application to a different role, such as going from a regular user account to an administrative user account. We might achieve this by manipulating session cookies, using XSS or weak CORS to target an administrative user, or using SQL injection to manipulate our user account.

`ffuf -w output.txt -u http://enum-sandbox/auth/login -X POST -d 'username=e.freeman&password=FUZZ' -H 'Content-Type: application/x-www-form-urlencoded'`
utilized the file `output.txt` that was created in [[2.3 - 2.3.2 Sourcing Wordlists]] as the password field to find the password of `innovative`

![[Pasted image 20240717193414.png]]
![[Pasted image 20240717193527.png]]
Logging in
![[Pasted image 20240717193553.png]]

--------------------------------------------------

#### 2.4.2 Data Exfiltration

One common goal during a web application assessment is to determine if attackers can access restricted or sensitive data they shouldn't have access to.

As we gain access to a web application or a user's account, we need to determine if we can access sensitive data. This might include data about users, such as payment information (credit cards, gift cards, bank accounts, etc.) or [_personally identifiable information_](https://www.ibm.com/topics/pii) (PII). It could also include data related to the organization we are assessing, such as proprietary information.

Companies may be subject to significant fines, penalties, or lawsuits if they are breached by attackers and it's later determined they mishandled sensitive or regulatory data. For example, the _Securities and Exchange Commission_ (SEC) charged [_SolarWinds_](https://www.sec.gov/news/press-release/2023-227) with fraud after a hacking group compromised SolarWinds in 2019. SolarWinds also [_settled a class-action lawsuit_](https://www.securityweek.com/solarwinds-agrees-pay-26-million-settle-shareholder-lawsuit-over-data-breach/) from its investors for $26 million.

--------------------------------------------------

#### 2.4.3 Remote Code Execution

The most severe vulnerabilities result in _remote code execution_ (RCE), which allows us to execute arbitrary code on the target system or application. RCE vulnerabilities are particularly dangerous because they can allow attackers to take complete control of the target system.

Attackers could use RCE vulnerabilities to exfiltrate data, install malware, modify or delete files, or even use the compromised system to launch further attacks.

During a web application assessment, we'll typically use RCE to get a _shell_ on the server. This could be a _bind shell_, which waits for a connection, a _reverse shell_, which sends a shell back to our machine, or a _web shell_, which allows us to run OS commands or arbitrary code from our browser. We'll explore web shells more in the next section.

When we create a bind or reverse shell, we use programming language functionality or a binary on the target machine to interact with a [_socket_](https://docs.oracle.com/javase/tutorial/networking/sockets/definition.html). With a bind shell, we create an open socket on the target machine that waits for a connection. Once the bind shell is running, we need to connect to it in order to interact with it. To use a phone call metaphor, we make the call to connect to the bind shell.

However, even if we are able to start a bind shell on a server, the vulnerable server's network architecture may prevent us from connecting to the shell. An application exposed through a [_reverse proxy_](https://www.nginx.com/resources/glossary/reverse-proxy-server/) or running on server using [_Network Address Translation_](https://www.cisco.com/c/en/us/products/routers/network-address-translation.html) (NAT) might prevent us from accessing non-HTTP ports on the server.

A reverse shell sends a shell back to our system where we need a listener to handle the connection. To continue the phone call metaphor, the exploited machine makes the phone call to us and our listener answers the call.

One common tool we'll use when interacting with shells is [_Netcat_](http://www.stearns.org/nc/). There are actually two versions of Netcat: the "traditional" version and the [_openBSD_](https://man.openbsd.org/nc.1) version. Their high-level functionality is mostly the same from our perspective as attackers, with one noticeable difference. The traditional version has an option (**-e**) to execute a program after a connection is made. This feature is dangerous, as it can execute a shell environment, such as _bash_, giving the person connecting to the socket access to that environment.

We can use Netcat to create a bind shell, connect to a bind shell, or create a listener to handle a reverse shell based on the options we set when running it.

##### Bind Shell
Browse to **http://enum-sandbox/shells/**
- open bind shell on port `1337` - port 9999 want working
-  check that `i am a human`
![[Pasted image 20240717194404.png]]
Proof it was working
![[Pasted image 20240717195939.png]]
![[Pasted image 20240717200002.png]]
##### Reverse Shell
Browse to **http://enum-sandbox/shells/**
- open bind shell on port `1337` 
-  check that `i am a human`
- ![[Pasted image 20240717200225.png]]
![[Pasted image 20240717200154.png]]
##### Labs
![[Pasted image 20240717200418.png]]
`OS{3840e40f2b3f9c0d2fe212b17c17c1cb}`
![[Pasted image 20240717200321.png]]

--------------------------------------------------

#### 2.4.4 Web Shells

Similar to a traditional bind shell, a web shell provides an limited, shell-like interface through a script installed on a web server. Kali Linux includes several different web shells in **/usr/share/webshells**. These web shells are organized by programming language.

`tree /usr/share/webshells`
![[Pasted image 20240717200801.png]]