#### 11.1 Templating Engines
By the end of this Learning Unit, we should be able to:

1. Understand the purpose of templating engines
2. Understand the difference between statements and expressions
3. Understand the level of logic a templating engine can have and how it impacts security

-----------
#### 11.1.1. Accessing the Template Sandbox

In this Learning Module, we'll use three applications to learn about SSTI and the various templating engines:

- **Template Sandbox**: A custom sandbox application with access to multiple templating engines.
- **Halo CMS**: A CMS written in Java. Halo CMS contains an authenticated SSTI vulnerability that we will exploit.
- **Craft CMS**: Another CMS designed with PHP that we have configured to use a plugin vulnerable to SSTI.

In order to access these servers, we have created three `/etc/hosts` file entries on our Kali Linux VM.


```bash
kali@kali:~$ sudo mousepad /etc/hosts

kali@kali:~$ cat /etc/hosts
127.0.0.1       localhost
127.0.1.1       kali

# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters

192.168.50.101  template-sandbox
192.168.50.105  craft
192.168.50.105  halo
```

For now, we only need to start the Template Sandbox machine listed below and make the corresponding IP address update on our Kali machine before starting our work. We'll use this VM in several Learning Units before switching to the Halo and Craft VMs for their respective Case Studies.

---------------

#### 11.1.2 Introduction to Templating Engines

Templating engines can accept a generic document, known as a template, and combine it with a set of variables to create a final document. For example, let's review an email that an administrator wants to send to their customers.
```bash
Hello Dragan,

Thank you for your order! Your items will be shipped out shortly:

Widget - $10
	Quantity: 3
	Total: 	$30
Toolkit - $20
	Quantity: 1
	Total: 	$20
_______________
Total: 		$50

These items will be shipped to:

194 Bridge Avenue Elton, Louisiana 70532
```
While it's possible for the administrator to create a custom email for every order, it is much more convenient to create a template that can be reused multiple times:
```bash
01  Hello {{ name }},
02
03  Thank you for your order! Your items will be shipped out shortly:
04  {% for product in cart %}
05  {{product.name}}
06          Price:  ${{product.price}}
07          Quantity: {{product.quantity}}
08          Total:  ${{product.quantity * product.price}}
09  {% endfor %}____________________
10  Total:          ${{total}}
11
12  {% if cart|length > 1 %}
13  These items{% else %}
14  This item{% endif %} will be shipped to:
15  {{address}}
```
The template displayed in Listing 3 is using a popular templating engine called Jinja.[1](https://portal.offsec.com/courses/web-200-28380/learning/server-side-template-injection-discovery-and-exploitation-30963/templating-engines-31290/introduction-to-templating-engines-31052#fn-local_id_107-1) We'll inspect the various types of templating engines and their individual syntax later. However, while the syntax varies, the concepts are mostly the same.

Templates like the above would typically be compiled in a process much like compiling an application. This allows the template to be reused and various data to be passed into it.

A template like the one in Listing 3 would be paired with a set of variables that match the data the template would need. For this example, we'll use JSON to represent the data.
```json
{
	"name": "Dragan",
	"address": "194 Bridge Avenue Elton, Louisiana 70532",
	"cart": [
		{
			"name": "Widget",
			"quantity": 3,
			"price": 10
		},
		{
			"name": "Toolkit",
			"quantity": 1,
			"price": 20
		}
	],
	"total": 50
}
```
Let's dissect the template and review each component one by one. The template opens by greeting the user by name:
```json
01  Hello {{ name }},
...
```

The curly brackets, _{_ and _}_, are delimiters to instruct the templating engine where a template `expression` begins and ends. The delimiters are typically configurable to be any custom value.

In this templating engine, double opening curly brackets ({{) instruct the engine that an expression will follow, while double closing curly brackets (}}) indicate that the expression has ended. Effectively, this section will be replaced with the `name` variable from the data that is provided.

An expression produces a value. In this case, it displays the `name` value. An expression can also perform arithmetic, as we'll find later in the template. Some templating languages might call these `interpolations`.

For now, let's move on to the next section of the template that lists the products in the buyer's cart.

```json
04  {% for product in cart %}
05  {{product.name}}
06          Price:  ${{product.price}}
07          Quantity: {{product.quantity}}
08          Total:  ${{product.quantity * product.price}}
09  {% endfor %}
```
The portion of the template in Listing 6 will loop through the products in the cart and list their name, price, quantity, and the total. These instructions begin with an open curly bracket and a percent sign ({%), which indicates a `statement`. Unlike an expression, a statement can perform actions such as looping through a variable or checking with an `if` statement.

The lines between statement and expression are not clear and have some overlap. Different templating engines might have different terminology. It's important that, rather than getting stuck on definitions, we keep in mind that templating engines might have `if` statements and loops.

The syntax for this template's _for_ loop is similar to Python's syntax. For each item in the cart, a product is defined. Each product is expected to have a name, price, and quantity. Expressions, with the double curly brackets, are used to display the various attributes of a product on lines 5-7. On Line 8, a total is calculated by using an expression with the "`character to multiply the numbers`.

Finally, on line 9, we find the instruction that ends the `for` loop. A `for` loop doesn't require an ending character in Python because of the indentation; however, this templating engine requires an indicator to end the loop.

Next, the template displays the total using an expression.
```json
10  Total:          ${{total}}
```
Once that is complete, we find an `if` statement.
```json
12  {% if cart|length > 1 %}
13  These items{% else %}
14  This item{% endif %} will be shipped to:
15  {{address}}
```
Line 12 of Listing 8 begins by using a template statement to start the _if_ statement. Next, a _filter_[2](https://portal.offsec.com/courses/web-200-28380/learning/server-side-template-injection-discovery-and-exploitation-30963/templating-engines-31290/introduction-to-templating-engines-31052#fn-local_id_107-2) is used to obtain the length of the cart and determine if there are multiple items within.

A filter, sometimes called a _helper_, performs some action on the input and returns output, similar to a function in a programming language. Different templating engines will have different filters. Some templating engines might not provide any built-in filters, while others allow developers to create custom filters. An example of a custom filter would be one that takes a number, like the price of a product, and runs it through a currency filter to display the price in the user's local currency.

If the statement on line 12 in our template is true, the plural form will be used (_these items_). Otherwise, the singular form will be used (_this item_).

Finally, the recipient's address will be included in the text on line 15.

This example used a templating engine to more quickly create an email to be sent to a customer. However, templates and templating engines can also be used for configuration files in various environments (such as in _Ansible_[3](https://portal.offsec.com/courses/web-200-28380/learning/server-side-template-injection-discovery-and-exploitation-30963/templating-engines-31290/introduction-to-templating-engines-31052#fn-local_id_107-3)) or to generate the HTML displayed to a user. We will mostly be focusing on templating engines for use in web applications (HTML and email).

A correct implementation of a templating engine would mitigate many XSS vulnerabilities. So far, we've talked about expressions essentially acting as "find and replace". However, there is more going on behind the scenes. Most templating engines are developed assuming they will be used in web applications, and will therefore escape "dangerous" characters that might cause XSS. For example, if we were to set the name of our user to "<script>alert(0)</script>", the templating engine should replace the dangerous characters and output "&lt;script&gt;alert(0)&lt;/script&gt;".

Almost all templating engines also include syntax to bypass this escape. Usually, developers make this feature fairly obvious by designing the template to run the text through a filter named "safe" or "raw".

However, incorrect implementation of templates might result in the ability to inject arbitrary statements and expressions into a template. In general, templates are static files that do not accept direct user input. However, a developer will occasionally concatenate user-provided data into a template file or string. When this occurs, we might be able to inject our own template code.

Even more commonly, an application will include a feature allowing certain users to add and edit templates like emails, documents for printing, or even the UI.

If we can inject directly into the template or edit existing templates, we can bypass this default protection and display any parameter directly, or leverage the template's features to execute commands.

Since template engines are designed to display content, they may lack the ability to perform complex operations. The logic-less nature is commonly a design decision intended to force developers to keep complex manipulation of data in the main application code instead of the template. As we'll find later, the level of logic and sanitization available is highly dependent on each templating engine's design. Some engines allow for nearly full access to the underlying programming language, while others only allow for data display.

We should also note that depending on the architecture of the application, the HTML template rendering might be done server-side or client-side. This is important because on the server-side, injection could result in remote code execution or cross-site scripting. For client side-template rendering, the highest impact vulnerability would be XSS. Although we will mention a few templates that can be used on the client-side in this Learning Module, we will focus on those with server-side rendering.

Exploiting server-side template injection consists of three steps: discovering the injection point, finding the templating engine, and exploitation.

To understand how to discover and exploit a SSTI vulnerability, we first need to understand the various templating engines available.

| Templating Engine | Language       | Server/client Side |
| ----------------- | -------------- | ------------------ |
| Twig              | PHP            | Server Side        |
| Freemarker        | Java (usually) | Server Side        |
| Pug/Jade          | JavaScript     | Mostly Server Side |
| Jinja             | Python         | Server Side        |
| Handlebars        | JavaScript     | Both               |
| Mustache          | Multiple       | Varies             |
Table 1 lists some of the more popular templating engines used in applications. Although there are many other options available, we will focus on these. Each engine is intended to be used with a particular programming language, and many also offer varying degrees of logic to template developers.
![[Pasted image 20241022130610.png]]
Templating engines that are more logical do not strictly require the developer to separate underlying business logic from the frontend view.

Best practices for programming typically suggest that developers should separate the controller, or business logic, from how the final output is displayed. There are many reasons to do this, including increased security. It's also helpful, however, because it lets frontend developers focus on the frontend work and backend developers focus on backend work.

A logic-less templating engine might only allow for basic interaction with the data it's attempting to display; for example, basic arithmetic and _if_ statements. A logical templating engine might have filters to encode data, directly access the underlying programming language, or even run system commands. A frontend developer should not be able to run system commands on the backend server.

While logical templating engines increase developer flexibility, there can be a major drawback. Typically, logical templating engines increase the risk profile of the application if an injection is discovered.

As we will find, the syntax between these templating engines varies wildly. This can lead to sensitive information disclosure or remote code execution.

We will be using the Template Sandbox to generate various templates and interact with the templating engine. The cart template we have been working on is available at `/cart`. There are three main components to the sandbox: the template, the variables, and the output.

![[Pasted image 20241022130741.png]]
The template area in the top left displays the raw template. The output on the right side will update as we type. The variables at the bottom are broken down into two sections: string variables and non-string variables. The string variables allow us to define strings like "name" or "address", while the non-string variables allow us to define objects and arrays. It is possible to define strings in the non-string section too, but the string section is available for simpler use.