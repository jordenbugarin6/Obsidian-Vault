This Learning Unit covers the following Learning Objectives:

1. Understand where SSRF vulnerabilities are likely to occur
2. Understand how to test for SSRF
3. Understand how to verify SSRF vulnerabilities


Now that we have discussed the theory behind Server-side Request Forgery, let's discuss how we can discover it in web applications.

---------

#### 12.2.1. Accessing the SSRF Sandbox Application

We'll use two applications to learn about SSRF in this Learning Module:

- **SSRF Sandbox**: A custom sandbox application with intentionally vulnerable functionality.
- **Group-Office**: A dual license collaborative andÂ _Customer Resource Management_Â (CRM) that is vulnerable to SSRF.

We'll access these applications viaÂ /etc/hostsÂ entries on our Kali Linux VM.

```bash
kali@kali:~$ sudo mousepad /etc/hosts

kali@kali:~$ cat /etc/hosts
127.0.0.1       localhost
127.0.1.1       kali

# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters

192.168.50.101  ssrf-sandbox
192.168.50.105  groupoffice
```
For now, we only need to start the SSRF Sandbox machine listed below and update the corresponding IP address on our Kali machine before starting our work.

---------------
#### 12.2.2. Discovering SSRF Vulnerabilities

SSRF vulnerabilities can be present in applications that allow users to "upload" files from a link, rather than submitting a file directly. If we discover this kind of upload functionality or find suggestive parameters likeÂ _URL_,Â _URI_, orÂ _link_, we should test the application for SSRF. In some cases, the vulnerable application will request the resource we specify and then display the results of the request. This is known as aÂ _Basic SSRF_, and it allows us to easily retrieve data that we might not have direct access to.

Let's demonstrate this with the SSRF Sandbox application. We'll access theÂ _Preview Link_Â function at`http://ssrf-sandbox/preview`.

![[Pasted image 20241104122603.png]]

We can use this application to generate server-side requests withÂ _curl_,Â _wget_Â or Python'sÂ _requests_Â library.

Let's test this app by making a request toÂ http://www.megacorpone.com. We'll leaveÂ _Utility_Â set to "Requests Library", and clickÂ _Submit_.

![[Pasted image 20241104122653.png]]

Note that the SSRF Sandbox loaded the index page fromÂ http://www.megacorpone.com. The SSRF was successful and although the HTML did not render, we have access to the requested page's raw HTML source.

***Note that requests to other domains will most likely fail since the VMs in the lab environment do not have full access to the Internet.***

This is a fairly simple example. However, some applications accept a URL or link and will verify it exists with a GET or HEAD request. This is known asÂ _Blind SSRF_Â since we do not have direct access to the request's content. This is more difficult to exploit, but we can still leverage the information the application does return.

Let's demonstrate this with theÂ _Verify Link_Â function, which we can access by clickingÂ _Verify Link_Â on the top left-hand side of the application or by `browsing toÂ http://ssrf-sandbox/verify`.

![[Pasted image 20241104122815.png]]
Let's send a request toÂ `http://www.megacorpone.com`, leaveÂ _Utility_Â set to "Requests Library", and clickÂ _Submit_.

![[Pasted image 20241104123834.png]]

The page displays "URL verified" but we have no other indication of what the application did. Since we seem to control the full URL, let's send a request to a system we control: our Kali VM.

---------
#### 12.2.3. Calling Home to Kali

If we can force an application to connect to a server we control during an SSRF attack, we can gain greater insight into the application and the attack itself. Even if the application returns the results of the forged request, having the application request a page from our server can leak important information about the application through theÂ _User-Agent_Â header. In a real-world situation, we would need to make sure the victim machine could route to our vulnerable server. However, we can try this out in our lab environment with our Kali VM.

First, let's make sure we have Apache running.

```bash
kali@kali:~$ sudo systemctl restart apache2
```
Next, we'll submit our Kali VM's IP address in theÂ _URL_Â field.

***When we are performing this kind of testing in the real world, we should include a unique identifier in the URL. This would help us locate the attack in our log file.***

We'll browse toÂ `http://ssrf-sandbox/verify`. Let's type our IP address, including the HTTP protocol prefix, appended with "/hello_ssrf_world", and clickÂ _Submit_. The application might return a 404 status, but let's check our Apache log files with theÂ tailÂ command.

![[Pasted image 20241104130312.png]]
```bash
â”Œâ”€â”€(rootðŸ’€gobots)-[04Nov2024 18:02:00]-[/home/kali]
â””â”€# sudo tail /var/log/apache2/access.log
127.0.0.1 - - [04/Nov/2024:18:01:40 +0000] "GET / HTTP/1.1" 200 3380 "-" "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0"
127.0.0.1 - - [04/Nov/2024:18:01:40 +0000] "GET /icons/openlogo-75.png HTTP/1.1" 200 6041 "http://127.0.0.1/" "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0"
127.0.0.1 - - [04/Nov/2024:18:01:40 +0000] "GET /favicon.ico HTTP/1.1" 404 487 "http://127.0.0.1/" "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0"
192.168.231.101 - - [04/Nov/2024:18:01:55 +0000] "GET / HTTP/1.1" 200 3380 "-" "python-requests/2.26.0"

```
Excellent. The sandbox application made a GET request to our Kali VM. The request included "python-requests/2.26.0" as the user-agent. We've verified the SSRF vulnerability and also identified that the vulnerable application was written in Python.


#### Labs
1.
`curl/7.79.1`

![[Pasted image 20241104130719.png]]
```bash
â”Œâ”€â”€(rootðŸ’€gobots)-[04Nov2024 18:02:10]-[/home/kali]
â””â”€# sudo tail /var/log/apache2/access.log
127.0.0.1 - - [04/Nov/2024:18:01:40 +0000] "GET / HTTP/1.1" 200 3380 "-" "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0"
127.0.0.1 - - [04/Nov/2024:18:01:40 +0000] "GET /icons/openlogo-75.png HTTP/1.1" 200 6041 "http://127.0.0.1/" "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0"
127.0.0.1 - - [04/Nov/2024:18:01:40 +0000] "GET /favicon.ico HTTP/1.1" 404 487 "http://127.0.0.1/" "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0"
192.168.231.101 - - [04/Nov/2024:18:01:55 +0000] "GET / HTTP/1.1" 200 3380 "-" "python-requests/2.26.0"
192.168.231.101 - - [04/Nov/2024:18:03:53 +0000] "HEAD / HTTP/1.1" 200 255 "-" "curl/7.79.1"
```
![[Pasted image 20241104130738.png]]

2. `OS{tweedledumAndTweedledeeAgreedToHaveABattle}`
![[Pasted image 20241104132712.png]]
identified that the ssrf `/challenge` page is looking for the `/tweedledum` directory
![[Pasted image 20241104132504.png]]
created the `tweedledum` directory in the webroot
![[Pasted image 20241104132627.png]]
profit
![[Pasted image 20241104132557.png]]