```python
import os
import shutil
import time
import subprocess
import threading
import itertools
import sys
import argparse
from colorama import init, Fore, Style

# Initialize colorama
init(autoreset=True)

# === BASE DIRECTORY SETUP ===
base_dir = "/opt/cobaltstrike/arsenal-kit/arsenal-kit-mod"
artifact_dir = os.path.join(base_dir, "artifact-kit")
resource_dir = os.path.join(base_dir, "resource-kit")

# === COBALT STRIKE ACTIVE FILE LOCATIONS ===
artifact_kit_replace_dir = "/opt/cobaltstrike/arsenal-kit/kits/artifact/src-common"
resource_kit_replace_path = "/opt/cobaltstrike/arsenal-kit/kits/resource/compress.ps1"

# === MOD KIT DIRECTORY STRUCTURE ===
artifact_kit_original_dir = os.path.join(artifact_dir, "originals")
artifact_kit_bypass_dir   = os.path.join(artifact_dir, "bypass")
artifact_backup_dir       = os.path.join(artifact_dir, "backups")

resource_kit_original_dir = os.path.join(resource_dir, "originals")
resource_kit_bypass_dir   = os.path.join(resource_dir, "bypass")
resource_backup_dir       = os.path.join(resource_dir, "backups")

# === BUILD SCRIPT LOCATION ===
build_script_dir = "/opt/cobaltstrike/arsenal-kit"
build_script = os.path.join(build_script_dir, "build_arsenal_kit.sh")

# === FILE CONFIG ===
files_to_swap = ["patch.c", "bypass-pipe.c"]
resource_file_name = "compress.ps1"

def ensure_dirs():
    created_dirs = []
    for d in [
        artifact_kit_original_dir,
        artifact_kit_bypass_dir,
        artifact_backup_dir,
        resource_kit_original_dir,
        resource_kit_bypass_dir,
        resource_backup_dir
    ]:
        if not os.path.exists(d):
            os.makedirs(d)
            created_dirs.append(d)

    if created_dirs:
        print(Fore.GREEN + "\nüìÅ First-time setup detected.")
        for path in created_dirs:
            print(Fore.CYAN + f"  [+] Created: {path}")
        print(Fore.GREEN + "\n‚úÖ Directory structure initialized successfully.\n")
        time.sleep(1)

def timestamp():
    return time.strftime("%Y%m%d-%H%M%S")

def backup_files():
    ts = timestamp()
    for filename in files_to_swap:
        src = os.path.join(artifact_kit_replace_dir, filename)
        dst = os.path.join(artifact_backup_dir, f"{filename}.{ts}.bak")
        if os.path.exists(src):
            if not os.path.exists(dst):
                shutil.copy2(src, dst)

    if os.path.exists(resource_kit_replace_path):
        dst = os.path.join(resource_backup_dir, f"{resource_file_name}.{ts}.bak")
        if not os.path.exists(dst):
            shutil.copy2(resource_kit_replace_path, dst)

def switch_files(source_dir, resource_dir):
    if not os.listdir(source_dir) or not os.listdir(resource_dir):
        print(Fore.RED + Style.BRIGHT + "\n[!] Required files not found in one or more source directories.")
        print(Fore.RED + "    Ensure that Cobalt Build Manager has pre-configured files before attempting to enable or disable bypass modes.\n")
        return False

    backup_files()
    for filename in files_to_swap:
        src = os.path.join(source_dir, filename)
        dst = os.path.join(artifact_kit_replace_dir, filename)
        if os.path.exists(src):
            shutil.copy2(src, dst)

    resource_src = os.path.join(resource_dir, resource_file_name)
    if os.path.exists(resource_src):
        shutil.copy2(resource_src, resource_kit_replace_path)
    return True

def spider_loader(stop_event):
    spinner = [
        "üï∑Ô∏è  [‚ñ†         ]", "üï∑Ô∏è  [‚ñ†‚ñ†        ]", "üï∑Ô∏è  [‚ñ†‚ñ†‚ñ†       ]",
        "üï∑Ô∏è  [‚ñ†‚ñ†‚ñ†‚ñ†      ]", "üï∑Ô∏è  [‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†     ]", "üï∑Ô∏è  [‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†    ]",
        "üï∑Ô∏è  [‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†   ]", "üï∑Ô∏è  [‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†  ]", "üï∑Ô∏è  [‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ† ]",
        "üï∑Ô∏è  [‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†]"
    ]
    colors = [Fore.RED, Fore.YELLOW, Fore.GREEN, Fore.CYAN, Fore.MAGENTA]
    color_index = 0

    for frame in itertools.cycle(spinner):
        if stop_event.is_set():
            break
        color = colors[color_index % len(colors)]
        sys.stdout.write("\r\033[K")
        sys.stdout.write(f"{color}‚öôÔ∏è  Compiling Arsenal Kit {frame}   ")
        sys.stdout.flush()
        color_index += 1
        time.sleep(0.3)
    sys.stdout.write("\r\033[K")

def rebuild_artifact_kit(mode_label, silent=False):
    stop_event = threading.Event()
    thread = threading.Thread(target=spider_loader, args=(stop_event,))
    thread.start()
    try:
        subprocess.run(["bash", "build_arsenal_kit.sh"], cwd=build_script_dir,
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)
    except Exception:
        stop_event.set()
        thread.join()
        if not silent:
            print("\n‚ùå Build failed.")
        return

    stop_event.set()
    thread.join()

    if mode_label == "original":
        announce_disarmed()
    elif mode_label == "bypass":
        announce_armed()
    else:
        if not silent:
            print("‚úÖ Arsenal Kit rebuilt successfully.")

def announce_disarmed():
    print("\n" + Fore.YELLOW + "[+] Shutting down AV Bypass subsystem...")
    time.sleep(0.5)
    print(Fore.YELLOW + "[*] Restoring integrity modules...")
    time.sleep(0.5)
    print(Fore.YELLOW + "[!] Defensive protocols re-initialized.\n")
    print(Fore.RED + Style.BRIGHT + "üîª SYSTEM DISARMED ‚Äì AV BYPASS OFF üîª")

def announce_armed():
    print("\n" + Fore.CYAN + "[+] Injecting memory patch routines...")
    time.sleep(0.5)
    print(Fore.CYAN + "[*] Obfuscating artifact signatures...")
    time.sleep(0.5)
    print(Fore.CYAN + "[!] Evasion subsystem armed.\n")
    print(Fore.GREEN + Style.BRIGHT + "üî∫ SYSTEM ARMED ‚Äì AV BYPASS ON üî∫")

def show_menu():
    print("\n" + "‚ïê" * 50)
    print("üõ°Ô∏è  Arsenal Kit AV Control Panel".center(50))
    print("‚ïê" * 50)
    print(Fore.YELLOW + " [1] üîì Use ORIGINAL Kit Files     (No AV Evasion)")
    print(Fore.CYAN   + " [2] üß¨ Use BYPASS Kit Files       (Enable AV Evasion)")
    print(Fore.BLUE   + " [3] üîç Check Current Mode")
    print(Fore.RED    + " [4] ‚ùå Exit")
    print("‚ïê" * 50 + "\n")

def main():
    ensure_dirs()

    parser = argparse.ArgumentParser(description="Switch Cobalt Strike artifact kit mode.")
    parser.add_argument("--noav", action="store_true", help="Use original (non-bypass) files")
    parser.add_argument("--av", action="store_true", help="Use AV bypass files")
    parser.add_argument("--status", action="store_true", help="Check current active mode")
    args = parser.parse_args()

    if args.status:
        current_patch = os.path.join(artifact_kit_replace_dir, "patch.c")
        bypass_patch = os.path.join(artifact_kit_bypass_dir, "patch.c")
        if os.path.exists(current_patch) and os.path.exists(bypass_patch):
            with open(current_patch, 'rb') as curr_file, open(bypass_patch, 'rb') as bypass_file:
                if curr_file.read() == bypass_file.read():
                    print(Fore.GREEN + "\nüîç Current Mode: AV BYPASS ENABLED")
                else:
                    print(Fore.YELLOW + "\nüîç Current Mode: ORIGINAL (No AV Evasion)")
        else:
            print(Fore.RED + "\n‚ö†Ô∏è  Unable to determine current mode. Missing reference files.")

    elif args.noav:
        print(Fore.YELLOW + "\nüõ° Deactivating AV Bypass...\n")
        time.sleep(0.4)
        if switch_files(artifact_kit_original_dir, resource_kit_original_dir):
            rebuild_artifact_kit("original", silent=True)

    elif args.av:
        print(Fore.CYAN + "\nüß¨ Enabling AV Bypass...\n")
        time.sleep(0.4)
        if switch_files(artifact_kit_bypass_dir, resource_kit_bypass_dir):
            rebuild_artifact_kit("bypass", silent=True)

    else:
        show_menu()
        choice = input("Choose an option (1-4): ").strip()
        if choice == "1":
            if switch_files(artifact_kit_original_dir, resource_kit_original_dir):
                rebuild_artifact_kit("original")
        elif choice == "2":
            if switch_files(artifact_kit_bypass_dir, resource_kit_bypass_dir):
                rebuild_artifact_kit("bypass")
        elif choice == "3":
            current_patch = os.path.join(artifact_kit_replace_dir, "patch.c")
            bypass_patch = os.path.join(artifact_kit_bypass_dir, "patch.c")
            if os.path.exists(current_patch) and os.path.exists(bypass_patch):
                with open(current_patch, 'rb') as curr_file, open(bypass_patch, 'rb') as bypass_file:
                    if curr_file.read() == bypass_file.read():
                        print(Fore.GREEN + "\nüîç Current Mode: AV BYPASS ENABLED")
                    else:
                        print(Fore.YELLOW + "\nüîç Current Mode: ORIGINAL (No AV Evasion)")
            else:
                print(Fore.RED + "\n‚ö†Ô∏è  Unable to determine current mode. Missing reference files.")
        elif choice == "4":
            print("üëã Exiting...")
        else:
            print("‚ùå Invalid choice. Exiting.")

if __name__ == "__main__":
    main()

```