This Learning Unit covers the following Learning Objectives:

1. Discover the SSRF vulnerabilities
2. Exploit the SSRF vulnerabilities

In this Learning Unit, we will review two SSRF vulnerabilities found in _Group Office_,[1](https://portal.offsec.com/courses/web-200-28380/learning/server-side-request-forgery-34430/case-study-group-office-34513/case-study-group-office-34520#fn-local_id_865-1) an enterprise CRM and groupware tool. Fatih Çelik[2](https://portal.offsec.com/courses/web-200-28380/learning/server-side-request-forgery-34430/case-study-group-office-34513/case-study-group-office-34520#fn-local_id_865-2) discovered one vulnerability, which has been documented as CVE-2021-28060.[3](https://portal.offsec.com/courses/web-200-28380/learning/server-side-request-forgery-34430/case-study-group-office-34513/case-study-group-office-34520#fn-local_id_865-3) Offensive Security discovered the second SSRF vulnerability. We will approach both vulnerabilities from a black box perspective and find a way to exploit CVE-2021-28060 beyond the initial disclosure.

-----------
#### 12.4.1. Accessing Group Office
We'll access the Group Office application via an /etc/hosts file entry on our Kali Linux VM.

```bash
kali@kali:~$ sudo mousepad /etc/hosts

kali@kali:~$ cat /etc/hosts
127.0.0.1       localhost
127.0.1.1       kali

# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters

192.168.50.105  groupoffice
```
Let's start the virtual machine below and make the corresponding IP address update on our Kali machine before starting our work. We'll use this VM throughout the Learning Unit.

We can access the web application interface at the URL below.

| **URL**            | **Username** | **Password** |
| ------------------ | ------------ | ------------ |
| http://groupoffice | admin        | password     |



-------------

#### 12.4.2. Discovering the SSRF Vulnerabilities
We will start by opening Burp Suite, turning off Intercept if it is enabled, and opening the embedded browser. Next, we will access the login page at `http://groupoffice/`.
![[Pasted image 20241104164404.png]]

We will enter the provided credentials and click _Next_.

When assessing a new application, we should always spend some time exploring the application to get a sense for what the application does and any interesting functionality. In this case, we can add "portlets" to the "Start page" by clicking the _Add_ button.

![[Pasted image 20241104164503.png]]
We'll click _News_ on the resulting pop-up window.
![[Pasted image 20241104164522.png]]
After the pop-up window closes, we have a "News" frame added to the Start page.
![[Pasted image 20241104164543.png]]
Let's try configuring this new portlet by clicking on the gear in the top-right corner of the frame. The application will open a new window titled "Rss Feeds".
![[Pasted image 20241104170524.png]]

This new window includes a table with three columns: Title, URL, and Summary. The _URL_ field should stand out based on what we've learned about SSRF vulnerabilities and "suggestive" parameters in this Learning Module. If the application does send a request to the URL, we'll need a way to verify it. Let's use the Apache server on our Kali VM and submit our IP address in the _URL_ field.

First, we'll use systemctl to restart our Apache service.

```bash
kali@kali:~$ sudo systemctl restart apache2
```

Now that we have Apache running, we'll return to our browser and click _Add_. We'll then enter "Test" in the _Title_ field and our Kali IP address in the _URL_ field. Since we're not sure what the _Summary_ checkbox does, we'll leave it unchecked for now.

![[Pasted image 20241104170725.png]]

After clicking _Save_, the window closes and we're back on the Start page with "Test" listed under News. Let's use tail to check our Apache access.log for any new connections.
![[Pasted image 20241104170833.png]]

```bash
kali@kali:~$ sudo tail /var/log/apache2/access.log
192.168.50.105 - - [17/Nov/2021:10:34:02 -0500] "GET / HTTP/1.1" 200 10956 "-" "Group-Office HttpClient 6.5.77 (curl)"
```

Excellent. The Apache server on our Kali VM received a request. According to the user-agent field, the application used curl to send the request. Curl supports multiple URL schemes so we may be able to access local files with the SSRF if the application does not perform any input validation on the URL value we submit.

Let's review the requests we've sent in Burp Suite. The Group Office site generates some requests automatically, so we may need to scroll through our history to find the requests that start with URIs like `/index.php?r=summary/rssFeed`.

![[Pasted image 20241104171021.png]]
The request to /index.php?r=summary/rssFeed/proxy seems particularly interesting because of the word "proxy" in the query string. Let's test if this is the request that generated the forged request to our Kali VM. We'll right-click on that request and send it to Repeater.

Next, we'll click on the _Repeater_ tab. We want to make sure this is the request that generates the forged request, so let's update the _feed_ parameter by appending `/repeater` to our IP address. This will give us a unique value to check for in our Apache logs when we verify if this endpoint generates the request to our server.

![[Pasted image 20241104171156.png]]
Let's click _Send_. The response from Group Office seems to include an HTTP 404 response page from our Kali VM.

Let's check our Apache access log and verify we received the forged request.

```bash
kali@kali:~$ sudo tail /var/log/apache2/access.log
192.168.50.105 - - [17/Nov/2021:10:34:02 -0500] "GET / HTTP/1.1" 200 10956 "-" "Group-Office HttpClient 6.5.77 (curl)"
192.168.50.105 - - [17/Nov/2021:10:55:39 -0500] "GET /repeater HTTP/1.1" 404 437 "-" "Group-Office HttpClient 6.5.77 (curl)"
```
Excellent. We have a request to /repeater in our access log and the Group Office seems to render the HTTP 404 response page. We may be able to use this technique to access the results of the SSRF vulnerability.

Before we move on to exploitation, let's continue to explore the application. We can find another interesting feature in the _My Account_ page, which we can access by clicking the silhouette in the upper right-hand corner.

![[Pasted image 20241104171333.png]]
We'll then click _My account_ on the pop-up list and then click _Account_. On the resulting page, we can click on the silhouette in the upper left-hand corner to get yet another list of options.

![[Pasted image 20241104171442.png]]
The _From URL_ option seems interesting. Let's click on that.
![[Pasted image 20241104171449.png]]
After clicking _Ok_, the user profile picture changed from a silhouette to a grey circle, so something happened. Let's check our access log for any new requests.
```bash
kali@kali:~$ sudo tail /var/log/apache2/access.log
...
192.168.50.105 - - [17/Nov/2021:11:25:45 -0500] "GET /fromurl HTTP/1.1" 404 437 "-" "Group-Office HttpClient 6.5.77 (curl)"<c/r>
```

It seems we have found another SSRF vulnerability. Since we're updating the user's profile picture, we should be able to retrieve the results of the SSRF vulnerability. However, we just requested a page from our Kali VM that does not exist. Let's check the _HTTP history_ tab in Burp Suite to find the request that triggers the SSRF.

We may have to scroll through auto-generated requests to find the GET request to `/api/upload.php`.

![[Pasted image 20241104171605.png]]
This request includes the URL we submitted. Let's send this request to Repeater so we can resend it later. Interestingly, the response to our request includes a `"blobId"` and the subsequent request is to `/api/thumb.php` with the blob value included.

![[Pasted image 20241104171737.png]]

The server responded to `/api/thumb.php` with an HTTP 500 error. Perhaps this is because our URL didn't return anything. We'll send this request to Repeater as well.

Now let's create a valid page and retry this attack. We'll echo `"it worked"` into a file and move the file to our Apache server's web root.

```bash
kali@kali:~$ echo "it worked" > itworked.html
                      
kali@kali:~$ sudo mv itworked.html /var/www/html/itworked.html
```
Now that we have a simple HTML file, let's go back to the Repeater tab with the request to `/api/upload`. We'll update the _url_ parameter to use our new file.

![[Pasted image 20241104172011.png]]

The response includes a new _blobId_ value. Let's copy that value and switch to the Repeater tab with the request to /api/thumb.php. We'll replace the old _blobId_ value with the new one and click _Send_.

![[Pasted image 20241104172128.png]]

Unfortunately, the server responded with an HTTP 500 Internal Server Error. The error message indicates the application treats the file we requested as an image. We created a simple HTML file, which will lack the metadata an image file contains. It may be more difficult to retrieve the results from this second SSRF vulnerability. Still, we have two different attack vectors. In the next section, we'll attempt to exploit both of them.


##### Labs
1. `OS{7299df6b4bff259de04b17d3c2079c89}`

![[Pasted image 20241104172827.png]]
in `RSS FEED` added the location `http://flag/` as `exercise 1`
![[Pasted image 20241104172908.png]]
Checked Burpsuite for flag 
![[Pasted image 20241104172955.png]]

--------------

#### 12.4.3. Exploiting the SSRF Vulnerabilities

Let's return to the first SSRF vulnerability we identified in the RSS feed functionality. From the User-Agent header, we know that the application uses curl to send the request. We should be able to access other URL schemes since we control the entire URL value.

We will go back to our tab in Repeater with the request to `/index.php?r=summary/rssFeed/proxy`. Let's try to access a file on the application's OS. We'll update the `feed` parameter to `file:///etc/passwd` and then click _Send_.

![[Pasted image 20241104173118.png]]

Unfortunately, the application returned an empty response. Perhaps the application includes server-side logic to block the file scheme or performs some validation on the file contents before displaying it.

We're left with a bit of a conundrum. We have one SSRF vulnerability that renders the results but seems to block the file scheme. We have another SSRF vulnerability that we haven't tested for the file scheme, but we cannot retrieve the results. Let's explore the application some more. Maybe we'll find another feature that can help us.

Let's start by clicking on the _Address book_.

![[Pasted image 20241104173241.png]]

Interestingly, the users in the address book include profile pictures. Two of the pictures are gray circles, like the one shown for our admin user when we updated the profile with an invalid image. If we click on _John Smith_ and then click the profile picture, our browser will open a new tab.
![[Pasted image 20241104173301.png]]

Notice that this new URL includes a _blob_ in the query string. We should recall that our previous attempt at an SSRF attack against /api/upload returned a _blobId_ value. Let's return to that request in Repeater and retrieve the _blobId_ value.

We'll update the _blob_ value in the `http://groupoffice/api/download.php` URL and reload the page.

![[Pasted image 20241104173643.png]]
![[Pasted image 20241104173700.png]]
![[Pasted image 20241104173729.png]]

Nice. We retrieved the HTML file we loaded with the second SSRF vulnerability. Let's send this request to http://groupoffice/api/download.php to Repeater so we can reuse it later. Next, let's determine if we can access local file contents. In Repeater with the request to /api/upload, we'll change the _url_ parameter to `file:///etc/passwd` and click _Send_.

![[Pasted image 20241104174053.png]]
We received an HTTP 201 Created response with a new _blobId_ value. Let's copy the value, switch tabs in Repeater to the `/api/download.php` request, and replace the _blob_ value. We'll then _Send_ the request to the server.

![[Pasted image 20241104174127.png]]
Excellent! By exploiting the SSRF vulnerability in the image upload to get a _blobId_ value, and using the download URL with that value, we can access files from the underlying server. As this example illustrates, not all attacks are straightforward. Sometimes we must use other functionality within the application to access the results of our attack. Once we can read files from the server, we can search for configuration files or credentials that we can use for other attacks against the application or server.

##### TLDR:
using upload.php to grab new blobs such as `/etc/passwd` then in download browsing to that blobid to look at the file.


##### Labs
1.
`OS{eda404efc5fccd80d1a47f855a39e700}`
![[Pasted image 20241104174626.png]]
utilized the `/api/upload.php` to browse to `/tmp/flag.txt` this created with a `HTTP201` and gave me a new `blobID`
`BLOBID:`
```bash
"blobId":"a536dc38a65832af27b3635ddb6463ac98ef8c4c"
```
![[Pasted image 20241104174347.png]]
submitted the new `blobID` to  the `/api/download.php` endpoint to get flag
![[Pasted image 20241104174526.png]]

2.
`groupoffice`
![[Pasted image 20241104174758.png]]
using the `/api/upload.php` endpoint search for the endpoint using payload
```bash
file%3a///etc/groupoffice/config.php
```
get the new `BloBID:`
```bash
"blobId":"49b5ad9556a5edf37c19954ea15e4901d17228a5"
```
![[Pasted image 20241104174853.png]]
Plug in the new `blobID` into the `/api/download.php` endpoint and profit
![[Pasted image 20241104175053.png]]