#### Server XSS

Server XSS occurs when untrusted user supplied data is included in an HTML response generated by the server. The source of this data could be from the request, or from a stored location. As such, you can have both Reflected Server XSS and Stored Server XSS.

In this case, the entire vulnerability is in server-side code, and the browser is simply rendering the response and executing any valid script embedded in it.

#### Client XSS

Client XSS occurs when untrusted user supplied data is used to update the DOM with an unsafe JavaScript call. A JavaScript call is considered unsafe if it can be used to introduce valid JavaScript into the DOM. This source of this data could be from the DOM, or it could have been sent by the server (via an AJAX call, or a page load). The ultimate source of the data could have been from a request, or from a stored location on the client or the server. As such, you can have both Reflected Client XSS and Stored Client XSS.

#### Payload Cheatsheet:
```html
<h1>offsec</h1> - used for initial HTML injection
```

```js
<script>alert(0)</script> - used to display alerts
<img src='x' onerror='alert(1)'> - used to bypass innerHTML (found in network packets) and allow scripts
```

--------------

This Learning Unit covers the following Learning Objectives:

1. Understand the different types of XSS
2. Exploit reflected server XSS
3. Exploit stored server XSS
4. Exploit reflected client XSS
5. Exploit stored client XSS

While Cross-Site Scripting is the formal name, it's easier to think of it as JavaScript injection. As attackers, we are injecting code that will be executed in the victim's browser. It's important to note that XSS vulnerabilities can't directly lead to remote code execution of the server. Instead, XSS attacks target the users of the application. These vulnerabilities exploit the trust that the user has in the application they are visiting.

Unlike many other vulnerabilities, a cross-site scripting vulnerability is not exploited because an application accepts untrusted user input. Instead, an application is vulnerable because it **outputs** untrusted input. While the exploit payload must come in from an untrusted source, it does not become an XSS exploit until the payload is sent back to a user.

Even if the application does not complete any input sanitization, a payload that is properly sanitized when it is outputted will leave no path to XSS. On the contrary, if the application does perfect XSS sanitization input but no encoding on output, the application may still be vulnerable to XSS if an attacker can inject content via other means (admittedly, this is very rare).

Cross-site scripting can be classified into two main types: reflected and stored. The main difference being that stored is persistent and reflected is not. A reflected XSS payload is only exploited via a crafted link or a targeted redirect from another site. Conversely, a stored XSS, as the name implies, saves the payload into the database. This means multiple victims can fall prey to a stored XSS exploit through general navigation around the site, which makes stored XSS much more dangerous. The _stored_ and _reflected_ classifications refer to the level of persistence of the payload.

In addition, stored and reflected XSS can also be classified either by server XSS or client XSS. This refers to the location in the application architecture that the payload is outputted. With server XSS, the application server is appending the untrusted user input to the HTML document without any output encoding. With client XSS, the non-malicious client-side JavaScript is appending untrusted user input to the DOM without any further encoding. This is important because client XSS is much harder to discover. While server XSS can be discovered by sending a request and reviewing the response, client XSS must be discovered by using a browser or auditing the front-end JavaScript code.

**Historically, XSS has been broken down into three categories: stored, reflected, and DOM-based. The term "DOM-based" is what we now call "client XSS". The three categories paint an inaccurate picture of the XSS landscape. Using these three categories, a student would naturally assume that an XSS vulnerability can be either stored, reflected, or DOM-based. This is not true. A vulnerability can be either stored server XSS, stored client XSS, reflected server XSS, or reflected client XSS. XSS terminology has been neglected for years and this has caused much confusion in the industry.**

Regardless of the location or the likelihood of a XSS exploit, all XSS vulnerabilities require some form of user interaction. In addition, the victim must have different access than the access we have as attackers. We can't exploit a user with access equivalent to a public user. This could be a user authenticated with a standard session cookie, a user authenticated because of the IP address they are accessing from, or a user who has used an app to store sensitive data in their local storage.

In this Learning Unit, we'll review reflected server XSS, stored server XSS, reflected client XSS, and stored client XSS. Using the XSS Sandbox application, we'll demonstrate the various exploits with a focus on discovering the XSS vulnerability and escaping out of various entry points. We won't be focusing on bypassing authentication, keylogging, or any other exploitation method here.

----------
#### 4.3.1. Reflected Server XSS
- If we send a request to the server and our payload is shown in the response we know that it is Reflected Server XSS

Reflected server XSS is often found in locations where user input is sent via GET parameters. To exploit it, we would typically send a link to a user with the payload. Since the user trusts the domain, they'll click the link, the server will append our payload, and the user's browser will execute the payload. Unlike email phishing campaigns, we don't have to worry about making the domain "look" realistic since the user should already trust the domain being sent.

It's possible for POST parameters to also result in reflected XSS. However, we wouldn't be able to phish a user via a link. Instead, we would have to phish the user to a site we control and have a form auto-post when a user visits. Although, the likelihood of all of this aligning is much slimmer than a site being vulnerable via GET parameters. For this reason, we'll be focusing on reflected XSS vulnerabilities via GET parameters.

For most of this section, we'll use Firefox to discover the vulnerability and build the payload. We'll use the Search application found on the XSS sandbox.

Navigate to `http://xss-sandbox/challenge/search` - ensure that /etc/hosts is change to correct IP
![[Pasted image 20240729134850.png]]
type in `offsec` and hit search
![[Pasted image 20240729135046.png]]
This search engine isn't very useful. In addition to the search term being added to the _s_ parameter, we notice that it was also appended to the search page HTML. Let's inspect this in the DOM to understand how it was appended to the document. We'll select the search term, right click, and click _Inspect Element_.

Once Inspecting use `CTRL-F` and search for the term `offsec` 
We find here that the keyword was injected into a _div_ element. If the _s_ parameter is vulnerable to XSS, we won't have to escape out of any existing HTML tags. A good place to start with XSS testing is to first attempt HTML injection. Instead of injecting JavaScript code to be executed, we can inject basic HTML tags and review if they are rendered. HTML injection has less potential for error so it's a great control for our testing. Being able to inject HTML doesn't always mean that we can inject JavaScript, but it's a great indicator. Let's try to search for `<h1>offsec</h1>` and review the response to determine if the HTML was rendered.
![[Pasted image 20240729135555.png]]
Before hitting enter
![[Pasted image 20240729135910.png]]
After hitting enter - the translation means that it was rendered
![[Pasted image 20240729135953.png]]
When we searched for a term with HTML, the HTML was rendered instead of escaped! This most likely means that we'll be able to inject JavaScript as well. Let's try this. We will use the standard _alert()_ function to validate the proof-of-concept works. The payload we'll be submitting is: `<script>alert(0)</script>`, which should display an alert box when rendered.
![[Pasted image 20240729140213.png]]
After hitting Ok
![[Pasted image 20240729140241.png]]
```java
search.php?s=%3Cscript%3Ealert%280%29%3C%2Fscript%3E
```

Next, let's click _Render_ on the XSS Sandbox to have the victim render the page as well. The URL above is the same URL that the victim will be visiting. Normally, this would be sent through an email, chat message, or a link on another site.
![[Pasted image 20240729140451.png]]
When the target user renders the page, we find an alert box is displayed. This means we've successfully injected a XSS payload to our target.

Now, let's exploit this in Burp Suite to confirm the server is appending the payload. If we send a request to the server and our payload is included in the response, we know that this is a reflected server XSS. We'll begin by starting Burp Suite and visiting the Proxy tab.


Opened up Burpsuite browser and browsed to `http://xss-sandbox/challenge/search`
Sent the payload `<script>alert(0)</script>`
![[Pasted image 20240729175142.png]]
Hit `OK` and it got translated to `html`
![[Pasted image 20240729175233.png]]
If we click on the _Response_ tab, we can indeed find that our payload was reflected directly in the content.
![[Pasted image 20240729175505.png]]

##### Labs
![[Pasted image 20240729175638.png]]
Navigate to the `Donate` tab
![[Pasted image 20240729175714.png]]
Changed the name to `george` for testing
![[Pasted image 20240729175832.png]]
In burpsuite the class changed to reflect `george`
![[Pasted image 20240729175923.png]]
testing field with `<script>alert(0)</script>` html script.
Before hitting `OK`
![[Pasted image 20240729180011.png]]
After hitting `OK` you can see the html renders to `%3Cscript%3Ealert(0)%3C/script%3E` this means that XSS is vulnerable
![[Pasted image 20240729180051.png]]
can see the change in the `h3 class` with the alert changing
![[Pasted image 20240729180225.png]]
If a `user` browses to the website a alert pops up because an attacker injected an alert script to the website via java script injection or reflective XSS 
![[Pasted image 20240729180757.png]]
`OS{StopCopyingMe}`
![[Pasted image 20240729180849.png]]

--------------------------------------------------
#### 4.3.2 Stored Server XSS

Unlike reflected XSS, stored XSS does not require us to send a specially-crafted link. Instead, any user that visits the vulnerable page, rendering the stored XSS, will execute the payload. Because of this, we don't have to worry about limiting our payload to GET requests. For this example, we'll use the _Blog_ application found on the XSS Sandbox. During most of this section, we'll use Firefox to discover the vulnerability and build the payload.
![[Pasted image 20240729181334.png]]
At the bottom of the page, we find that the application allows us to post a comment. Let's post a comment and check how the application responds.
utilized `bugs` as the username and `Indeed!` as the comment
![[Pasted image 20240729181647.png]]
Inspecting the page and `ctrl f` to search for `bugs`

![[Pasted image 20240729181804.png]]
We find that the name and comment were added. Let's try to inject an H1 tag into the comment and review the output. If the HTML is rendered, then we can move on and try to inject JavaScript. We'll set the same username, "bugs", but set the comment to `<h1>Hello</h1>`.
![[Pasted image 20240729181955.png]]
Instead of getting a big "hello", the HTML tag was not rendered. Let's inspect the element to understand what's going on. We'll select the comment, right click, and click "Inspect Element".
![[Pasted image 20240729182127.png]]
Strange. We seem to be showing HTML tags. Why isn't this rendering? To find the answer, let's right-click on the element and click _Edit as HTML_.
![[Pasted image 20240729182222.png]]

![[Pasted image 20240729182333.png]]\
The server seems to have encoded the HTML characters. Instead of "<", the server changed it to "&lt" to ensure that the browser would not treat the user input as HTML. Unfortunately, this most likely means this parameter is not vulnerable. Let's not give up just yet though. Let's try the username parameter. We'll visit /reset in our hacker browser to clean the database first. This isn't mandatory, but will ensure we have a clean work surface.

![[Pasted image 20240729182719.png]]
We'll use the same payload for the username `<h1>Hello</h1>`.
![[Pasted image 20240729182902.png]]
When the comment is submitted, we should find that the H1 HTML tag we injected is rendered!
![[Pasted image 20240729183001.png]]

Now that we know we can inject HTML, let's attempt to inject JavaScript. We'll use the _alert()_ function as the JavaScript to execute since it will give us a clear indicator that the XSS was executed. Again, we'll reset the database. Once reset, we'll use `<script>alert(0)</script>` as the payload. However, since the HTML will be rendered as the username, it will be very clear to the administrator which comment contains the exploit. Instead, we'll attempt to be a bit sneakier by prepending the name "John" to the payload. This way, the username field won't be empty once everything is rendered.

![[Pasted image 20240729183404.png]]
`John<script>alert(0)</script>`
![[Pasted image 20240729183542.png]]
When we submit the payload, we execute the injected XSS directly in our browser first so an alert box with "0" is displayed. Once we close the alert, we can render the payload in the target user browser by clicking _Render_ in the control panel.
![[Pasted image 20240729183643.png]]
Interestingly, we find that no specially crafted link is required to exploit the vulnerability. Any user visiting this page will receive an alert box.
![[Pasted image 20240729183745.png]]
Looking at the Burpsuite Response request i am able to see the changes of the script and `hello` comment
![[Pasted image 20240729200706.png]]
##### Labs
- Didnt work, requested to be added to lab discord, awaiting approval - moving on for now
	- Got added to the discord, [OffSec](https://portal.offsec.com/courses/osa-web-200-43711/learning/videos/week-3-cross-site-scripting-exploitation-and-case-study-46716/live-session-46717/live-session-46715) this link shows how to do it
	

![[Pasted image 20240729184107.png]]
Script to use for testing `<script>alert(0)</script>`

initial testing with `bugs` and `1`
![[Pasted image 20240729200911.png]]
can see that both name and guests fields were modified in the class
![[Pasted image 20240729201012.png]]
looks like the `id=1` field might be testable, going to test it with the script `<script>alert(0)</script>`
![[Pasted image 20240729201139.png]]
looks like the `html` was rendered but gave out an error due to it not being a number - properly fixed in the comment field
![[Pasted image 20240729201218.png]]
Inserting the script into the Name field `<script>alert(0)</script>` made the `id=2`
![[Pasted image 20240729201418.png]]
Evaluating the burp request shows the `&lt` meaning that this field is likely not vulnerable
![[Pasted image 20240729201621.png]]
Booting up the new VM
![[Pasted image 20240729202337.png]]

`<h1>Hello</h1>`

##### Solving
- [OffSec](https://portal.offsec.com/courses/osa-web-200-43711/learning/videos/week-3-cross-site-scripting-exploitation-and-case-study-46716/live-session-46717/live-session-46715) @ 27 minutes
On this page inspect the webpage
![[Pasted image 20240729211925.png]]
You will see in this class below that you are able to change the requrement from `number` to `text`
![[Pasted image 20240729212139.png]]
with the Edit as HTML function
![[Pasted image 20240729212251.png]]
Once the `input type` is changed to text we are able to get the `Stored Server XSS` to work
![[Pasted image 20240729212451.png]]
Now if we look at the Burp Response can see that the script was taken
![[Pasted image 20240729212625.png]]
Profit
![[Pasted image 20240729212702.png]]
`OS{IWontForgetThis}`

![[Pasted image 20240729212954.png]]

--------------------------------------------------
#### 4.3.3 Reflected Client XSS

While the impact for client XSS is mostly the same as server XSS, the discovery and payload may differ. Since the payload is appended on the client-side rather than the server-side, there is a layer of abstraction that we have to handle. Unlike server XSS, we cannot discover client XSS by reviewing the requests and response. Instead, we need to have a browser render the page fully to discover if the payload worked.

Since the payload is added to the content by the client, we can also discover client XSS vulnerabilities by reviewing the client JavaScript. We'll quickly review the code to confirm the vulnerability, but deep source code review is out of scope for this section.

The target will be the "Survey" application in the XSS sandbox. Again, we'll use Firefox to discover and attack the application. When we visit the page, we should notice immediately that the name of the user is provided in the _name_ query parameter. This name is also reflected on the page for the "welcome" message. This should trigger our hacking senses.

![[Pasted image 20240729205958.png]]
Let's wrap the name in H1 tags to find if we can inject HTML. We can type in `<h1>Jason</h1>` and our browser will automatically encode the parameter before it sends the request.

Before render
![[Pasted image 20240729210106.png]]
After render
![[Pasted image 20240729213121.png]]
The HTML is rendered and the name is now in bold. Let's use the Firefox network tools to review the raw response so we can confirm that this is indeed a client XSS. To do this, we'll open the network utility by clicking the hamburger icon at the top-right and clicking on _Web Developer_ > _Network_.
![[Pasted image 20240729213319.png]]
If we click the request, we'll open yet another window pane with multiple tabs. One of the tabs is "Response", which contains the raw response that the server sent. However, if we click the _Response_ tab, Firefox will attempt to render a preview of the HTML without any JavaScript. We'll close this pane by clicking on _Preview_.

Click the switch to see the raw
![[Pasted image 20240729213939.png]]
Once the preview pane is closed, we're left with the "Response Payload" pane. From here, we can find that the original welcome message simply said "Welcome, User!". This isn't what's being rendered on our end. Where could our payload be rendered?

In Figure 48, we find additional resources loaded on this page. The css pages probably don't have any logic that changes the welcome messages. The `jquery.min.js` file contains an external library. Finally, `survey.js` seems to be custom to this application. We might find a clue in this file so we'll click on it to review it.

`jquery.min.js` didnt contain anything - posting this just to have notes to check it
![[Pasted image 20240729214826.png]]

Originialy my `survey.js` didnt contain any response packet
In order to fix that right click `survey.js` and hit resend
![[Pasted image 20240729214634.png]]
this resends a new `survey.js` with valid information
![[Pasted image 20240729214748.png]]
One of the first things this JavaScript file does is set the _innerHTML_ of the "welcome" DOM element to the value set in the _name_ query parameter. This is where we are injecting our HTML.

Next, let's try to inject an XSS payload. We'll start with our standard alert payload: `<script>alert(0)</script>`.
![[Pasted image 20240729215011.png]]
The page loads, but the payload does not execute. The name in the welcome message is blank as well. Let's investigate to understand what might be going on. We'll select the welcome text, right click, and click _Inspect Element_.
![[Pasted image 20240729215157.png]]
When the Inspector tool opens, we'll have to expand the _p_ tag to show the contents of the message.

![[Pasted image 20240729215335.png]]

From this viewpoint, it seems that our injection was appended appropriately. Searching online for "innerHTML execute script tag" takes us to the MDN document for _innerHTML_,[1](https://portal.offsec.com/courses/web-200-28380/learning/cross-site-scripting-introduction-and-discovery-30964/cross-site-scripting-discovery-31284/reflected-client-xss-30996#fn-local_id_196-1) which states:

...HTML5 specifies that a `<\script>` tag inserted with innerHTML should not execute.

If we keep reading, Mozilla conveniently provides a workaround for us:

However, there are ways to execute JavaScript without using `<\script>` elements, so there is still a security risk whenever you use `innerHTML` to set strings over which you have no control.

The example they provide is:
```
const name = "<img src='x' onerror='alert(1)'>";
el.innerHTML = name; // shows the alert
```

payload to use `<img src='x' onerror='alert(1)'>`

![[Pasted image 20240729215557.png]]

Excellent! We were able to exploit a client XSS! There are many ways to exploit XSS and the _onerror_ attribute on an image is just one way. We can also use _onfocus_, _onclick_, _onload_, and many others.

(Mozilla, 2021), [https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML) [↩︎](https://portal.offsec.com/courses/web-200-28380/learning/cross-site-scripting-introduction-and-discovery-30964/cross-site-scripting-discovery-31284/reflected-client-xss-30996#fnref-local_id_196-1)

##### Labs
**Unlike server XSS, we cannot discover client XSS by reviewing the requests and response. Instead, we need to have a browser render the page fully to discover if the payload worked.**

- [OffSec](https://portal.offsec.com/courses/osa-web-200-43711/learning/videos/week-3-cross-site-scripting-exploitation-and-case-study-46716/live-session-46717/live-session-46715) @ 35 minutes
![[Pasted image 20240731120640.png]]

Inserted `<h1>Testing<h1>` to test the field - it is being translated
![[Pasted image 20240729220215.png]]
the field doesn't matter
![[Pasted image 20240731120750.png]]
When you hit share it spits out a csv base64 encoded string
![[Pasted image 20240731121056.png]]
Translated it is the payload is the same.
![[Pasted image 20240731121005.png]]
utilizing the innerHTML method of bypassing to execute a script `<img src='x' onerror='alert(1)'>`
![[Pasted image 20240731121500.png]]
due to `Client side XSS` we have to follow this **Unlike server XSS, we cannot discover client XSS by reviewing the requests and response. Instead, we need to have a browser render the page fully to discover if the payload worked.**

Before `base64` encoding
```html
#,User,active
<img src='x' onerror='alert(1)'>,Samantha,1
```
After `base64` encoded from clicking `Share`
```
list.com/?csv=IyxVc2VyLGFjdGl2ZQo8aW1nIHNyYz0neCcgb25lcnJvcj0nYWxlcnQoMSknPixTYW1hbnRoYSwxCg%3D%3D`
```
Input the new `shared URL` into the search bar - hit enter - then render, this will generate the flag
`OS{AKADOMXSS}`
![[Pasted image 20240731130637.png]]
![[Pasted image 20240731130751.png]]

--------------------------------------------------
#### 4.3.4 Stored Client XSS

Unlike reflected client XSS, stored client XSS does not require an attacker to send a specially-crafted URL to a victim. Instead, any user that visits the vulnerable page will automatically be exploited. We'll again use the Survey application in the XSS Sandbox with Firefox to test this. Let's use the application as intended and submit the survey as the default user, Jason.
![[Pasted image 20240731130909.png]]
We'll enter the user's age, city, and the remaining questions. At the end, we're taken to a page that shows the summary of our answers.
![[Pasted image 20240731131030.png]]
On this page, we find that a new query parameter, _result_, was added. If we refresh the page, we also find that the user's results display. If we remove the _result_ query parameter and visit the page, we are taken back to the user's result page again. It seems that the application only allows us to submit a survey once for a username. If the survey has been submitted, it shows the answers.

Let's change the name and submit the survey. However, this time we'll answer one of the questions with HTML. We'll use the name "Damir" and set the payload on the question that reads "Where are you from?" We'll encapsulate the city Sarajevo with H1 tags.

`<h1>Sarajevo<h1>`
![[Pasted image 20240731131416.png]]
If we review the source code of survey.js using the Network Tools, we'll find that this result table was added via client JavaScript and not the server.
Like before in order to get a response had to right click and refresh `survey.js`
![[Pasted image 20240731134939.png]]
If we review the source code of survey.js using the Network Tools, we'll find that this result table was added via client JavaScript and not the server.
- Because the `getData` function? - getting from the client.
![[Pasted image 20240731135221.png]]
However, unlike with the reflected XSS, the data was added via _append_. Let's try our standard alert payload again and review the output.

Again, we'll use a different name and set the payload at the same question.
`<script>alert(0)</script>`

![[Pasted image 20240731135729.png]]
worked
![[Pasted image 20240731135800.png]]
If we click past the alert box and reload the page, the alert box is displayed again. Let's render the page in the victim's browser to confirm that payload works. Since this is a stored XSS, the URL does not require any special payload.
![[Pasted image 20240731135903.png]]
Excellent! We have now exploited stored client XSS in a victim's browser.

##### Labs
`<h1>Sarajevo<h1>` payload test
![[Pasted image 20240731140132.png]]
testing payload `<script>alert(0)</script>` - worked
![[Pasted image 20240731140618.png]]
client side because its requesting input from the user
![[Pasted image 20240731141621.png]]
The yellow is where the script was uploaded, notice it is empty
`OS{ExExEsss}`
![[Pasted image 20240731141738.png]]

![[Pasted image 20240731141846.png]]